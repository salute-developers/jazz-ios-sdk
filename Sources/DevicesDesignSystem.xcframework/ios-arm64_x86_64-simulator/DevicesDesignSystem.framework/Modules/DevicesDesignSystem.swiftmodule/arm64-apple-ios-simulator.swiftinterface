// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.1 (swiftlang-5.7.1.135.3 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name DevicesDesignSystem
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Combine
import CoreGraphics
import CoreText
import DevicesCore
import DevicesUI
import Foundation
import MessageUI
import Swift
import SwiftUI
import UIKit
import _Concurrency
import _StringProcessing
public protocol Action {
}
public protocol ActionPerformer : AnyObject {
  @discardableResult
  func perform(_ action: DevicesDesignSystem.AnyAction, sender: DevicesDesignSystem.ActionSender) -> Swift.Bool
}
extension DevicesDesignSystem.ActionPerformer {
  @inlinable public func perform(_ actions: [DevicesDesignSystem.AnyAction], sender: DevicesDesignSystem.ActionSender) {
		actions.forEach {
			perform($0, sender: sender)
		}
	}
  @discardableResult
  @inlinable public func perform(_ action: DevicesDesignSystem.AnyAction) -> Swift.Bool {
		perform(action, sender: .unspecified)
	}
  @discardableResult
  @inlinable public func perform(_ action: DevicesDesignSystem.AnyAction, logId: DevicesDesignSystem.LogID?) -> Swift.Bool {
		perform(action, sender: ActionSender(elementType: nil, logId: logId))
	}
  @inlinable public func perform(_ actions: [DevicesDesignSystem.AnyAction], logId: DevicesDesignSystem.LogID? = nil) {
		perform(actions, sender: ActionSender(elementType: nil, logId: logId))
	}
}
public struct ActionSender : Swift.Equatable {
  public struct AdditionalData {
  }
  public let elementType: DevicesDesignSystem.ElementType?
  public let logId: DevicesDesignSystem.LogID?
  public let additionalData: [Swift.String : Swift.String]
  public init(elementType: DevicesDesignSystem.ElementType?, logId: DevicesDesignSystem.LogID?, additionalData: [Swift.String : Swift.String] = [:])
  public static func == (a: DevicesDesignSystem.ActionSender, b: DevicesDesignSystem.ActionSender) -> Swift.Bool
}
extension DevicesDesignSystem.ActionSender {
  public static var unspecified: DevicesDesignSystem.ActionSender {
    get
  }
}
final public class ActionSequencePerformer : DevicesDesignSystem.ActionPerformer {
  public init(_ performers: [DevicesDesignSystem.ActionPerformer])
  final public func perform(_ action: DevicesDesignSystem.AnyAction, sender: DevicesDesignSystem.ActionSender) -> Swift.Bool
  @objc deinit
}
extension DevicesDesignSystem.SheetModel {
  public init(title: DevicesUI.StringContent, titleAligment: DevicesUI.TextAlignment = .center, titleGravity: DevicesUI.HorizontalGravity = .center, description: DevicesUI.StringContent, descriptionAligment: DevicesUI.TextAlignment = .center, descriptionGravity: DevicesUI.HorizontalGravity = .center, contents: [DevicesUI.ViewRenderable], contentsGravity: DevicesUI.HorizontalGravity = .center, image: DevicesUI.ImageContent? = nil, background: DevicesUI.ViewRenderable? = nil)
}
public protocol ActivityItemsContainer {
  func setCompletionWithItemsHandler(_ handler: @escaping (DevicesDesignSystem.CloseShareScreenParameters) -> Swift.Void)
  func setExcludedActivityTypes(_ excludedShareDestinations: [DevicesDesignSystem.ShareScreenConfig.Destination])
}
public struct ActivityScreen : DevicesCore.ModalScreen, DevicesDesignSystem.ActivityItemsContainer {
  public let content: UIKit.UIActivityViewController
  public var viewController: UIKit.UIViewController {
    get
  }
  public func setCompletionWithItemsHandler(_ handler: @escaping (DevicesDesignSystem.CloseShareScreenParameters) -> Swift.Void)
  public func setExcludedActivityTypes(_ excludedShareDestinations: [DevicesDesignSystem.ShareScreenConfig.Destination])
  public init(content: UIKit.UIActivityViewController)
}
public struct Alert {
  public struct Button {
    public let title: DevicesUI.StringContent
    public let action: () -> Swift.Void
    public let style: DevicesDesignSystem.PlasmaButtonStyleID
    public init(title: DevicesUI.StringContent, action: @escaping () -> Swift.Void, style: DevicesDesignSystem.PlasmaButtonStyleID)
  }
  public let title: DevicesUI.StringContent
  public let subtitle: DevicesUI.StringContent?
  public let image: DevicesCore.ImageID?
  public let buttons: [DevicesDesignSystem.Alert.Button]
  public let hasBorderLine: Swift.Bool
  public init(title: DevicesUI.StringContent, subtitle: DevicesUI.StringContent?, image: DevicesCore.ImageID?, buttons: [DevicesDesignSystem.Alert.Button], hasBorderLine: Swift.Bool = false)
}
public typealias AlertScreenFactory = DevicesCore.Factory<DevicesDesignSystem.AlertScreenFactoryInput, DevicesCore.StackScreen>
public struct AlertScreenFactoryInput {
  public init(model: DevicesDesignSystem.Alert, dismissAlert: @escaping () -> Swift.Void)
}
public protocol AlertStackScreen : DevicesCore.StackScreen {
}
extension DevicesDesignSystem.AlertToastModel : DevicesUI.SingleSubjectRenderable {
  public var subject: DevicesUI.ViewRenderable {
    get
  }
}
public struct AlertToastModel {
  public let text: DevicesUI.StringContent
  public let iconImage: DevicesCore.ImageID?
  public let actionTitle: DevicesUI.StringContent
  public let action: (() -> Swift.Void)?
  public init(text: DevicesUI.StringContent, iconImage: DevicesCore.ImageID?, actionTitle: DevicesUI.StringContent, action: (() -> Swift.Void)?)
}
public struct AnalyticsAction : DevicesDesignSystem.Action, Swift.Equatable {
  public let event: DevicesCore.AnalyticsEvent
  public init(event: DevicesCore.AnalyticsEvent)
  public static func == (lhs: DevicesDesignSystem.AnalyticsAction, rhs: DevicesDesignSystem.AnalyticsAction) -> Swift.Bool
}
extension DevicesDesignSystem.AnalyticsAction {
  public func eraseToAnyAction() -> DevicesDesignSystem.AnyAction
}
extension DevicesDesignSystem.AnyAction {
  public static func analytics(event: DevicesCore.AnalyticsEvent) -> DevicesDesignSystem.AnyAction
}
final public class AnalyticsActionPerformer : DevicesDesignSystem.ActionPerformer {
  public init(analytics: DevicesCore.AnalyticsService)
  final public func perform(_ action: DevicesDesignSystem.AnyAction, sender _: DevicesDesignSystem.ActionSender) -> Swift.Bool
  @objc deinit
}
public enum AnimationCommand {
  case play(completion: ((Swift.Bool) -> Swift.Void)?)
  case playPartially(from: CoreFoundation.CGFloat, to: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)?)
  case playFromMarkerToMarker(from: DevicesDesignSystem.AnimationMarker?, to: DevicesDesignSystem.AnimationMarker, completion: ((Swift.Bool) -> Swift.Void)?)
  case setProgress(CoreFoundation.CGFloat)
}
public enum AnimationDurationID : Swift.String {
  case x1
  case x2
  case x3
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol AnimationDurationProvider {
  func duration(for value: DevicesDesignSystem.AnimationDurationID) -> Foundation.TimeInterval
}
public protocol AnimationID {
  var name: Swift.String { get }
}
extension DevicesDesignSystem.AnimationID where Self : Swift.RawRepresentable, Self.RawValue == Swift.String {
  public var name: Swift.String {
    get
  }
}
public enum AnimationMarkerTag {
}
public typealias AnimationMarker = DevicesCore.Tagged<DevicesDesignSystem.AnimationMarkerTag, Swift.String>
public struct AnimationModel : DevicesUI.ViewRenderable {
  public init(source: DevicesDesignSystem.AnimationSource, measurable: DevicesUI.Measurable = BlockMeasurable { $0 }, makeAnimationAreaFrame: @escaping (_ bounds: CoreFoundation.CGSize) -> CoreFoundation.CGRect = {
			CGRect(origin: .zero, size: $0)
		}, loopMode: DevicesDesignSystem.LottieLoopMode, backgroundBehavior: DevicesDesignSystem.LottieBackgroundBehavior = .pauseAndRestore, commandSignal: DevicesCore.Signal<DevicesDesignSystem.AnimationCommand>)
  public func renderView(context: DevicesUI.ViewContext, reusing _: DevicesUI.View?) -> DevicesUI.View
}
public enum AnimationSource {
  case animationId(DevicesDesignSystem.AnimationID)
  case model(DevicesDesignSystem.DynamicAnimation)
}
public struct AnyAction : Swift.Hashable {
  public let base: DevicesDesignSystem.Action
  public init<E>(_ base: E, equals: @escaping (E, E) -> Swift.Bool, hash: @escaping (E, inout Swift.Hasher) -> Swift.Void = { _, _ in }) where E : DevicesDesignSystem.Action
  public static func == (lhs: DevicesDesignSystem.AnyAction, rhs: DevicesDesignSystem.AnyAction) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.AnyAction {
  @inlinable public func perform<E>(when _: E.Type, using block: (E) throws -> Swift.Void) rethrows where E : DevicesDesignSystem.Action {
		guard let value = base as? E else {
			return
		}
		try block(value)
	}
  public init<E>(_ base: E) where E : DevicesDesignSystem.Action, E : Swift.Equatable
}
extension DevicesDesignSystem.CardBase {
  public func eraseToAnyCardBase() -> DevicesDesignSystem.AnyCardBase
}
public struct AnyCardBase : DevicesDesignSystem.CardBase {
  public let viewRenderable: DevicesUI.ViewRenderable
  public let elementType: DevicesDesignSystem.ElementType
  public let definesCardBackground: Swift.Bool
  public let canBeDisabled: Swift.Bool
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
  public static func == (lhs: DevicesDesignSystem.AnyCardBase, rhs: DevicesDesignSystem.AnyCardBase) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public init(viewRenderable: DevicesUI.ViewRenderable, elementType: DevicesDesignSystem.ElementType, definesCardBackground: Swift.Bool, canBeDisabled: Swift.Bool, equal: @escaping (_ rhs: DevicesUI.ViewRenderable) -> Swift.Bool, hashing: @escaping (DevicesUI.ViewRenderable, inout Swift.Hasher) -> Swift.Void)
  public init<V>(viewRenderable: V, elementType: DevicesDesignSystem.ElementType, definesCardBackground: Swift.Bool, canBeDisabled: Swift.Bool) where V : DevicesDesignSystem.CardBase
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.ArrayRightModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.ArrayRightModel.Content : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
public struct ArrayRightModel : Swift.Hashable {
  public enum Orientation : Swift.String, Swift.Hashable {
    case vertical
    case horizontal
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Content : Swift.Hashable {
    case disclosure(DevicesDesignSystem.DisclosureRightModel)
    case detail(DevicesDesignSystem.DetailRightModel)
    case flexibleImage(DevicesDesignSystem.FlexibleImageCellModel)
    case roundButton(DevicesDesignSystem.RoundButtonCellModel)
    case tag(DevicesDesignSystem.TagCellModel)
    case plasmaButton(DevicesDesignSystem.PlasmaButtonCellModel)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.ArrayRightModel.Content, b: DevicesDesignSystem.ArrayRightModel.Content) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public let items: [DevicesDesignSystem.ArrayRightModel.Content]
  public let orientation: DevicesDesignSystem.ArrayRightModel.Orientation
  public init(items: [DevicesDesignSystem.ArrayRightModel.Content], orientation: DevicesDesignSystem.ArrayRightModel.Orientation)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.ArrayRightModel, b: DevicesDesignSystem.ArrayRightModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.ArrayRightModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct AspectRatio<Dimension> : Swift.Hashable where Dimension : Swift.Hashable {
  public enum Major : Swift.Hashable {
    case width
    case height
    public static func == (a: DevicesDesignSystem.AspectRatio<Dimension>.Major, b: DevicesDesignSystem.AspectRatio<Dimension>.Major) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let value: CoreFoundation.CGFloat
  public let major: DevicesDesignSystem.AspectRatio<Dimension>.Major
  public let dimension: Dimension
  public init(value: CoreFoundation.CGFloat, major: DevicesDesignSystem.AspectRatio<Dimension>.Major, dimension: Dimension)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.AspectRatio<Dimension>, b: DevicesDesignSystem.AspectRatio<Dimension>) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct AssistantCharacterBackgroundModel {
  public let z0Color: UIKit.UIColor
  public let z1StartColor: UIKit.UIColor
  public let z1EndColor: UIKit.UIColor
  public let z2StartColor: UIKit.UIColor
  public let z2EndColor: UIKit.UIColor
  public let z3StartColor: UIKit.UIColor
  public let z3EndColor: UIKit.UIColor
  public let z4StartColor: UIKit.UIColor
  public let z4EndColor: UIKit.UIColor
  public init(z0Color: UIKit.UIColor, z1StartColor: UIKit.UIColor, z1EndColor: UIKit.UIColor, z2StartColor: UIKit.UIColor, z2EndColor: UIKit.UIColor, z3StartColor: UIKit.UIColor, z3EndColor: UIKit.UIColor, z4StartColor: UIKit.UIColor, z4EndColor: UIKit.UIColor)
}
public enum AvatarImageHelper {
  public static func defaultAvatar(_ title: Swift.String, size: CoreFoundation.CGSize, context: DevicesUI.ViewContext) -> UIKit.UIImage
}
extension DevicesDesignSystem.BackgroundColor : DevicesUI.ImageContent {
  public func image(context: DevicesUI.ViewContext) -> UIKit.UIImage
}
@available(*, deprecated, message: "Deprecated, use BackgroundColor")
public typealias Color = DevicesDesignSystem.BackgroundColor
public enum BackgroundColor : Swift.String, Swift.Decodable, Swift.CaseIterable {
  public static var allCases: [DevicesDesignSystem.BackgroundColor]
  case `default`
  case overlay
  case primary
  case secondary
  case tertiary
  @available(*, deprecated, message: "Color became Buttoncolor: globalBlack/globalWhite")
  case deprecatedPrimary
  @available(*, deprecated, message: "Color became Buttoncolor: globalBlackSecondary/globalWhiteSecondary")
  case deprecatedSecondary
  @available(*, deprecated, message: "Non-plazma. Contact designer. If color is ok - remove this message")
  case dragonBorn
  @available(*, deprecated, message: "Non-plazma. Contact designer. If color is ok - remove this message")
  case solidBlack
  @available(*, deprecated, message: "Non-plazma. Contact designer. If color is ok - remove this message")
  case solidWhite
  @available(*, deprecated, message: "Non-plazma. Contact designer. If color is ok - remove this message")
  case solidTransparent
  @available(*, deprecated, message: "Non-plazma. Contact designer. If color is ok - remove this message")
  case solidDisabled
  @available(*, deprecated, message: "Non-plazma. Contact designer. If color is ok - remove this message")
  case solidBrand
  @available(*, deprecated, message: "Non-plazma. Contact designer. If color is ok - remove this message")
  case solidWarning
  @available(*, deprecated, message: "Non-plazma. Contact designer. If color is ok - remove this message")
  case solidCritical
  @available(*, deprecated, message: "Non-plazma. Contact designer. If color is ok - remove this message")
  case solidAction
  case solidGreen
  case solidBlue
  @available(*, deprecated, message: "Non-plazma. Contact designer. If color is ok - remove this message")
  case liquid60
  @available(*, deprecated, message: "Non-plazma. Contact designer. If color is ok - remove this message")
  case liquid50
  @available(*, deprecated, message: "Non-plazma. Contact designer. If color is ok - remove this message")
  case liquid40
  @available(*, deprecated, message: "Non-plazma. Contact designer. If color is ok - remove this message")
  case liquid30
  @available(*, deprecated, message: "Non-plazma. Contact designer. If color is ok - remove this message")
  case liquid20
  @available(*, deprecated, message: "Non-plazma. Contact designer. If color is ok - remove this message")
  case liquid10
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DevicesDesignSystem.BackgroundColor]
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension DevicesDesignSystem.BackgroundColor : DevicesDesignSystem.ColorProtocol {
  public func value(characterSemantic: DevicesDesignSystem.CharacterSemantic, userInterfaceStyle: DevicesDesignSystem.UserInterfaceStyle) -> UIKit.UIColor
}
public struct BadgeModel : Swift.Equatable, Swift.Hashable {
  public let background: DevicesDesignSystem.GradientStyleID
  public let textColor: DevicesDesignSystem.TypeColor
  public let text: DevicesUI.StringContent?
  public let paddings: DevicesDesignSystem.Paddings
  public init(background: DevicesDesignSystem.GradientStyleID?, textColor: DevicesDesignSystem.TypeColor?, text: Swift.String?, paddings: DevicesDesignSystem.Paddings?)
  public static func == (lhs: DevicesDesignSystem.BadgeModel, rhs: DevicesDesignSystem.BadgeModel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.BadgeModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.BadgeModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct BannerModel : DevicesUI.ViewRenderable {
  public let content: DevicesUI.ViewRenderable
  public let background: DevicesUI.ViewRenderable?
  public init(content: DevicesUI.ViewRenderable, background: DevicesUI.ViewRenderable?)
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class BannerViewController : UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public init(model: DevicesDesignSystem.BannerModel, context: DevicesUI.ViewContext)
  @_Concurrency.MainActor(unsafe) @objc override final public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override final public func viewWillLayoutSubviews()
  @_Concurrency.MainActor(unsafe) final public func sizeThatFits(_ size: CoreFoundation.CGSize, safeAreaInsets: UIKit.UIEdgeInsets) -> CoreFoundation.CGSize
  @objc deinit
}
public struct BlockAction : DevicesDesignSystem.Action, Swift.Equatable {
  public let block: () -> Swift.Void
  public init(block: @escaping () -> Swift.Void)
  public static func == (_: DevicesDesignSystem.BlockAction, _: DevicesDesignSystem.BlockAction) -> Swift.Bool
}
extension DevicesDesignSystem.AnyAction {
  public static func block(_ block: @escaping () -> Swift.Void) -> DevicesDesignSystem.AnyAction
}
final public class BlockActionPerformer : DevicesDesignSystem.ActionPerformer {
  public init()
  final public func perform(_ action: DevicesDesignSystem.AnyAction, sender _: DevicesDesignSystem.ActionSender) -> Swift.Bool
  @objc deinit
}
@objc @_Concurrency.MainActor(unsafe) final public class BottomSheetTransition : ObjectiveC.NSObject, UIKit.UIViewControllerTransitioningDelegate {
  @_Concurrency.MainActor(unsafe) public init(animationDuration: Foundation.TimeInterval = 0.3, heightForPresentedView: DevicesCore.PresentedViewHeight, isInteractive: Swift.Bool, assertionCaller: DevicesCore.AssertionCaller)
  @_Concurrency.MainActor(unsafe) @objc final public func presentationController(forPresented presented: UIKit.UIViewController, presenting: UIKit.UIViewController?, source: UIKit.UIViewController) -> UIKit.UIPresentationController?
  @_Concurrency.MainActor(unsafe) @objc final public func animationController(forPresented _: UIKit.UIViewController, presenting _: UIKit.UIViewController, source _: UIKit.UIViewController) -> UIKit.UIViewControllerAnimatedTransitioning?
  @_Concurrency.MainActor(unsafe) @objc final public func animationController(forDismissed _: UIKit.UIViewController) -> UIKit.UIViewControllerAnimatedTransitioning?
  @_Concurrency.MainActor(unsafe) @objc final public func interactionControllerForPresentation(using _: UIKit.UIViewControllerAnimatedTransitioning) -> UIKit.UIViewControllerInteractiveTransitioning?
  @_Concurrency.MainActor(unsafe) @objc final public func interactionControllerForDismissal(using _: UIKit.UIViewControllerAnimatedTransitioning) -> UIKit.UIViewControllerInteractiveTransitioning?
  @objc deinit
}
public protocol Brandbook : AnyObject, DevicesDesignSystem.AnimationDurationProvider, DevicesDesignSystem.ColorProvider, DevicesDesignSystem.GradientProvider, DevicesDesignSystem.InsetsProvider, DevicesDesignSystem.MarkdownStyleProvider, DevicesDesignSystem.NativeStyleProvider, DevicesDesignSystem.SizeProvider, DevicesDesignSystem.TypographyProvider {
  func addObserver(_ observer: DevicesDesignSystem.BrandbookObserver)
  func removeObserver(_ observer: DevicesDesignSystem.BrandbookObserver)
}
extension DevicesDesignSystem.Brandbook {
  public func attributes(typeface: DevicesDesignSystem.Typeface, foregroundColor: DevicesDesignSystem.ColorProtocol, lineBreakMode: UIKit.NSLineBreakMode = .byTruncatingTail, alignment: UIKit.NSTextAlignment = .natural, useHyphen: Swift.Bool = false) -> [Foundation.NSAttributedString.Key : Any]
  public func attributes(typeface: DevicesDesignSystem.Typeface, typeColor: DevicesDesignSystem.TypeColor, lineBreakMode: UIKit.NSLineBreakMode = .byTruncatingTail, alignment: UIKit.NSTextAlignment = .natural, useHyphen: Swift.Bool = false) -> [Foundation.NSAttributedString.Key : Any]
}
final public class BrandbookImpl : DevicesDesignSystem.Brandbook {
  public init(device: DevicesDesignSystem.Device, userInterfaceStyle: DevicesCore.Property<DevicesDesignSystem.UserInterfaceStyle>, characterSemantic: DevicesCore.Property<DevicesDesignSystem.CharacterSemantic> = .constant(.salute), typographyProvider: DevicesDesignSystem.TypographyProvider? = nil, isModernBackgroundGradientEnabled: Swift.Bool, assertionCaller: DevicesCore.AssertionCaller)
  final public func addObserver(_ observer: DevicesDesignSystem.BrandbookObserver)
  final public func removeObserver(_ observer: DevicesDesignSystem.BrandbookObserver)
  @objc deinit
}
extension DevicesDesignSystem.BrandbookImpl {
  final public func value(for iconSize: DevicesDesignSystem.Icon.Size) -> CoreFoundation.CGSize
  final public func value(for dimension: DevicesDesignSystem.Icon.Size.Dimension) -> CoreFoundation.CGFloat
  final public func value(for contentWidth: DevicesDesignSystem.GridContentWidth, canvasWidth: CoreFoundation.CGFloat) -> DevicesDesignSystem.LayoutGridMetrics
}
extension DevicesDesignSystem.BrandbookImpl {
  final public func value(for insets: DevicesDesignSystem.Insets) -> UIKit.UIEdgeInsets
  final public func value(for inset: DevicesDesignSystem.Dimensions) -> CoreFoundation.CGFloat
}
extension DevicesDesignSystem.BrandbookImpl {
  final public func value(for color: DevicesDesignSystem.BackgroundColor) -> UIKit.UIColor
}
extension DevicesDesignSystem.BrandbookImpl {
  final public func value(for typeColor: DevicesDesignSystem.TypeColor) -> UIKit.UIColor
}
extension DevicesDesignSystem.BrandbookImpl {
  final public func value(for speechBubbleColor: DevicesDesignSystem.SpeechBubbleColor) -> UIKit.UIColor
}
extension DevicesDesignSystem.BrandbookImpl {
  final public func value(for styleID: DevicesDesignSystem.GradientStyleID) -> DevicesUI.GradientConfig
}
extension DevicesDesignSystem.BrandbookImpl {
  final public func value(for assistantCharacterBackgroundColor: DevicesDesignSystem.CharacterSemantic) -> DevicesDesignSystem.AssistantCharacterBackgroundModel
}
extension DevicesDesignSystem.BrandbookImpl {
  final public func makeGlyphTypo(for typeface: DevicesDesignSystem.Typeface) -> DevicesDesignSystem.GlyphTypo
}
extension DevicesDesignSystem.BrandbookImpl {
  final public func value(for size: DevicesDesignSystem.DividerModel.Size) -> UIKit.UIEdgeInsets
}
extension DevicesDesignSystem.BrandbookImpl : DevicesDesignSystem.NativeStyleProvider {
  final public var interfaceStyle: DevicesDesignSystem.UserInterfaceStyle {
    get
  }
}
extension DevicesDesignSystem.BrandbookImpl {
  final public var markdownStyle: DevicesCore.MarkdownStyler {
    get
  }
}
extension DevicesDesignSystem.BrandbookImpl {
  final public func value(for smartAppColor: DevicesDesignSystem.SmartAppColor) -> UIKit.UIColor
}
extension DevicesDesignSystem.BrandbookImpl {
  final public func value(for paymentColor: DevicesDesignSystem.PaymentColor) -> UIKit.UIColor
}
extension DevicesDesignSystem.BrandbookImpl {
  final public func duration(for value: DevicesDesignSystem.AnimationDurationID) -> Foundation.TimeInterval
}
extension DevicesDesignSystem.BrandbookImpl {
  final public func value(for buttonColor: DevicesDesignSystem.ButtonColor) -> UIKit.UIColor
}
extension DevicesDesignSystem.BrandbookImpl {
  final public func value(for surfaceColor: DevicesDesignSystem.SurfaceColor) -> UIKit.UIColor
}
extension DevicesDesignSystem.BrandbookImpl {
  final public func value(for colorProtocol: DevicesDesignSystem.ColorProtocol) -> UIKit.UIColor
}
final public class BrandbookObject : DevicesDesignSystem.Brandbook, Combine.ObservableObject {
  final public var interfaceStyle: DevicesDesignSystem.UserInterfaceStyle {
    get
  }
  final public var markdownStyle: DevicesCore.MarkdownStyler {
    get
  }
  public init(_ subject: DevicesDesignSystem.Brandbook)
  final public func addObserver(_ observer: DevicesDesignSystem.BrandbookObserver)
  final public func removeObserver(_ observer: DevicesDesignSystem.BrandbookObserver)
  final public func value(for color: DevicesDesignSystem.BackgroundColor) -> UIKit.UIColor
  final public func value(for typeColor: DevicesDesignSystem.TypeColor) -> UIKit.UIColor
  final public func value(for speechBubbleColor: DevicesDesignSystem.SpeechBubbleColor) -> UIKit.UIColor
  final public func value(for assistantCharacterBackgroundColor: DevicesDesignSystem.CharacterSemantic) -> DevicesDesignSystem.AssistantCharacterBackgroundModel
  final public func value(for smartAppColor: DevicesDesignSystem.SmartAppColor) -> UIKit.UIColor
  final public func value(for paymentColor: DevicesDesignSystem.PaymentColor) -> UIKit.UIColor
  final public func value(for buttonColor: DevicesDesignSystem.ButtonColor) -> UIKit.UIColor
  final public func value(for surfaceColor: DevicesDesignSystem.SurfaceColor) -> UIKit.UIColor
  final public func value(for colorProtocol: DevicesDesignSystem.ColorProtocol) -> UIKit.UIColor
  final public func value(for styleID: DevicesDesignSystem.GradientStyleID) -> DevicesUI.GradientConfig
  final public func makeGlyphTypo(for typeface: DevicesDesignSystem.Typeface) -> DevicesDesignSystem.GlyphTypo
  final public func value(for insets: DevicesDesignSystem.Insets) -> UIKit.UIEdgeInsets
  final public func value(for inset: DevicesDesignSystem.Dimensions) -> CoreFoundation.CGFloat
  final public func value(for size: DevicesDesignSystem.DividerModel.Size) -> UIKit.UIEdgeInsets
  final public func value(for iconSize: DevicesDesignSystem.Icon.Size) -> CoreFoundation.CGSize
  final public func value(for dimension: DevicesDesignSystem.Icon.Size.Dimension) -> CoreFoundation.CGFloat
  final public func value(for contentWidth: DevicesDesignSystem.GridContentWidth, canvasWidth: CoreFoundation.CGFloat) -> DevicesDesignSystem.LayoutGridMetrics
  final public func duration(for value: DevicesDesignSystem.AnimationDurationID) -> Foundation.TimeInterval
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
}
public protocol BrandbookObserver : AnyObject {
  func brandbookDidUpdate(_ brandbook: DevicesDesignSystem.Brandbook)
}
extension Foundation.Bundle {
  public var designSystem: Foundation.Bundle {
    get
  }
}
extension DevicesUI.Button {
  public static func plasma(text: DevicesUI.StringContent, style styleID: DevicesDesignSystem.PlasmaButtonStyleID? = nil, icon: DevicesDesignSystem.ImageAddress? = nil, progress progressStyle: DevicesDesignSystem.ProgressSpinnerStyle? = nil, paddings: DevicesDesignSystem.Paddings? = nil, roundedCorners: DevicesDesignSystem.CornersRounding? = nil, isEnabled: Swift.Bool = true, action: @escaping () -> Swift.Void) -> DevicesUI.Button
}
public typealias ButtonCellModel = DevicesDesignSystem.SingleContentCellModel<DevicesDesignSystem.ButtonModel>
public enum ButtonColor : Swift.String, Swift.Decodable {
  case `default`
  case secondary
  case clear
  case success
  case warning
  case critical
  case checked
  case globalBlack
  case globalBlackSecondary
  case globalBlackTransparent
  case globalWhite
  case globalWhiteSecondary
  @available(*, deprecated, message: "То же что и primary цвета, в новой версии стилей их не будет")
  case accent
  @available(*, deprecated, message: "То же что и primary цвета, в новой версии стилей их не будет")
  case focus
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension DevicesDesignSystem.ButtonColor : DevicesDesignSystem.ColorProtocol {
  public func value(characterSemantic: DevicesDesignSystem.CharacterSemantic, userInterfaceStyle: DevicesDesignSystem.UserInterfaceStyle) -> UIKit.UIColor
}
public enum ButtonColorKind : Swift.String, Swift.Decodable {
  case accept
  case disabled
  case neutral
  case negative
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct ButtonDefaultStyle : DevicesUI.ButtonStyle {
  public static let defaultMargins: DevicesDesignSystem.Margins
  public init(margins: DevicesDesignSystem.Margins = Self.defaultMargins, backgroundColor: DevicesDesignSystem.ColorProtocol)
  public init(margins: DevicesDesignSystem.Margins = Self.defaultMargins, backgroundColor: DevicesDesignSystem.BackgroundColor)
  public init(margins: DevicesDesignSystem.Margins = Self.defaultMargins, kind: DevicesDesignSystem.ButtonColorKind)
  public func transformContent(config: DevicesUI.ButtonStyleConfig, context: DevicesUI.ViewContext) -> DevicesUI.ViewRenderable
}
public struct ButtonGradientStyle : DevicesUI.ButtonStyle {
  public static let defaultMargins: DevicesDesignSystem.Margins
  public init(margins: DevicesDesignSystem.Margins = Self.defaultMargins, gradient: DevicesUI.Gradient)
  public func transformContent(config: DevicesUI.ButtonStyleConfig, context _: DevicesUI.ViewContext) -> DevicesUI.ViewRenderable
}
extension DevicesDesignSystem.ButtonModel : DevicesCore.Deserializable {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.ButtonModel {
  public enum Error : Foundation.LocalizedError {
    case actionsAreEmpty
    public static func == (a: DevicesDesignSystem.ButtonModel.Error, b: DevicesDesignSystem.ButtonModel.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public typealias Style = DevicesDesignSystem.LegacyButtonModelStyle
  public typealias Kind = DevicesDesignSystem.ButtonColorKind
  public struct Appearance : Swift.Hashable {
    public let textColor: DevicesDesignSystem.TypeColor
    public let background: DevicesDesignSystem.BackgroundColor?
    public let highlightedBackground: DevicesDesignSystem.BackgroundColor?
    public let labelMargins: DevicesDesignSystem.Margins
    public let isRounded: Swift.Bool
    public init(textColor: DevicesDesignSystem.TypeColor, background: DevicesDesignSystem.BackgroundColor? = nil, highlightedBackground: DevicesDesignSystem.BackgroundColor? = nil, labelMargins: DevicesDesignSystem.Margins? = nil, isRounded: Swift.Bool = true)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.ButtonModel.Appearance, b: DevicesDesignSystem.ButtonModel.Appearance) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum HighlightEffect : Swift.Hashable {
    case scale(_: CoreFoundation.CGFloat, animationDuration: Foundation.TimeInterval)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.ButtonModel.HighlightEffect, b: DevicesDesignSystem.ButtonModel.HighlightEffect) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(*, deprecated, message: "Use PlasmaButtonModel")
  public init(text: DevicesUI.StringContent, typeface: DevicesDesignSystem.Typeface?, style: DevicesDesignSystem.ButtonModel.Style?, type: DevicesDesignSystem.ButtonModel.Kind?, actions: [DevicesDesignSystem.AnyAction], highlightEffect: DevicesDesignSystem.ButtonModel.HighlightEffect? = nil, margins: DevicesDesignSystem.Margins? = nil, logId: DevicesDesignSystem.LogID? = nil, spinner: DevicesDesignSystem.ProgressSpinnerModel? = nil, accessibility: Swift.String? = nil) throws
  @available(*, deprecated, message: "Use PlasmaButtonModel")
  public init(text: DevicesUI.StringContent, typeface: DevicesDesignSystem.Typeface?, style: DevicesDesignSystem.ButtonModel.Style?, type: DevicesDesignSystem.ButtonModel.Kind?, action: DevicesDesignSystem.AnyAction, highlightEffect: DevicesDesignSystem.ButtonModel.HighlightEffect? = nil, margins: DevicesDesignSystem.Margins? = nil, logId: DevicesDesignSystem.LogID? = nil, spinner: DevicesDesignSystem.ProgressSpinnerModel? = nil, accessibility: Swift.String? = nil)
  @available(*, deprecated, message: "Use PlasmaButtonModel")
  public init(text: DevicesUI.StringContent, appearance: DevicesDesignSystem.ButtonModel.Appearance, typeface: DevicesDesignSystem.Typeface?, action: DevicesDesignSystem.AnyAction, highlightEffect: DevicesDesignSystem.ButtonModel.HighlightEffect? = nil, margins: DevicesDesignSystem.Margins? = nil, logId: DevicesDesignSystem.LogID? = nil, spinner: DevicesDesignSystem.ProgressSpinnerModel? = nil, accessibility: Swift.String? = nil)
}
extension DevicesDesignSystem.ButtonModel.Error {
  public var errorDescription: Swift.String? {
    get
  }
}
extension DevicesDesignSystem.ButtonModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public enum ButtonModel : Swift.Hashable {
  case legacy(DevicesDesignSystem.LegacyButtonModel)
  case plasma(DevicesDesignSystem.PlasmaButtonModel)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.ButtonModel, b: DevicesDesignSystem.ButtonModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.ButtonModel {
  @available(*, deprecated, message: "Use PlasmaButtonModel")
  public init(text: DevicesUI.StringContent, appearance: DevicesDesignSystem.ButtonModel.Appearance, typeface: DevicesDesignSystem.Typeface?, actions: [DevicesDesignSystem.AnyAction], highlightEffect: DevicesDesignSystem.ButtonModel.HighlightEffect? = nil, margins: DevicesDesignSystem.Margins? = nil, logId: DevicesDesignSystem.LogID? = nil, spinner: DevicesDesignSystem.ProgressSpinnerModel? = nil, accessibility: Swift.String? = nil) throws
}
extension DevicesDesignSystem.ButtonModel {
  public init(plasma: DevicesDesignSystem.PlasmaButtonModel)
  public init(text: Swift.String, actions: [DevicesDesignSystem.AnyAction], logId: DevicesDesignSystem.LogID? = nil, style: DevicesDesignSystem.PlasmaButtonStyleID? = nil, icon: DevicesDesignSystem.ImageAddress? = nil, paddings: DevicesDesignSystem.Paddings? = nil, roundedCorners: DevicesDesignSystem.CornersRounding? = nil, accessibility: Swift.String? = nil)
}
public enum ButtonSpinnerStyle : Swift.String, Swift.Decodable {
  case white
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension CoreFoundation.CGFloat {
  public static var ios13SafeInfinity: CoreFoundation.CGFloat {
    get
  }
}
public protocol CardBase : DevicesUI.HashableViewRenderable {
  var elementType: DevicesDesignSystem.ElementType { get }
  var definesCardBackground: Swift.Bool { get }
  var canBeDisabled: Swift.Bool { get }
}
extension DevicesDesignSystem.CardBase {
  @inlinable public var reuseID: DevicesUI.ReuseID {
    get {
		ReuseID(value: elementType.rawValue)
	}
  }
  public var definesCardBackground: Swift.Bool {
    get
  }
  public var canBeDisabled: Swift.Bool {
    get
  }
}
public enum CardError : Foundation.LocalizedError {
  case unknownType(Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
}
public enum CardModel : Swift.Hashable {
  case list(DevicesDesignSystem.ListCardModel)
  case grid(DevicesDesignSystem.GridCardModel)
  case gallery(DevicesDesignSystem.GalleryCardModel)
  case widgetSingle(DevicesDesignSystem.WidgetSingleCardModel)
  case widgetTitle(DevicesDesignSystem.WidgetTitleCardModel)
  case widgetGallery(DevicesDesignSystem.WidgetGalleryModel)
  case widgetCategoriesGallery(DevicesDesignSystem.WidgetCategoriesGalleryModel)
  case simpleListCard(DevicesDesignSystem.SimpleListCardModel)
  case extendedListCard(DevicesDesignSystem.ExtendedListCardModel)
  case widgetTwoColumns(DevicesDesignSystem.WidgetTwoColumnModel)
  case discoveryCard(DevicesDesignSystem.WidgetDiscoveryCardModel)
  case widgetButton(DevicesDesignSystem.WidgetButtonModel)
  case widgetNestedContentCard(DevicesDesignSystem.WidgetNestedContentCardModel)
  case widgetVerticalCards(DevicesDesignSystem.WidgetVerticalCardsModel)
  public static var allCardTypes: [DevicesDesignSystem.ElementType] {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.CardModel, b: DevicesDesignSystem.CardModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.CardModel {
  public struct Deserializable : DevicesCore.Deserializable, Swift.Equatable {
    public let model: DevicesDesignSystem.CardModel
    public init(deserializer: DevicesCore.Deserializer) throws
    public static func == (a: DevicesDesignSystem.CardModel.Deserializable, b: DevicesDesignSystem.CardModel.Deserializable) -> Swift.Bool
  }
}
extension DevicesDesignSystem.CardModel : DevicesDesignSystem.CardBase {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public var definesCardBackground: Swift.Bool {
    get
  }
  public var canBeDisabled: Swift.Bool {
    get
  }
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public typealias CardModelFactory = DevicesCore.Factory<DevicesCore.JSONString, Swift.Result<DevicesDesignSystem.CardModel, Swift.Error>>
extension DevicesCore.Factory where Arg == Swift.String, Item == Swift.Result<DevicesDesignSystem.CardModel, Swift.Error> {
  public enum Error : Foundation.LocalizedError {
    case cardIsDisabled
    case typeError
    public var errorDescription: Swift.String? {
      get
    }
    public static func == (a: DevicesCore.Factory<Arg, Item>.Error, b: DevicesCore.Factory<Arg, Item>.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func cardModel(disabledCardTypes: [DevicesDesignSystem.ElementType], context: DevicesCore.DeserializationContext) -> DevicesDesignSystem.CardModelFactory
  public static func checkDisabledCard(disabledCardTypes: [DevicesDesignSystem.ElementType], cardDict: DevicesCore.DeserializationDictionary) throws
}
public struct CategoryDeselectAction : DevicesDesignSystem.Action, Swift.Equatable {
  public let categoryNumber: Swift.Int
  public let categoryName: Swift.String?
  public let categoryCardCount: Swift.Int
  public let nextSelectWith: DevicesDesignSystem.SelectType
  public init(categoryNumber: Swift.Int, categoryName: Swift.String?, categoryCardCount: Swift.Int, nextSelectWith: DevicesDesignSystem.SelectType)
  public static func == (a: DevicesDesignSystem.CategoryDeselectAction, b: DevicesDesignSystem.CategoryDeselectAction) -> Swift.Bool
}
extension DevicesDesignSystem.AnyAction {
  public static func categoryDeselected(categoryNumber: Swift.Int, categoryName: Swift.String?, categoryCardCount: Swift.Int, nextSelectWith: DevicesDesignSystem.SelectType) -> DevicesDesignSystem.AnyAction
}
public struct CategorySelectAction : DevicesDesignSystem.Action, Swift.Equatable {
  public let categoryNumber: Swift.Int
  public let categoryName: Swift.String?
  public let categoryCardCount: Swift.Int
  public let selectedWith: DevicesDesignSystem.SelectType
  public init(categoryNumber: Swift.Int, categoryName: Swift.String?, categoryCardCount: Swift.Int, selectedWith: DevicesDesignSystem.SelectType)
  public static func == (a: DevicesDesignSystem.CategorySelectAction, b: DevicesDesignSystem.CategorySelectAction) -> Swift.Bool
}
extension DevicesDesignSystem.AnyAction {
  public static func categorySelected(categoryNumber: Swift.Int, categoryName: Swift.String?, categoryCardCount: Swift.Int, selectedWith: DevicesDesignSystem.SelectType) -> DevicesDesignSystem.AnyAction
}
public struct CategoryVisibleChangedAction : DevicesDesignSystem.Action, Swift.Equatable {
  public let categoryNumber: Swift.Int
  public let categoryName: Swift.String?
  public let categoryCardCount: Swift.Int
  public let isSelected: Swift.Bool
  public let isVisible: Swift.Bool
  public init(categoryNumber: Swift.Int, categoryName: Swift.String?, categoryCardCount: Swift.Int, isSelected: Swift.Bool, isVisible: Swift.Bool)
  public static func == (a: DevicesDesignSystem.CategoryVisibleChangedAction, b: DevicesDesignSystem.CategoryVisibleChangedAction) -> Swift.Bool
}
extension DevicesDesignSystem.AnyAction {
  public static func categoryVisibleChanged(categoryNumber: Swift.Int, categoryName: Swift.String?, categoryCardCount: Swift.Int, isSelected: Swift.Bool, isVisible: Swift.Bool) -> DevicesDesignSystem.AnyAction
}
extension DevicesDesignSystem.CellModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.CellModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public enum CellModel : Swift.Hashable {
  case leftRight(DevicesDesignSystem.LeftRightCellModel)
  case textCell(DevicesDesignSystem.TextCellModel)
  case buttonCell(DevicesDesignSystem.ButtonCellModel)
  case roundButtonCell(DevicesDesignSystem.RoundButtonCellModel)
  case imageCell(DevicesDesignSystem.ImageCellModel)
  case detailsCell(DevicesDesignSystem.DetailsCellModel)
  case weatherCell(DevicesDesignSystem.WeatherCellModel)
  case flexibleImageCell(DevicesDesignSystem.FlexibleImageCellModel)
  case horizontalCells(DevicesDesignSystem.HorizontalCellsModel)
  case horizontalStackCells(DevicesDesignSystem.HorizontalStackCellsModel)
  case operatorCard(DevicesDesignSystem.OperatorCardCellModel)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.CellModel, b: DevicesDesignSystem.CellModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum CharacterSemantic {
  case salute
  case joy
  case eva
  public static func == (a: DevicesDesignSystem.CharacterSemantic, b: DevicesDesignSystem.CharacterSemantic) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.CheckmarkModel : DevicesUI.NativeViewRenderable {
  public func renderNativeView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.NativeView
}
public struct CheckmarkModel {
  public let isChecked: DevicesCore.MutableProperty<Swift.Bool>
  public let checkedIcon: DevicesCore.ImageID
  public let uncheckedIcon: DevicesCore.ImageID
  public let isDisabled: Swift.Bool
  public init(isChecked: DevicesCore.MutableProperty<Swift.Bool>, isDisabled: Swift.Bool = false, checkedIcon: DevicesCore.ImageID = DesignSystemLocalImageID.color(.checkBox_on), uncheckedIcon: DevicesCore.ImageID = DesignSystemLocalImageID.color(.checkBox_off))
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class CheckmarkUIView : UIKit.UIControl, DevicesDesignSystem.CheckmarkView {
  @_Concurrency.MainActor(unsafe) public init(model: DevicesDesignSystem.CheckmarkModel, context: DevicesUI.ViewContext)
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override final public func sizeThatFits(_: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @_Concurrency.MainActor(unsafe) final public func set(_ model: DevicesDesignSystem.CheckmarkModel, context: DevicesUI.ViewContext)
  @objc deinit
}
public protocol CheckmarkView : AnyObject {
  func set(_ model: DevicesDesignSystem.CheckmarkModel, context: DevicesUI.ViewContext)
}
public struct ChipGalleryItem {
  public let content: DevicesUI.ViewRenderable
  public init(content: DevicesUI.ViewRenderable)
}
extension DevicesDesignSystem.ChipGalleryModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct ChipGalleryModel {
  public struct Chip {
    public init(typeface: DevicesDesignSystem.Typeface, color: DevicesDesignSystem.TypeColor, selectedColor: DevicesDesignSystem.TypeColor, bubbleColor: DevicesDesignSystem.ButtonColor, insets: UIKit.UIEdgeInsets, chipSpacing: CoreFoundation.CGFloat)
  }
  public init(chip: DevicesDesignSystem.ChipGalleryModel.Chip, chipType: DevicesDesignSystem.WidgetCategoriesGalleryModel.ChipKind, sections: [DevicesDesignSystem.ChipGallerySection], itemsSpacing: CoreFoundation.CGFloat = 0.0, contentInset: UIKit.UIEdgeInsets = .zero, chipsToSectionsSpacing: CoreFoundation.CGFloat = 0.0, contentOffset: DevicesCore.MutableProperty<CoreFoundation.CGFloat> = MutableProperty(0.0), debugLabel: Swift.StaticString? = nil, onDidSwipe: ((DevicesDesignSystem.SwipeType, [Swift.Int]) -> Swift.Void)?, onDidShow: ((Swift.Int) -> Swift.Void)? = nil, onDidHide: ((Swift.Int) -> Swift.Void)? = nil, chipSelectionHandler: ((Swift.Int, DevicesDesignSystem.SelectType) -> Swift.Void)?)
}
public struct ChipGallerySection {
  public enum ChipHeader : Swift.Equatable, Swift.Hashable {
    case title(Swift.String)
    case image(DevicesDesignSystem.FlexibleImageModel)
    public static func == (a: DevicesDesignSystem.ChipGallerySection.ChipHeader, b: DevicesDesignSystem.ChipGallerySection.ChipHeader) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let title: DevicesDesignSystem.ChipGallerySection.ChipHeader
  public let items: [DevicesDesignSystem.ChipGalleryItem]
  public init(title: DevicesDesignSystem.ChipGallerySection.ChipHeader, items: [DevicesDesignSystem.ChipGalleryItem])
}
public struct ChipsModel {
  public struct ImageContent {
  }
  public struct TextContent {
  }
  public enum Content {
    case images(DevicesDesignSystem.ChipsModel.ImageContent)
    case texts(DevicesDesignSystem.ChipsModel.TextContent)
  }
  public init(items: DevicesDesignSystem.ChipsModel.Content, chipSpacing: CoreFoundation.CGFloat, insets: UIKit.UIEdgeInsets, selectedChipIndex: DevicesUI.Binding<CoreFoundation.CGFloat>, onDidSwipe: ((DevicesDesignSystem.SwipeType, [Swift.Int]) -> Swift.Void)? = nil, onDidShow: ((Swift.Int) -> Swift.Void)? = nil, onDidHide: ((Swift.Int) -> Swift.Void)? = nil, onSelect: ((DevicesUI.RenderingCollectionCell, Swift.Bool) -> Swift.Void)? = nil, selectionHandler: ((Swift.Int) -> Swift.Void)? = nil)
}
extension DevicesDesignSystem.ChipsModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
extension DevicesDesignSystem.ChipsModel {
  @available(*, deprecated, message: "Method for legacy support")
  public init(titles: [Swift.String], typeface: DevicesDesignSystem.Typeface, color: DevicesDesignSystem.TypeColor, selectedColor: DevicesDesignSystem.TypeColor, bubbleColor: DevicesDesignSystem.ButtonColor, chipSpacing: CoreFoundation.CGFloat, insets: UIKit.UIEdgeInsets, selectedChipIndex: DevicesUI.Binding<CoreFoundation.CGFloat>, onDidSwipe: ((DevicesDesignSystem.SwipeType, [Swift.Int]) -> Swift.Void)? = nil, onDidShow: ((Swift.Int) -> Swift.Void)? = nil, onDidHide: ((Swift.Int) -> Swift.Void)? = nil, onSelect: ((DevicesUI.RenderingCollectionCell, Swift.Bool) -> Swift.Void)? = nil, selectionHandler: ((Swift.Int) -> Swift.Void)? = nil)
}
public struct CloseShareScreenParameters : Swift.Equatable {
  public let destination: Swift.String?
  public let success: Swift.Bool
  public init(destination: Swift.String?, success: Swift.Bool)
  public static func == (a: DevicesDesignSystem.CloseShareScreenParameters, b: DevicesDesignSystem.CloseShareScreenParameters) -> Swift.Bool
}
public protocol CodeEnteringViewDelegate : AnyObject {
  func codeEnteringViewDidReceiveCode(_ codeEraser: DevicesDesignSystem.CodeEraser, code: Swift.String)
}
public protocol CodeEraser {
  func eraseCode()
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class CodeViewController : UIKit.UIViewController {
  public struct Model {
    public init(title: DevicesDesignSystem.TextModel, description: DevicesDesignSystem.TextModel, codeView: DevicesDesignSystem.CodeViewable, image: DevicesDesignSystem.ImageModel?, controls: [DevicesUI.ViewRenderable]?, backgroundGradient: DevicesUI.ViewRenderable? = nil)
  }
  @_Concurrency.MainActor(unsafe) public init(model: DevicesDesignSystem.CodeViewController.Model, context: DevicesUI.ViewContext)
  @_Concurrency.MainActor(unsafe) @objc override final public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override final public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override final public func viewWillLayoutSubviews()
  @objc deinit
}
public struct CodeViewModel {
  public let codeLength: Swift.Int
  public let groupSize: Swift.Int
  public let keyboardType: UIKit.UIKeyboardType
  public let initialCode: Swift.String
  public let type: DevicesDesignSystem.CodeViewType
  public let onCodeEntered: ((DevicesDesignSystem.CodeEraser, Swift.String) -> Swift.Void)?
  public init(type: DevicesDesignSystem.CodeViewType, codeLength: Swift.Int, groupSize: Swift.Int, keyboardType: UIKit.UIKeyboardType, onCodeEntered: ((DevicesDesignSystem.CodeEraser, Swift.String) -> Swift.Void)?)
}
public enum CodeViewType : Swift.Equatable {
  case mutable
  case immutable(Swift.String)
  public static func == (a: DevicesDesignSystem.CodeViewType, b: DevicesDesignSystem.CodeViewType) -> Swift.Bool
}
extension DevicesDesignSystem.CodeViewModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing _: DevicesUI.View?) -> DevicesUI.View
}
public protocol CodeViewable : DevicesUI.ViewRenderable {
}
extension DevicesDesignSystem.CodeViewModel : DevicesDesignSystem.CodeViewable {
}
extension DevicesDesignSystem.TextModel : DevicesDesignSystem.CodeViewable {
}
public protocol ColorProtocol {
  func value(characterSemantic: DevicesDesignSystem.CharacterSemantic, userInterfaceStyle: DevicesDesignSystem.UserInterfaceStyle) -> UIKit.UIColor
  func isEqualToColor(to another: DevicesDesignSystem.ColorProtocol) -> Swift.Bool
}
extension DevicesDesignSystem.ColorProtocol where Self : Swift.Equatable {
  public func isEqualToColor(to another: DevicesDesignSystem.ColorProtocol) -> Swift.Bool
}
public protocol ColorProvider {
  func value(for color: DevicesDesignSystem.BackgroundColor) -> UIKit.UIColor
  func value(for typeColor: DevicesDesignSystem.TypeColor) -> UIKit.UIColor
  func value(for speechBubbleColor: DevicesDesignSystem.SpeechBubbleColor) -> UIKit.UIColor
  func value(for assistantCharacterBackgroundColor: DevicesDesignSystem.CharacterSemantic) -> DevicesDesignSystem.AssistantCharacterBackgroundModel
  func value(for smartAppColor: DevicesDesignSystem.SmartAppColor) -> UIKit.UIColor
  func value(for paymentColor: DevicesDesignSystem.PaymentColor) -> UIKit.UIColor
  func value(for buttonColor: DevicesDesignSystem.ButtonColor) -> UIKit.UIColor
  func value(for surfaceColor: DevicesDesignSystem.SurfaceColor) -> UIKit.UIColor
  func value(for colorProtocol: DevicesDesignSystem.ColorProtocol) -> UIKit.UIColor
}
extension DevicesDesignSystem.ColumnGridShimmer : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct ColumnGridShimmer {
  public struct Column {
    public init(items: [DevicesUI.ViewRenderable], insets: UIKit.UIEdgeInsets = .zero)
  }
  public let columns: [DevicesDesignSystem.ColumnGridShimmer.Column]
  public let verticalSpacing: CoreFoundation.CGFloat
  public let horizontalSpacing: CoreFoundation.CGFloat
  public let itemCornerRaduis: CoreFoundation.CGFloat
  public init(columns: [DevicesDesignSystem.ColumnGridShimmer.Column], verticalSpacing: CoreFoundation.CGFloat, horizontalSpacing: CoreFoundation.CGFloat, itemCornerRaduis: CoreFoundation.CGFloat)
}
public enum CommonAlertType {
  case success
  case failure
  case warning
  case startMessaging
  case emptyContent
  case audioVideoPermissions
  public static func == (a: DevicesDesignSystem.CommonAlertType, b: DevicesDesignSystem.CommonAlertType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CompactContact {
  var givenName: Swift.String { get }
  var familyName: Swift.String { get }
  var middleName: Swift.String { get }
  var thumbnailImageData: Foundation.Data? { get }
}
public struct ContactAvatarSource : DevicesUI.ImageSource, Swift.Equatable {
  public init(imageHash: DevicesDesignSystem.PhoneContactHash)
  public func loadImage(context: DevicesUI.ViewContext, _ completion: @escaping (Swift.Result<UIKit.UIImage, Swift.Error>) -> Swift.Void) -> DevicesCore.Cancellable
  public static func == (a: DevicesDesignSystem.ContactAvatarSource, b: DevicesDesignSystem.ContactAvatarSource) -> Swift.Bool
}
public protocol ContactHashProvider {
  func loadAvatar(phoneHash: DevicesDesignSystem.PhoneContactHash, completion: @escaping (_ contact: DevicesDesignSystem.CompactContact) -> Swift.Void)
}
public enum ContentHeight : Swift.Hashable {
  case fixed(CoreFoundation.CGFloat)
  case aspectRatio(CoreFoundation.CGFloat)
  case matchParent
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.ContentHeight, b: DevicesDesignSystem.ContentHeight) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.ContentHeight : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.ContentSize : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
public enum ContentSize : Swift.Hashable {
  case fixed(CoreFoundation.CGSize)
  case matchParent
  @inlinable public static func fixed(width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat) -> DevicesDesignSystem.ContentSize {
		.fixed(CGSize(width: width, height: height))
	}
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.ContentSize, b: DevicesDesignSystem.ContentSize) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.ContentSize {
  public var contentWidth: DevicesDesignSystem.ContentWidth {
    get
  }
  public var contentHeight: DevicesDesignSystem.ContentHeight {
    get
  }
}
public enum ContentWidth : Swift.Hashable {
  case fixed(CoreFoundation.CGFloat)
  case columns(CoreFoundation.CGFloat)
  case matchParent
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.ContentWidth, b: DevicesDesignSystem.ContentWidth) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.ContentWidth : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
public enum CornersRounding : Swift.String {
  case none
  case rounded
  case circle
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension DevicesUI.NativeViewRenderable {
  @inlinable public func cornerRadius(_ cornerRadius: DevicesDesignSystem.CornersRounding) -> DevicesUI.NativeViewRenderable {
		switch cornerRadius {
		case .rounded:
			return self.cornerRadius(12.0)
		case .circle:
			return self.cornerRadius { size in
				size.minDimension / 2
			}
		case .none:
			return self
		}
	}
}
extension DevicesCore.Factory where Arg == DevicesDesignSystem.AlertScreenFactoryInput, Item == DevicesCore.StackScreen {
  public static func `default`(context: DevicesUI.ViewContext) -> DevicesDesignSystem.AlertScreenFactory
}
extension DevicesCore.Tagged where Tag == DevicesDesignSystem.DeserializableAction.KindTag, T == Swift.String {
  public static let deeplink: DevicesCore.Tagged<DevicesDesignSystem.DeserializableAction.KindTag, Swift.String>
}
extension DevicesDesignSystem.DeserializableAction {
  public var isDeeplink: Swift.Bool {
    get
  }
  public func deserializeDeeplink() throws -> Foundation.URL
}
public struct DeserializableAction : DevicesDesignSystem.Action, DevicesCore.Deserializable, Swift.Equatable {
  public typealias Kind = DevicesCore.Tagged<DevicesDesignSystem.DeserializableAction.KindTag, Swift.String>
  public enum KindTag {
  }
  public let type: DevicesDesignSystem.DeserializableAction.Kind
  public let deserializer: DevicesCore.Deserializer
  public init(type: DevicesDesignSystem.DeserializableAction.Kind, deserializer: DevicesCore.Deserializer)
  public init(deserializer: DevicesCore.Deserializer) throws
  public static func == (lhs: DevicesDesignSystem.DeserializableAction, rhs: DevicesDesignSystem.DeserializableAction) -> Swift.Bool
}
extension DevicesCore.Tagged where Tag == DevicesDesignSystem.DeserializableAction.KindTag, T == Swift.String {
  public static let unknown: DevicesCore.Tagged<DevicesDesignSystem.DeserializableAction.KindTag, Swift.String>
}
extension DevicesCore.DeserializationContainer {
  @inlinable public func decodeActions(key: Key) throws -> [DevicesDesignSystem.AnyAction] {
		let actions: [DeserializableAction] = try decodeArray(key: key)
		return actions.map(AnyAction.init)
	}
  @inlinable public func decodeActionsIfPresent(key: Key) throws -> [DevicesDesignSystem.AnyAction]? {
		let actions: [DeserializableAction]? = try decodeArrayIfPresent(key: key)
		return actions.map { $0.map(AnyAction.init) }
	}
}
extension DevicesDesignSystem.DeserializableAction {
  public func eraseToAnyAction() -> DevicesDesignSystem.AnyAction
}
final public class DeserializableDeeplinkPerformer : DevicesDesignSystem.ActionPerformer {
  public init(linkHandler: DevicesCore.URLHandler, assertionCaller: DevicesCore.AssertionCaller = assertionCallerShared)
  final public func perform(_ action: DevicesDesignSystem.AnyAction, sender _: DevicesDesignSystem.ActionSender) -> Swift.Bool
  @objc deinit
}
@_Concurrency.MainActor(unsafe) public struct DesignImage : SwiftUI.View {
  @_Concurrency.MainActor(unsafe) public init(imageID: DevicesCore.ImageID)
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s19DevicesDesignSystem0B5ImageV4bodyQrvp", 0) __
}
public enum DesignSystemLocalImageID : Swift.Decodable, Swift.Equatable {
  case mono(DevicesDesignSystem.DesignSystemLocalImageID.Mono)
  case color(DevicesDesignSystem.DesignSystemLocalImageID.Color)
  public enum Mono : Swift.String, Swift.CaseIterable {
    case add_contactless_payment
    case apple_wallet
    case arrow_right_chevron_rectangle
    case arrow_right_trace_line
    case arrows_forward_back
    case atm_banknote
    case bag
    case ballot_paper
    case bar_graph
    case basket
    case beach_umbrella
    case bell
    case bell_crossed
    case boarding_pass
    case bolt
    case box
    case brightness
    case building
    case calculator
    case camera
    case candy
    case capsule
    case car
    case card
    case card_chevron_left
    case card_on_card
    case card_plus
    case card_viewfinder
    case cards_carousel
    case `case`
    case change
    case case_diagram
    case chess_piece
    case circle_cross
    case circle_plus
    case clock
    case coat_of_arms
    case coin
    case copy
    case coin_heart
    case counterclock_wise
    case cross
    case crown
    case digital_banknotes
    case disclosure_up
    case disclosure_down
    case disclosure_down_chevron
    case disclosure_left
    case disclosure_left_chevron
    case disclosure_right
    case document
    case document_checkmark
    case document_magnifying_glass
    case document_on_document
    case dot
    case drop
    case edit
    case eye
    case eye_crossed
    case face
    case face_id
    case falling_coin
    case file_pdf
    case fingerprint
    case flag
    case flame
    case flasher
    case funnel
    case gamepad
    case gear
    case gift
    case globe
    case hammer
    case handset
    case heart
    case heart_hand
    case home
    case house
    case house_handset
    case house_percent
    case info
    case key
    case keyboard
    case list
    case lock_closed
    case lock_opened
    case magnit
    case mail
    case mail_eye
    case mail_waves
    case man_badge
    case man_wheelchair
    case map
    case mask
    case microphone
    case mindmap
    case mobile
    case mobile_plus
    case mobile_plus_alt
    case mobile_waves
    case necklace
    case note
    case notebook_waves
    case open_book
    case paper_clip
    case paper_tray
    case parking
    case passport
    case password_checkmark
    case paw
    case pencil
    case pencil_line
    case percent
    case photo
    case pie_chart
    case plane
    case play
    case postcard_heart
    case pram
    case qr_code
    case receipt
    case rectangle_on_dashed_rectangle
    case rectangle_speech_bubble
    case rectangle_speech_bubble_on_speech_bubble
    case rectangle_watches
    case round_speech_bubble_question
    case round_watches
    case ruble_dollar
    case ruble_plus
    case safe
    case safe_diagram
    case salute
    case security_camera
    case shield
    case shield_check
    case shield_crossed
    case shield_lines
    case shield_lines_circles
    case spasibo
    case speaker_waves
    case square_on_square
    case star_light
    case student_hat
    case telephone
    case thermometer
    case trash
    case tv_set
    case umbrella
    case user
    case user_cross
    case user_on_user
    case vibration
    case wallet
    case watering_can
    case waves
    case waves_cross
    case whistle
    case wrench
    case yule
    case plus
    case spasibo_logo
    case medium_loading_icon
    case thick_loading_icon
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DevicesDesignSystem.DesignSystemLocalImageID.Mono]
    public typealias RawValue = Swift.String
    public static var allCases: [DevicesDesignSystem.DesignSystemLocalImageID.Mono] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Color : Swift.String, Swift.CaseIterable {
    case app_placeholder
    case app_assistant
    case back
    case card_mc_black
    case card_visa_gold
    case card_visa_black
    case card_mc
    case card_visa
    case card_visa_infinite_sber
    case card_mir_black
    case card_mir
    case card_blocked
    case card_visa_infinite
    case card_visa_digital
    case card_visa_null
    case card_amex_black
    case card_mc_null
    case card_pro100_null
    case card_amex_gold
    case color_spasibo
    case pfm
    case placeholder
    case card_amex
    case card_mir_gold
    case card_maestro_null
    case card_momentum
    case card_ghost
    case card_mir_null
    case close
    case other
    case color_total
    case card_uek
    case card_mc_gold
    case between_accounts
    case loading_icon
    case password_checkmark
    case white_spinner
    case black_spinner
    case checkBox_on
    case checkBox_off
    case checkmark
    case bot_operator
    case status_online
    case alert_error
    case alert_warning
    case start_messaging
    case empty_content
    case av_permission_alert
    case notice
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DevicesDesignSystem.DesignSystemLocalImageID.Color]
    public typealias RawValue = Swift.String
    public static var allCases: [DevicesDesignSystem.DesignSystemLocalImageID.Color] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension DevicesDesignSystem.DesignSystemLocalImageID : Swift.CaseIterable {
  public static var allCases: [DevicesDesignSystem.DesignSystemLocalImageID] {
    get
  }
  public typealias AllCases = [DevicesDesignSystem.DesignSystemLocalImageID]
}
extension DevicesDesignSystem.DesignSystemLocalImageID : Swift.RawRepresentable {
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
extension DevicesDesignSystem.DesignSystemLocalImageID : DevicesCore.ImageID, DevicesUI.ImageContent {
  public var name: Swift.String {
    get
  }
}
public struct DesignSystemLocalImageProvider : DevicesCore.ImageProvider {
  public init(bundle: Foundation.Bundle)
  public func getImage(for id: DevicesCore.ImageID) -> UIKit.UIImage?
}
@_Concurrency.MainActor(unsafe) public struct DesignText : SwiftUI.View {
  @_Concurrency.MainActor(unsafe) public init(text: DevicesUI.StringContent)
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s19DevicesDesignSystem0B4TextV4bodyQrvp", 0) __
}
@_Concurrency.MainActor(unsafe) public struct DesignTextField : SwiftUI.View {
  @_Concurrency.MainActor(unsafe) public init(text: SwiftUI.Binding<Swift.String>, title: DevicesUI.StringContent? = nil, isSecure: Swift.Bool = false, validator: DevicesDesignSystem.StringValidator? = nil, placeholderTitle: DevicesUI.StringContent? = nil, warningAlignment: SwiftUI.HorizontalAlignment = .center, warningColor: DevicesDesignSystem.TypeColor = .critical, backgroundColor: DevicesDesignSystem.ColorProtocol = BackgroundColor.liquid20, cornerRadius: CoreFoundation.CGFloat = 16)
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s19DevicesDesignSystem0B9TextFieldV4bodyQrvp", 0) __
}
@_Concurrency.MainActor(unsafe) public struct DesignToggle : SwiftUI.View {
  @_Concurrency.MainActor(unsafe) public init(title: DevicesUI.StringContent, isOn: SwiftUI.Binding<Swift.Bool>, onColor: DevicesDesignSystem.ColorProtocol = BackgroundColor.liquid60, offColor: DevicesDesignSystem.ColorProtocol = BackgroundColor.liquid20)
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s19DevicesDesignSystem0B6ToggleV4bodyQrvp", 0) __
}
extension DevicesDesignSystem.DetailRightModel {
  public struct Deserializable : DevicesCore.Deserializable, Swift.Equatable {
    public let model: DevicesDesignSystem.DetailRightModel
    public init(model: DevicesDesignSystem.DetailRightModel)
    public init(deserializer: DevicesCore.Deserializer) throws
    public static func == (a: DevicesDesignSystem.DetailRightModel.Deserializable, b: DevicesDesignSystem.DetailRightModel.Deserializable) -> Swift.Bool
  }
}
extension DevicesDesignSystem.DetailRightModel.InfoIconModel {
  public struct Deserializable : DevicesCore.Deserializable, Swift.Equatable {
    public let model: DevicesDesignSystem.DetailRightModel.InfoIconModel
    public init(deserializer: DevicesCore.Deserializer) throws
    public static func == (a: DevicesDesignSystem.DetailRightModel.InfoIconModel.Deserializable, b: DevicesDesignSystem.DetailRightModel.InfoIconModel.Deserializable) -> Swift.Bool
  }
}
extension DevicesDesignSystem.DetailRightModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct DetailRightModel : Swift.Hashable {
  public enum Error : Foundation.LocalizedError {
    case noContent
    public static func == (a: DevicesDesignSystem.DetailRightModel.Error, b: DevicesDesignSystem.DetailRightModel.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum DetailPosition : Swift.String, Swift.Decodable {
    case top
    case bottom
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let detail: DevicesDesignSystem.TextModel?
  public let infoIcon: DevicesDesignSystem.DetailRightModel.InfoIconModel?
  public let margins: DevicesDesignSystem.Margins
  public let verticalGravity: DevicesUI.VerticalGravity
  public let detailPosition: DevicesDesignSystem.DetailRightModel.DetailPosition
  public let accessibility: Swift.String?
  public init(detail: DevicesDesignSystem.TextModel?, infoIcon: DevicesDesignSystem.DetailRightModel.InfoIconModel?, margins: DevicesDesignSystem.Margins?, verticalGravity: DevicesUI.VerticalGravity?, detailPosition: DevicesDesignSystem.DetailRightModel.DetailPosition?, accessibility: Swift.String? = nil) throws
  public init(detail: DevicesDesignSystem.TextModel, infoIcon: DevicesDesignSystem.DetailRightModel.InfoIconModel? = nil, margins: DevicesDesignSystem.Margins? = nil, verticalGravity: DevicesUI.VerticalGravity? = nil, detailPosition: DevicesDesignSystem.DetailRightModel.DetailPosition? = nil, accessibility: Swift.String? = nil)
  public struct InfoIconModel : Swift.Hashable {
    public let info: DevicesDesignSystem.TextModel?
    public let icon: DevicesDesignSystem.IconModel?
    public let margins: DevicesDesignSystem.Margins
    public init(info: DevicesDesignSystem.TextModel?, icon: DevicesDesignSystem.IconModel?, margins: DevicesDesignSystem.Margins?)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.DetailRightModel.InfoIconModel, b: DevicesDesignSystem.DetailRightModel.InfoIconModel) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.DetailRightModel, b: DevicesDesignSystem.DetailRightModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.DetailRightModel.Error {
  public var errorDescription: Swift.String? {
    get
  }
}
extension DevicesDesignSystem.DetailsCellModel {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public struct Deserializable : DevicesCore.Deserializable, Swift.Equatable {
    public let model: DevicesDesignSystem.DetailsCellModel
    public init(model: DevicesDesignSystem.DetailsCellModel)
    public init(deserializer: DevicesCore.Deserializer) throws
    public static func == (a: DevicesDesignSystem.DetailsCellModel.Deserializable, b: DevicesDesignSystem.DetailsCellModel.Deserializable) -> Swift.Bool
  }
}
extension DevicesDesignSystem.DetailsCellModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct DetailsCellModel : Swift.Hashable {
  public enum Error : Foundation.LocalizedError, Swift.Equatable {
    case emptyDetails
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.DetailsCellModel.Error, b: DevicesDesignSystem.DetailsCellModel.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public let details: [DevicesDesignSystem.DetailRightModel]
  public let paddings: DevicesDesignSystem.Paddings
  public init(details: [DevicesDesignSystem.DetailRightModel], paddings: DevicesDesignSystem.Paddings?) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.DetailsCellModel, b: DevicesDesignSystem.DetailsCellModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.DetailsCellModel.Error {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum Device : Swift.Equatable {
  case mobile(DevicesDesignSystem.Device.App)
  public enum App : Swift.Equatable {
    case assistant
    case companion
    case remote
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.Device.App, b: DevicesDesignSystem.Device.App) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func == (a: DevicesDesignSystem.Device, b: DevicesDesignSystem.Device) -> Swift.Bool
}
public enum Dimensions : Swift.String, Swift.Decodable, Swift.CustomStringConvertible {
  case x0
  case x1
  case x2
  case x3
  case x4
  case x5
  case x6
  case x7
  case x8
  case x9
  case x10
  case x12
  case x16
  case x24
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension DevicesDesignSystem.DisclosureRightModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.DisclosureRightModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct DisclosureRightModel : Swift.Hashable {
  public let logId: DevicesDesignSystem.LogID?
  public init(margins: DevicesDesignSystem.Margins? = nil, logId: DevicesDesignSystem.LogID? = nil, actions: [DevicesDesignSystem.AnyAction]? = nil, accessibility: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.DisclosureRightModel, b: DevicesDesignSystem.DisclosureRightModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.DividerModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.DividerModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing _: DevicesUI.View?) -> DevicesUI.View
}
public struct DividerModel : Swift.Hashable {
  public static let height: CoreFoundation.CGFloat
  public enum Size : Swift.String, Swift.Decodable {
    case d1
    case d2
    case d3
    case d4
    case d5
    case d6
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Style : Swift.String, Swift.Decodable {
    case `default`
    case readOnly
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let style: DevicesDesignSystem.DividerModel.Style
  public let size: DevicesDesignSystem.DividerModel.Size
  public init(style: DevicesDesignSystem.DividerModel.Style?, size: DevicesDesignSystem.DividerModel.Size?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.DividerModel, b: DevicesDesignSystem.DividerModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct DynamicAnimation : Swift.Equatable {
  public let body: Foundation.Data
  public init(body: Foundation.Data)
  public static func == (a: DevicesDesignSystem.DynamicAnimation, b: DevicesDesignSystem.DynamicAnimation) -> Swift.Bool
}
public enum ElementTypeTag {
}
public typealias ElementType = DevicesCore.Tagged<DevicesDesignSystem.ElementTypeTag, Swift.String>
extension DevicesCore.Tagged where Tag == DevicesDesignSystem.ElementTypeTag, T == Swift.String {
  public static let leftRightCell: DevicesDesignSystem.ElementType
  public static let textCell: DevicesDesignSystem.ElementType
  public static let buttonCell: DevicesDesignSystem.ElementType
  public static let imageCell: DevicesDesignSystem.ElementType
  public static let roundButtonCell: DevicesDesignSystem.ElementType
  public static let detailsCell: DevicesDesignSystem.ElementType
  public static let weatherCell: DevicesDesignSystem.ElementType
  public static let flexibleImageCell: DevicesDesignSystem.ElementType
  public static let horizontalCells: DevicesDesignSystem.ElementType
  public static let horizontalStackCells: DevicesDesignSystem.ElementType
  public static let operatorCardCell: DevicesDesignSystem.ElementType
}
extension DevicesCore.Tagged where Tag == DevicesDesignSystem.ElementTypeTag, T == Swift.String {
  public static let greetingGridItem: DevicesDesignSystem.ElementType
}
extension DevicesCore.Tagged where Tag == DevicesDesignSystem.ElementTypeTag, T == Swift.String {
  public static let simpleListCard: DevicesDesignSystem.ElementType
  public static let galleryCard: DevicesDesignSystem.ElementType
  public static let discoveryCard: DevicesDesignSystem.ElementType
  public static let gridCard: DevicesDesignSystem.ElementType
  public static let listCard: DevicesDesignSystem.ElementType
  public static let extendedListCard: DevicesDesignSystem.ElementType
}
extension DevicesCore.Tagged where Tag == DevicesDesignSystem.ElementTypeTag, T == Swift.String {
  public static let widgetVerticalCards: DevicesDesignSystem.ElementType
  public static let widgetGallery: DevicesDesignSystem.ElementType
  public static let widgetCategoriesGallery: DevicesDesignSystem.ElementType
  public static let widgetSingleCard: DevicesDesignSystem.ElementType
  public static let widgetTitleCard: DevicesDesignSystem.ElementType
  public static let widgetTwoColumns: DevicesDesignSystem.ElementType
  public static let widgetNestedContentCard: DevicesDesignSystem.ElementType
  public static let widgetNestedContentGallery: DevicesDesignSystem.ElementType
  public static let widgetNestedContentList: DevicesDesignSystem.ElementType
  public static let widgetButton: DevicesDesignSystem.ElementType
}
extension DevicesCore.Tagged where Tag == DevicesDesignSystem.ElementTypeTag, T == Swift.String {
  public static let spacer: DevicesDesignSystem.ElementType
  public static let text: DevicesDesignSystem.ElementType
  public static let icon: DevicesDesignSystem.ElementType
  public static let image: DevicesDesignSystem.ElementType
  public static let flexibleImage: DevicesDesignSystem.ElementType
  public static let extendedImage: DevicesDesignSystem.ElementType
  public static let button: DevicesDesignSystem.ElementType
  public static let roundButton: DevicesDesignSystem.ElementType
  public static let plasmaButton: DevicesDesignSystem.ElementType
  public static let verticalIconTextItem: DevicesDesignSystem.ElementType
  public static let imageTextItem: DevicesDesignSystem.ElementType
}
extension DevicesDesignSystem.ExtendedImageModel : DevicesCore.Deserializable {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.ExtendedImageModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct ExtendedImageModel {
  public init(imageAddress: DevicesDesignSystem.ImageAddress, placeholder: DevicesCore.ImageID?, placeholderColor: DevicesDesignSystem.BackgroundColor, scaleMode: DevicesDesignSystem.ScaleMode, height: CoreFoundation.CGFloat, imageRatio: DevicesDesignSystem.ExtendedImageRatio, logId: DevicesDesignSystem.LogID?, actions: [DevicesDesignSystem.AnyAction]?, accessibility: Swift.String?)
}
extension DevicesDesignSystem.ExtendedImageModel : Swift.Equatable {
  public static func == (lhs: DevicesDesignSystem.ExtendedImageModel, rhs: DevicesDesignSystem.ExtendedImageModel) -> Swift.Bool
}
extension DevicesDesignSystem.ExtendedImageModel : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ExtendedImageRatio : Swift.String {
  case oneToOne
  case threeToTwo
  case threeToFour
  case fourToThree
  case nineToSixteen
  case sixteenToNine
  public var aspectRatio: CoreFoundation.CGFloat {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension DevicesDesignSystem.ExtendedListCardModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.ExtendedListCardModel : DevicesUI.ViewRenderable, DevicesDesignSystem.CardBase {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct ExtendedListCardModel : Swift.Hashable {
  public let cells: [DevicesDesignSystem.CellModel]
  public let cellImage: DevicesDesignSystem.ExtendedImageModel
  public let paddings: DevicesDesignSystem.Paddings
  public let canBeDisabled: Swift.Bool
  public let actions: [DevicesDesignSystem.AnyAction]?
  public let logId: DevicesDesignSystem.LogID?
  public let backgroundImage: DevicesDesignSystem.FlexibleImageModel?
  public let backgroundColor: DevicesDesignSystem.ColorProtocol
  public let topAccessibility: Swift.String?
  public init(cells: [DevicesDesignSystem.CellModel], cellImage: DevicesDesignSystem.ExtendedImageModel, paddings: DevicesDesignSystem.Paddings? = nil, canBeDisabled: Swift.Bool = false, actions: [DevicesDesignSystem.AnyAction]? = nil, logId: DevicesDesignSystem.LogID? = nil, backgroundImage: DevicesDesignSystem.FlexibleImageModel? = nil, backgroundColor: DevicesDesignSystem.ColorProtocol = SurfaceColor.card, topAccessibility: Swift.String? = nil)
  public static func == (lhs: DevicesDesignSystem.ExtendedListCardModel, rhs: DevicesDesignSystem.ExtendedListCardModel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.FastAnswerLeftModel {
  public struct Deserializable : DevicesCore.Deserializable, Swift.Equatable {
    public let model: DevicesDesignSystem.FastAnswerLeftModel
    public init(model: DevicesDesignSystem.FastAnswerLeftModel)
    public init(deserializer: DevicesCore.Deserializer) throws
    public static func == (a: DevicesDesignSystem.FastAnswerLeftModel.Deserializable, b: DevicesDesignSystem.FastAnswerLeftModel.Deserializable) -> Swift.Bool
  }
}
extension DevicesDesignSystem.FastAnswerLeftModel.IconAndValue {
  public struct Deserializable : DevicesCore.Deserializable, Swift.Equatable {
    public let model: DevicesDesignSystem.FastAnswerLeftModel.IconAndValue
    public init(deserializer: DevicesCore.Deserializer) throws
    public static func == (a: DevicesDesignSystem.FastAnswerLeftModel.IconAndValue.Deserializable, b: DevicesDesignSystem.FastAnswerLeftModel.IconAndValue.Deserializable) -> Swift.Bool
  }
}
extension DevicesDesignSystem.FastAnswerLeftModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing _: DevicesUI.View?) -> DevicesUI.View
}
public struct FastAnswerLeftModel : Swift.Hashable {
  public struct IconAndValue : Swift.Hashable {
    public let icon: DevicesDesignSystem.IconModel?
    public let value: DevicesDesignSystem.TextModel
    public let margins: DevicesDesignSystem.Margins
    public init(icon: DevicesDesignSystem.IconModel?, value: DevicesDesignSystem.TextModel, margins: DevicesDesignSystem.Margins?)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.FastAnswerLeftModel.IconAndValue, b: DevicesDesignSystem.FastAnswerLeftModel.IconAndValue) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public let label: DevicesDesignSystem.TextModel?
  public let iconAndValue: DevicesDesignSystem.FastAnswerLeftModel.IconAndValue
  public let margins: DevicesDesignSystem.Margins
  public let accessibility: Swift.String?
  public init(label: DevicesDesignSystem.TextModel?, iconAndValue: DevicesDesignSystem.FastAnswerLeftModel.IconAndValue, margins: DevicesDesignSystem.Margins?, accessibility: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.FastAnswerLeftModel, b: DevicesDesignSystem.FastAnswerLeftModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public typealias FlexibleImageCellModel = DevicesDesignSystem.SingleContentCellModel<DevicesDesignSystem.FlexibleImageModel>
extension DevicesDesignSystem.FlexibleImageModel : DevicesCore.Deserializable {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.FlexibleImageModel {
  public static func sample(imageAddress: DevicesDesignSystem.ImageAddress = ImageAddress.url(
			URL(string: "anyURL"),
			hash: "anyHash"
		), width: DevicesDesignSystem.ContentWidth = .matchParent, height: DevicesDesignSystem.ContentHeight = .matchParent, scaleMode: DevicesDesignSystem.ScaleMode = .scaleAspectFill, gravity: DevicesUI.Gravity = .center) -> DevicesDesignSystem.FlexibleImageModel
}
extension DevicesDesignSystem.FlexibleImageModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct FlexibleImageModel {
  public enum Mask : Swift.String {
    case bottom
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public init(imageAddress: DevicesDesignSystem.ImageAddress, width: DevicesDesignSystem.ContentWidth, height: DevicesDesignSystem.ContentHeight, scaleMode: DevicesDesignSystem.ScaleMode, gravity: DevicesUI.Gravity, mask: DevicesDesignSystem.FlexibleImageModel.Mask?, logId: DevicesDesignSystem.LogID?, actions: [DevicesDesignSystem.AnyAction]?, placeholder: DevicesCore.ImageID?, placeholderColor: DevicesDesignSystem.BackgroundColor, accessibility: Swift.String? = nil)
}
extension DevicesDesignSystem.FlexibleImageModel : Swift.Equatable {
  public static func == (lhs: DevicesDesignSystem.FlexibleImageModel, rhs: DevicesDesignSystem.FlexibleImageModel) -> Swift.Bool
}
extension DevicesDesignSystem.FlexibleImageModel : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.FontProvider {
  public func cached() -> DevicesDesignSystem.FontProvider
}
extension DevicesDesignSystem.FontManagerRegistrar {
  public static func designSystem(_ bundle: Foundation.Bundle) -> DevicesDesignSystem.FontManagerRegistrar
}
final public class FontManagerRegistrar : DevicesDesignSystem.FontRegistrar {
  public init(baseUrl: Foundation.URL, getFileName: @escaping (DevicesDesignSystem.FontType) -> Swift.String, registerFont: @escaping (Foundation.URL) throws -> Swift.Void, assertionCaller: DevicesCore.AssertionCaller)
  final public func register()
  public static func register(at url: Foundation.URL) throws
  @objc deinit
}
public protocol FontProvider {
  func font(for fontType: DevicesDesignSystem.FontType, size: CoreFoundation.CGFloat) -> UIKit.UIFont
}
public enum FontProviders {
}
public protocol FontRegistrar {
  func register()
}
public enum FontType : Swift.CaseIterable, Swift.Hashable {
  case medium
  case bold
  case semibold
  case regular
  case light
  case italic
  public static func == (a: DevicesDesignSystem.FontType, b: DevicesDesignSystem.FontType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [DevicesDesignSystem.FontType]
  public static var allCases: [DevicesDesignSystem.FontType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.GalleryCardItem {
  public struct Deserializable : DevicesCore.Deserializable {
    public let model: DevicesDesignSystem.GalleryCardItem
    public init(model: DevicesDesignSystem.GalleryCardItem)
    public init(deserializer: DevicesCore.Deserializer) throws
  }
}
public enum GalleryCardItem : Swift.Hashable {
  case media(DevicesDesignSystem.GalleryMediaCardItem)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.GalleryCardItem, b: DevicesDesignSystem.GalleryCardItem) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.GalleryCardModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.GalleryCardModel : DevicesDesignSystem.CardBase, DevicesUI.ViewRenderable {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  @inlinable public var definesCardBackground: Swift.Bool {
    get { true }
  }
  public func renderView(context: DevicesUI.ViewContext, reusing _: DevicesUI.View?) -> DevicesUI.View
}
public struct GalleryCardModel : Swift.Hashable {
  public let items: [DevicesDesignSystem.GalleryCardItem]
  public let canBeDisabled: Swift.Bool
  public init(items: [DevicesDesignSystem.GalleryCardItem], canBeDisabled: Swift.Bool?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.GalleryCardModel, b: DevicesDesignSystem.GalleryCardModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum GalleryCardItemKind : Swift.String {
  case media
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension DevicesDesignSystem.GalleryMediaCardItem {
  public struct Deserializable : DevicesCore.Deserializable {
    public let model: DevicesDesignSystem.GalleryMediaCardItem
    public init(model: DevicesDesignSystem.GalleryMediaCardItem)
    public init(deserializer: DevicesCore.Deserializer) throws
  }
}
public struct GalleryMediaCardItem : Swift.Hashable {
  public enum Error : Foundation.LocalizedError {
    case unsupportedImageSize
    case unexpectedMarginsWithoutTexts
    case emptyContent
    public static func == (a: DevicesDesignSystem.GalleryMediaCardItem.Error, b: DevicesDesignSystem.GalleryMediaCardItem.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let image: DevicesDesignSystem.ImageModel?
  public let topText: DevicesDesignSystem.TextModel?
  public let bottomText: DevicesDesignSystem.TextModel?
  public let margins: DevicesDesignSystem.Margins?
  public let actions: [DevicesDesignSystem.AnyAction]?
  public let logId: DevicesDesignSystem.LogID?
  public init(image: DevicesDesignSystem.ImageModel?, topText: DevicesDesignSystem.TextModel?, bottomText: DevicesDesignSystem.TextModel?, margins: DevicesDesignSystem.Margins?, actions: [DevicesDesignSystem.AnyAction]?, logId: DevicesDesignSystem.LogID? = nil) throws
  public static func item(image: DevicesDesignSystem.ImageModel?, topText: DevicesDesignSystem.TextModel?, bottomText: DevicesDesignSystem.TextModel?, margins: DevicesDesignSystem.Margins?, actions: [DevicesDesignSystem.AnyAction]?, logId: DevicesDesignSystem.LogID? = nil) -> DevicesDesignSystem.GalleryMediaCardItem
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.GalleryMediaCardItem, b: DevicesDesignSystem.GalleryMediaCardItem) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct GallerySwipeAction : DevicesDesignSystem.Action, Swift.Equatable {
  public let widgetType: Swift.String
  public let visibleIndexes: [Swift.Int]
  public let cardsTotal: Swift.Int
  public let type: DevicesDesignSystem.SwipeType
  public init(widgetType: Swift.String, visibleIndexes: [Swift.Int], cardsTotal: Swift.Int, type: DevicesDesignSystem.SwipeType)
  public static func == (a: DevicesDesignSystem.GallerySwipeAction, b: DevicesDesignSystem.GallerySwipeAction) -> Swift.Bool
}
extension DevicesDesignSystem.AnyAction {
  public static func gallerySwipe(widgetType: Swift.String, visibleIndexes: [Swift.Int], cardsTotal: Swift.Int, type: DevicesDesignSystem.SwipeType) -> DevicesDesignSystem.AnyAction
}
public struct GlyphTypo {
  public let font: UIKit.UIFont
  public let kern: CoreFoundation.CGFloat
  public let lineHeight: CoreFoundation.CGFloat
  public init(font: UIKit.UIFont, kern: CoreFoundation.CGFloat, lineHeight: CoreFoundation.CGFloat)
}
extension DevicesUI.Gradient {
  public static func fromUser(uuid: Swift.String, startPoint: CoreFoundation.CGPoint, endPoint: CoreFoundation.CGPoint) -> DevicesUI.Gradient
}
public typealias GradientColors = (start: UIKit.UIColor, end: UIKit.UIColor)
extension DevicesUI.GradientConfig {
  public static let gradientColorValues: [DevicesDesignSystem.GradientColors]
  public static func fromUser(uuid: Swift.String) -> DevicesUI.GradientConfig
}
public protocol GradientProvider {
  func value(for styleID: DevicesDesignSystem.GradientStyleID) -> DevicesUI.GradientConfig
}
public enum GradientStyleID : Swift.String, Swift.Decodable {
  case background
  case bottomShade
  case critical
  case saluteAppBackground
  case saluteSheetBackground
  case messengerSuggestGradient
  case messengerInputVoiceGradient
  case messengerInputBackgroundGradient
  case messengerBackgroundGradient
  case salute
  case athena
  case joy
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct GradientStyleIDBackground : DevicesUI.GradientStyle {
  public let styleID: DevicesDesignSystem.GradientStyleID
  public init(styleID: DevicesDesignSystem.GradientStyleID)
  public func makeGradientConfig(context: DevicesUI.ViewContext) -> DevicesUI.GradientConfig
}
extension DevicesUI.Gravity : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesUI.Greediness : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.GreetingGridItemModel {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public struct Deserializable : DevicesCore.Deserializable, Swift.Equatable {
    public let model: DevicesDesignSystem.GreetingGridItemModel
    public init(model: DevicesDesignSystem.GreetingGridItemModel)
    public init(deserializer: DevicesCore.Deserializer) throws
    public static func == (a: DevicesDesignSystem.GreetingGridItemModel.Deserializable, b: DevicesDesignSystem.GreetingGridItemModel.Deserializable) -> Swift.Bool
  }
}
extension DevicesDesignSystem.GreetingGridItemModel : DevicesUI.NativeViewRenderable {
  public func renderNativeView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.NativeView
}
public struct GreetingGridItemModel : Swift.Hashable {
  public let topText: DevicesDesignSystem.TextModel
  public let bottomText: DevicesDesignSystem.TextModel
  public let paddings: DevicesDesignSystem.Paddings
  public let backgroundImage: DevicesDesignSystem.ImageModel?
  public let actions: [DevicesDesignSystem.AnyAction]?
  public let logId: DevicesDesignSystem.LogID?
  public init(topText: DevicesDesignSystem.TextModel, bottomText: DevicesDesignSystem.TextModel, paddings: DevicesDesignSystem.Paddings?, actions: [DevicesDesignSystem.AnyAction]?, backgroundImage: DevicesDesignSystem.ImageModel?, logId: DevicesDesignSystem.LogID? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.GreetingGridItemModel, b: DevicesDesignSystem.GreetingGridItemModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.GridCardModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.GridCardModel : DevicesUI.ViewRenderable, DevicesDesignSystem.CardBase {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct GridCardModel : Swift.Hashable {
  public enum GridContentHeight : Swift.String {
    case fixed
    case resizable
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Error : Foundation.LocalizedError, Swift.Hashable {
    case emptyItems
    public static func == (a: DevicesDesignSystem.GridCardModel.Error, b: DevicesDesignSystem.GridCardModel.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let items: [DevicesDesignSystem.GridItemModel]
  public let columns: Swift.Int
  public let paddings: DevicesDesignSystem.Paddings
  public let itemWidth: DevicesDesignSystem.GridContentWidth
  public let itemHeight: DevicesDesignSystem.GridCardModel.GridContentHeight
  public let canBeDisabled: Swift.Bool
  public init(items: [DevicesDesignSystem.GridItemModel], columns: Swift.Int?, paddings: DevicesDesignSystem.Paddings?, itemWidth: DevicesDesignSystem.GridContentWidth?, itemHeight: DevicesDesignSystem.GridCardModel.GridContentHeight?, canBeDisabled: Swift.Bool?) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.GridCardModel, b: DevicesDesignSystem.GridCardModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.GridCardModel.Error {
  public var errorDescription: Swift.String? {
    get
  }
}
extension DevicesDesignSystem.GridContentSize : DevicesCore.Deserializable {
  public enum Error : Swift.Error, Swift.Equatable {
    case invalidAspectRatio
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.GridContentSize.Error, b: DevicesDesignSystem.GridContentSize.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(deserializer: DevicesCore.Deserializer) throws
}
public struct GridContentSize : Swift.Equatable {
  public let width: DevicesDesignSystem.GridContentWidth
  public let aspectRatio: CoreFoundation.CGFloat
  public init(width: DevicesDesignSystem.GridContentWidth, aspectRatio: CoreFoundation.CGFloat)
  public static func == (a: DevicesDesignSystem.GridContentSize, b: DevicesDesignSystem.GridContentSize) -> Swift.Bool
}
public enum GridContentWidth : Swift.String {
  case xsmall
  case small
  case medium
  case large
  case resizable
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension DevicesDesignSystem.GridItemModel {
  public struct Deserializable : DevicesCore.Deserializable, Swift.Equatable {
    public let model: DevicesDesignSystem.GridItemModel
    public init(model: DevicesDesignSystem.GridItemModel)
    public init(deserializer: DevicesCore.Deserializer) throws
    public static func == (a: DevicesDesignSystem.GridItemModel.Deserializable, b: DevicesDesignSystem.GridItemModel.Deserializable) -> Swift.Bool
  }
}
extension DevicesDesignSystem.GridItemModel : DevicesUI.NativeViewRenderable {
  public func renderNativeView(context: DevicesUI.ViewContext, reusing _: DevicesUI.View?) -> DevicesUI.NativeView
}
public enum GridItemModel : Swift.Hashable {
  case greeting(DevicesDesignSystem.GreetingGridItemModel)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.GridItemModel, b: DevicesDesignSystem.GridItemModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.HStackShimmer : DevicesDesignSystem.ShimmerMaskRenderable, DevicesUI.NativeViewRenderable {
  public func renderShimmerMask(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesDesignSystem.ShimmerMaskView
  public func renderNativeView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.NativeView
}
public struct HStackShimmer {
  public let items: [DevicesDesignSystem.HStackShimmerItem]
  public let spacing: CoreFoundation.CGFloat
  public init(items: [DevicesDesignSystem.HStackShimmerItem], spacing: CoreFoundation.CGFloat = 0)
}
public struct HStackShimmerItem {
  public let content: DevicesUI.ViewRenderable
  public let cornerRadius: CoreFoundation.CGFloat
  public let margins: UIKit.UIEdgeInsets
  public let gravity: DevicesUI.VerticalGravity
  public let greediness: DevicesUI.Greediness
  public let renderType: DevicesDesignSystem.ShimmerItemRenderType
  public init(content: DevicesUI.ViewRenderable, cornerRadius: CoreFoundation.CGFloat, margins: UIKit.UIEdgeInsets = .zero, gravity: DevicesUI.VerticalGravity, greediness: DevicesUI.Greediness = .intrinsic, renderType: DevicesDesignSystem.ShimmerItemRenderType? = nil)
  @inlinable public init(width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat, cornerRadius: CoreFoundation.CGFloat, margins: UIKit.UIEdgeInsets = .zero, gravity: DevicesUI.VerticalGravity, greediness: DevicesUI.Greediness = .intrinsic, renderType: DevicesDesignSystem.ShimmerItemRenderType? = nil) {
		self.init(
			content: Spacer(width: width, height: height),
			cornerRadius: cornerRadius,
			margins: margins,
			gravity: gravity,
			greediness: greediness,
			renderType: renderType
		)
	}
}
extension DevicesUI.ViewRenderable {
  @inlinable public func asHStackShimmerItem(cornerRadius: CoreFoundation.CGFloat, margins: UIKit.UIEdgeInsets = .zero, gravity: DevicesUI.VerticalGravity = .center, greediness: DevicesUI.Greediness = .intrinsic, renderType: DevicesDesignSystem.ShimmerItemRenderType? = nil) -> DevicesDesignSystem.HStackShimmerItem {
		HStackShimmerItem(
			content: self,
			cornerRadius: cornerRadius,
			margins: margins,
			gravity: gravity,
			greediness: greediness,
			renderType: renderType
		)
	}
}
public struct HorizontalCellsModel : Swift.Hashable {
  public enum Content : Swift.Hashable {
    case spacer(DevicesDesignSystem.SpacerModel)
    case verticalIconText(DevicesDesignSystem.VerticalIconTextModel)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.HorizontalCellsModel.Content, b: DevicesDesignSystem.HorizontalCellsModel.Content) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public let cells: [DevicesDesignSystem.HorizontalCellsModel.Content]
  public let paddings: DevicesDesignSystem.Paddings
  public init(cells: [DevicesDesignSystem.HorizontalCellsModel.Content], paddings: DevicesDesignSystem.Paddings)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.HorizontalCellsModel, b: DevicesDesignSystem.HorizontalCellsModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.HorizontalCellsModel : DevicesCore.Deserializable {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.HorizontalCellsModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
extension DevicesDesignSystem.HorizontalCellsModel.Content : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.HorizontalCellsModel.Content : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public enum HorizontalStackCellContent : Swift.Hashable {
  case simpleLeft(DevicesDesignSystem.SimpleLeftModel)
  case fastAnswerLeft(DevicesDesignSystem.FastAnswerLeftModel)
  case flexibleImage(DevicesDesignSystem.FlexibleImageCellModel)
  case imageTexts(DevicesDesignSystem.ImageTextsLeftCellModel)
  case plasmaButton(DevicesDesignSystem.PlasmaButtonCellModel)
  case disclosure(DevicesDesignSystem.DisclosureRightModel)
  case detail(DevicesDesignSystem.DetailRightModel)
  case roundButton(DevicesDesignSystem.RoundButtonCellModel)
  case array(DevicesDesignSystem.ArrayRightModel)
  case tag(DevicesDesignSystem.TagCellModel)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.HorizontalStackCellContent, b: DevicesDesignSystem.HorizontalStackCellContent) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.HorizontalStackCellContent : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.HorizontalStackCellsModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct HorizontalStackCellsModel : Swift.Hashable {
  public let items: [DevicesDesignSystem.HorizontalStackItemModel]
  public let alignment: DevicesUI.HorizontalGravity
  public let actions: [DevicesDesignSystem.AnyAction]?
  public let divider: DevicesDesignSystem.DividerModel?
  public let paddings: DevicesDesignSystem.Paddings
  public let logId: DevicesDesignSystem.LogID?
  public init(items: [DevicesDesignSystem.HorizontalStackItemModel], alignment: DevicesUI.HorizontalGravity, actions: [DevicesDesignSystem.AnyAction]?, divider: DevicesDesignSystem.DividerModel?, paddings: DevicesDesignSystem.Paddings?, logId: DevicesDesignSystem.LogID? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.HorizontalStackCellsModel, b: DevicesDesignSystem.HorizontalStackCellsModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.HorizontalStackCellsModel : DevicesCore.Deserializable {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public init(deserializer: DevicesCore.Deserializer) throws
}
public struct HorizontalStackItemModel : Swift.Hashable {
  public init(model: DevicesDesignSystem.HorizontalStackCellContent, greediness: DevicesUI.Greediness)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.HorizontalStackItemModel, b: DevicesDesignSystem.HorizontalStackItemModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.HorizontalStackItemModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.IconModel {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public struct Deserializable : DevicesCore.Deserializable, Swift.Equatable {
    public let model: DevicesDesignSystem.IconModel
    public init(model: DevicesDesignSystem.IconModel)
    public init(deserializer: DevicesCore.Deserializer) throws
    public static func == (a: DevicesDesignSystem.IconModel.Deserializable, b: DevicesDesignSystem.IconModel.Deserializable) -> Swift.Bool
  }
}
extension DevicesDesignSystem.Icon.Size : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.IconModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct IconModel : Swift.Hashable {
  public enum RoundedCorners : Swift.String {
    case none
    case rounded
    case circle
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public typealias Size = DevicesDesignSystem.Icon.Size
  public let address: DevicesDesignSystem.ImageAddress
  public let size: DevicesDesignSystem.IconModel.Size
  public let tintColor: DevicesDesignSystem.BackgroundColor?
  public let margins: DevicesDesignSystem.Margins
  public let roundedCorners: DevicesDesignSystem.IconModel.RoundedCorners
  public let renderingMode: UIKit.UIImage.RenderingMode
  public let badge: DevicesDesignSystem.BadgeModel?
  public let actions: [DevicesDesignSystem.AnyAction]?
  public let logId: DevicesDesignSystem.LogID?
  public let accessibility: Swift.String?
  public init(address: DevicesDesignSystem.ImageAddress, size: DevicesDesignSystem.IconModel.Size, tintColor: DevicesDesignSystem.BackgroundColor? = nil, margins: DevicesDesignSystem.Margins? = nil, roundedCorners: DevicesDesignSystem.IconModel.RoundedCorners = .none, renderingMode: UIKit.UIImage.RenderingMode = .automatic, badge: DevicesDesignSystem.BadgeModel? = nil, actions: [DevicesDesignSystem.AnyAction]? = nil, logId: DevicesDesignSystem.LogID? = nil, accessibility: Swift.String? = nil)
  public init(address: DevicesDesignSystem.ImageAddress, size: DevicesDesignSystem.IconModel.Size, tintColor: DevicesDesignSystem.BackgroundColor? = nil, margins: DevicesDesignSystem.Margins? = nil, roundedCorners: DevicesDesignSystem.IconModel.RoundedCorners = .none, badge: DevicesDesignSystem.BadgeModel? = nil, action: DevicesDesignSystem.AnyAction, logId: DevicesDesignSystem.LogID? = nil, accessibility: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.IconModel, b: DevicesDesignSystem.IconModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum Icon : Swift.Hashable {
  public struct Size : Swift.Hashable {
    public enum Dimension : Swift.String, Swift.Decodable {
      case xsmall
      case small
      case medium
      case large
      case xlarge
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public let width: DevicesDesignSystem.Icon.Size.Dimension
    public let height: DevicesDesignSystem.Icon.Size.Dimension
    public init(width: DevicesDesignSystem.Icon.Size.Dimension, height: DevicesDesignSystem.Icon.Size.Dimension)
    public init(dimension: DevicesDesignSystem.Icon.Size.Dimension)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.Icon.Size, b: DevicesDesignSystem.Icon.Size) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.Icon, b: DevicesDesignSystem.Icon) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesUI.Image {
  public init(address: DevicesDesignSystem.ImageAddress, contentMode: UIKit.UIView.ContentMode = .scaleToFill, renderingMode: UIKit.UIImage.RenderingMode = .automatic, initialContentMode: UIKit.UIView.ContentMode = .scaleAspectFit, initialContent: DevicesUI.ImageContent? = nil, failureContentMode: UIKit.UIView.ContentMode = .scaleAspectFit, failureContent: DevicesUI.ImageContent? = nil)
}
extension DevicesDesignSystem.ImageAddress : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.ImageAddress : DevicesCore.Serializable {
  public func toJSONDictionary() -> DevicesCore.JSONDictionary
}
public enum ImageAddress {
  public struct Remote : Swift.Hashable {
    public let url: Foundation.URL
    public let hash: Swift.String?
    public let placeholder: DevicesCore.ImageID
    public init(url: Foundation.URL, hash: Swift.String?, placeholder: DevicesCore.ImageID)
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct LocalContact : Swift.Hashable {
    public let hash: DevicesDesignSystem.PhoneContactHash
    public let placeholder: DevicesCore.ImageID
    public init(hash: DevicesDesignSystem.PhoneContactHash, placeholder: DevicesCore.ImageID)
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  case remote(DevicesDesignSystem.ImageAddress.Remote)
  case local(DevicesCore.ImageID)
  case localContact(DevicesDesignSystem.ImageAddress.LocalContact)
  public var placeholder: DevicesCore.ImageID? {
    get
  }
}
extension DevicesDesignSystem.ImageAddress : Swift.Equatable {
  public static func == (lhs: DevicesDesignSystem.ImageAddress, rhs: DevicesDesignSystem.ImageAddress) -> Swift.Bool
}
extension DevicesDesignSystem.ImageAddress : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.ImageAddress.Remote : Swift.Equatable {
  public static func == (lhs: DevicesDesignSystem.ImageAddress.Remote, rhs: DevicesDesignSystem.ImageAddress.Remote) -> Swift.Bool
}
extension DevicesDesignSystem.ImageAddress {
  public static func url(_ url: Foundation.URL?, hash: Swift.String? = nil, placeholder: DevicesCore.ImageID? = nil) -> DevicesDesignSystem.ImageAddress
}
extension DevicesDesignSystem.ImageAddress.LocalContact : Swift.Equatable {
  public static func == (lhs: DevicesDesignSystem.ImageAddress.LocalContact, rhs: DevicesDesignSystem.ImageAddress.LocalContact) -> Swift.Bool
}
public typealias ImageCellModel = DevicesDesignSystem.SingleContentCellModel<DevicesDesignSystem.ImageModel>
extension DevicesDesignSystem.ImageModel : DevicesCore.Deserializable {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.ImageModel : DevicesUI.NativeViewRenderable {
  public func renderNativeView(context: DevicesUI.ViewContext, reusing _: DevicesUI.View?) -> DevicesUI.NativeView
}
public struct ImageModel : Swift.Hashable {
  public let address: DevicesDesignSystem.ImageAddress
  public let scaleMode: DevicesDesignSystem.ScaleMode
  public let verticalContentAlignment: DevicesUI.VerticalGravity
  public let size: DevicesDesignSystem.ImageSize
  public let placeholderColor: DevicesDesignSystem.BackgroundColor
  public let actions: [DevicesDesignSystem.AnyAction]?
  public let logId: DevicesDesignSystem.LogID?
  public let accessibility: Swift.String?
  public init(address: DevicesDesignSystem.ImageAddress, scaleMode: DevicesDesignSystem.ScaleMode?, verticalContentAlignment: DevicesUI.VerticalGravity? = nil, size: DevicesDesignSystem.ImageSize, placeholderColor: DevicesDesignSystem.BackgroundColor?, actions: [DevicesDesignSystem.AnyAction]? = nil, logId: DevicesDesignSystem.LogID? = nil, accessibility: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.ImageModel, b: DevicesDesignSystem.ImageModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ImagePickerConfig {
  public enum Source : Swift.Equatable {
    case camera
    case library
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.ImagePickerConfig.Source, b: DevicesDesignSystem.ImagePickerConfig.Source) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public let source: DevicesDesignSystem.ImagePickerConfig.Source
  public let allowsEditing: Swift.Bool
  public let dismissOnCancel: () -> Swift.Void
  public let dismissOnSelection: (UIKit.UIImage) -> Swift.Void
  public init(source: DevicesDesignSystem.ImagePickerConfig.Source, allowsEditing: Swift.Bool, dismissOnCancel: @escaping () -> Swift.Void, dismissOnSelection: @escaping (UIKit.UIImage) -> Swift.Void)
}
public typealias ImagePickerFactory = DevicesCore.Factory<DevicesDesignSystem.ImagePickerConfig, DevicesCore.ModalScreen>
extension DevicesCore.Factory where Arg == DevicesDesignSystem.ImagePickerConfig, Item == DevicesCore.ModalScreen {
  public init(assertionCaller: DevicesCore.AssertionCaller)
}
extension DevicesCore.ImageProviders {
  public static func designSystem(_ bundle: Foundation.Bundle) -> DevicesCore.ImageProvider
}
public enum ImageSize : Swift.Hashable {
  public enum Dimension : Swift.Hashable {
    case width(DevicesDesignSystem.GridContentWidth)
    case points(CoreFoundation.CGFloat)
    case flexible
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.ImageSize.Dimension, b: DevicesDesignSystem.ImageSize.Dimension) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  case fixedSize(CoreFoundation.CGSize)
  case fixedHeight(CoreFoundation.CGFloat)
  case aspect(DevicesDesignSystem.AspectRatio<DevicesDesignSystem.ImageSize.Dimension>)
  case natural
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.ImageSize {
  public static func fixed(square: CoreFoundation.CGFloat) -> DevicesDesignSystem.ImageSize
  public init(_ contentSize: DevicesDesignSystem.GridContentSize)
}
extension DevicesDesignSystem.ImageSize : Swift.Equatable {
  public static func == (a: DevicesDesignSystem.ImageSize, b: DevicesDesignSystem.ImageSize) -> Swift.Bool
}
public struct ImageTextsLeftCellModel : Swift.Hashable {
  public let image: DevicesDesignSystem.FlexibleImageModel?
  public let texts: DevicesDesignSystem.VerticalTextsModel?
  public let imageVerticalGravity: DevicesUI.VerticalGravity
  public init(image: DevicesDesignSystem.FlexibleImageModel?, texts: DevicesDesignSystem.VerticalTextsModel?, imageVerticalGravity: DevicesUI.VerticalGravity)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.ImageTextsLeftCellModel, b: DevicesDesignSystem.ImageTextsLeftCellModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.ImageTextsLeftCellModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.ImageTextsLeftCellModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct InlineAlertButtonStyle : DevicesUI.ButtonStyle {
  public static let brand: DevicesUI.ButtonStyle
  public static let `default`: DevicesUI.ButtonStyle
  public func transformContent(config: DevicesUI.ButtonStyleConfig, context: DevicesUI.ViewContext) -> DevicesUI.ViewRenderable
}
extension DevicesDesignSystem.InlineAlertModel {
  public init(type: DevicesDesignSystem.CommonAlertType, title: DevicesUI.StringContent, message: DevicesUI.StringContent, buttonTitle: DevicesUI.StringContent, presentationStyle: DevicesDesignSystem.InlineAlertModel.PresentationStyle, onRetry: @escaping () -> Swift.Void)
}
extension DevicesDesignSystem.InlineAlertModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct InlineAlertModel {
  public enum PresentationStyle {
    case compact
    case fullScreen
    public static func == (a: DevicesDesignSystem.InlineAlertModel.PresentationStyle, b: DevicesDesignSystem.InlineAlertModel.PresentationStyle) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(title: DevicesUI.StringContent, message: DevicesUI.StringContent, image: DevicesUI.Image, presentationStyle: DevicesDesignSystem.InlineAlertModel.PresentationStyle, buttons: [DevicesUI.Button])
  public init(title: DevicesUI.StringContent, message: DevicesUI.StringContent, image: DevicesUI.ViewRenderable, presentationStyle: DevicesDesignSystem.InlineAlertModel.PresentationStyle, buttons: [DevicesUI.Button])
}
@_Concurrency.MainActor(unsafe) public struct InlineAlertView<Button, Subtitle> : SwiftUI.View where Button : SwiftUI.View, Subtitle : SwiftUI.View {
  public enum IconType {
    case error
    case warning
    public static func == (a: DevicesDesignSystem.InlineAlertView<Button, Subtitle>.IconType, b: DevicesDesignSystem.InlineAlertView<Button, Subtitle>.IconType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) public let iconType: DevicesDesignSystem.InlineAlertView<Button, Subtitle>.IconType
  @_Concurrency.MainActor(unsafe) public let titleText: DevicesUI.StringContent
  @_Concurrency.MainActor(unsafe) public let subtitleView: Subtitle
  @_Concurrency.MainActor(unsafe) public let button: Button
  @_Concurrency.MainActor(unsafe) public let secondaryButton: Button?
  @_Concurrency.MainActor(unsafe) public init(iconType: DevicesDesignSystem.InlineAlertView<Button, Subtitle>.IconType, titleText: DevicesUI.StringContent, titleTypeface: DevicesDesignSystem.Typeface = .title1, subtitleView: Subtitle, button: Button, secondaryButton: Button? = nil)
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s19DevicesDesignSystem15InlineAlertViewV4bodyQrvp", 0) __<Button, Subtitle>
}
extension DevicesDesignSystem.Insets : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
public typealias Margins = DevicesDesignSystem.Insets
public typealias Paddings = DevicesDesignSystem.Insets
public struct Insets : Swift.Hashable, Swift.CustomStringConvertible {
  public static let zero: DevicesDesignSystem.Insets
  public let left: DevicesDesignSystem.Dimensions
  public let top: DevicesDesignSystem.Dimensions
  public let right: DevicesDesignSystem.Dimensions
  public let bottom: DevicesDesignSystem.Dimensions
  public init(left: DevicesDesignSystem.Dimensions = .x0, top: DevicesDesignSystem.Dimensions = .x0, right: DevicesDesignSystem.Dimensions = .x0, bottom: DevicesDesignSystem.Dimensions = .x0)
  public init(horizontal: DevicesDesignSystem.Dimensions = .x0, vertical: DevicesDesignSystem.Dimensions = .x0)
  public init(inset: DevicesDesignSystem.Dimensions)
  public var description: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.Insets, b: DevicesDesignSystem.Insets) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol InsetsProvider {
  func value(for insets: DevicesDesignSystem.Insets) -> UIKit.UIEdgeInsets
  func value(for inset: DevicesDesignSystem.Dimensions) -> CoreFoundation.CGFloat
  func value(for size: DevicesDesignSystem.DividerModel.Size) -> UIKit.UIEdgeInsets
}
public typealias InterfaceOrientationRenderable = (UIKit.UIInterfaceOrientation, CoreFoundation.CGSize?) -> DevicesUI.ViewRenderable
public struct InterfaceOrientationUpdatableModel : DevicesUI.NativeViewRenderable {
  public init(subject: @escaping DevicesDesignSystem.InterfaceOrientationRenderable)
  public func renderNativeView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.NativeView
}
public struct InvitationConfig {
  public let message: Swift.String
  public let recipients: [Swift.String]
  public let closeScreen: () -> Swift.Void
  public init(message: Swift.String, recipients: [Swift.String], closeScreen: @escaping () -> Swift.Void)
}
public typealias InvitationFactory = DevicesCore.Factory<DevicesDesignSystem.InvitationConfig, DevicesCore.ModalScreen>
extension DevicesCore.Factory where Arg == DevicesDesignSystem.InvitationConfig, Item == DevicesCore.ModalScreen {
  public init()
}
public protocol InvitationScreen {
  func asViewController() -> UIKit.UIViewController
  func set(messagingDelegate: MessageUI.MFMessageComposeViewControllerDelegate)
  func set(recipients: [Swift.String])
  func set(message: Swift.String)
}
extension MessageUI.MFMessageComposeViewController : DevicesDesignSystem.InvitationScreen {
  @_Concurrency.MainActor(unsafe) public func asViewController() -> UIKit.UIViewController
  @_Concurrency.MainActor(unsafe) public func set(messagingDelegate: MessageUI.MFMessageComposeViewControllerDelegate)
  @_Concurrency.MainActor(unsafe) public func set(recipients: [Swift.String])
  @_Concurrency.MainActor(unsafe) public func set(message: Swift.String)
}
public struct LayoutGridMetrics {
  public init(margins: UIKit.UIEdgeInsets, columnGap: CoreFoundation.CGFloat, totalNumberOfColumns: Swift.Int, numberOfColumns: Swift.Int, canvasWidth: CoreFoundation.CGFloat)
}
extension DevicesDesignSystem.LeftModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.LeftModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public enum LeftTypeTag {
}
public typealias LeftType = DevicesCore.Tagged<DevicesDesignSystem.LeftTypeTag, Swift.String>
extension DevicesCore.Tagged where Tag == DevicesDesignSystem.LeftTypeTag, T == Swift.String {
  public static let fastAnswer: DevicesDesignSystem.LeftType
  public static let simpleLeft: DevicesDesignSystem.LeftType
  public static let flexibleImage: DevicesDesignSystem.LeftType
  public static let imageTexts: DevicesDesignSystem.LeftType
  public static let plasmaButton: DevicesDesignSystem.LeftType
}
public enum LeftModel : Swift.Hashable {
  case simpleLeft(DevicesDesignSystem.SimpleLeftModel)
  case fastAnswerLeft(DevicesDesignSystem.FastAnswerLeftModel)
  case flexibleImage(DevicesDesignSystem.FlexibleImageCellModel)
  case imageTexts(DevicesDesignSystem.ImageTextsLeftCellModel)
  case plasmaButton(DevicesDesignSystem.PlasmaButtonCellModel)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.LeftModel, b: DevicesDesignSystem.LeftModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.LeftRightCellModel {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public struct Deserializable : DevicesCore.Deserializable, Swift.Equatable {
    public let model: DevicesDesignSystem.LeftRightCellModel
    public init(model: DevicesDesignSystem.LeftRightCellModel)
    public init(deserializer: DevicesCore.Deserializer) throws
    public static func == (a: DevicesDesignSystem.LeftRightCellModel.Deserializable, b: DevicesDesignSystem.LeftRightCellModel.Deserializable) -> Swift.Bool
  }
}
extension DevicesDesignSystem.LeftRightCellModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct LeftRightCellModel : Swift.Hashable {
  public let left: DevicesDesignSystem.LeftModel
  public let right: DevicesDesignSystem.RightModel?
  public let actions: [DevicesDesignSystem.AnyAction]?
  public let divider: DevicesDesignSystem.DividerModel?
  public let paddings: DevicesDesignSystem.Paddings
  public let logId: DevicesDesignSystem.LogID?
  public let accessibility: Swift.String?
  public init(left: DevicesDesignSystem.LeftModel, right: DevicesDesignSystem.RightModel?, actions: [DevicesDesignSystem.AnyAction]?, divider: DevicesDesignSystem.DividerModel?, paddings: DevicesDesignSystem.Paddings?, logId: DevicesDesignSystem.LogID? = nil, accessibility: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.LeftRightCellModel, b: DevicesDesignSystem.LeftRightCellModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.LegacyButtonModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct LegacyButtonModel : Swift.Hashable {
  public enum Error : Foundation.LocalizedError {
    case actionsAreEmpty
    public static func == (a: DevicesDesignSystem.LegacyButtonModel.Error, b: DevicesDesignSystem.LegacyButtonModel.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let textModel: DevicesDesignSystem.TextModel
  public let actions: [DevicesDesignSystem.AnyAction]
  public let highlightEffect: DevicesDesignSystem.ButtonModel.HighlightEffect?
  public let margins: DevicesDesignSystem.Margins
  public let appearance: DevicesDesignSystem.ButtonModel.Appearance
  public let logId: DevicesDesignSystem.LogID?
  public let accessibility: Swift.String?
  public let spinner: DevicesDesignSystem.ProgressSpinnerModel?
  public let elementType: DevicesDesignSystem.ElementType
  @available(*, deprecated, message: "Use PlasmaButtonModel")
  public init(text: DevicesUI.StringContent, appearance: DevicesDesignSystem.ButtonModel.Appearance, typeface: DevicesDesignSystem.Typeface?, actions: [DevicesDesignSystem.AnyAction], highlightEffect: DevicesDesignSystem.ButtonModel.HighlightEffect? = nil, margins: DevicesDesignSystem.Margins? = nil, logId: DevicesDesignSystem.LogID? = nil, spinner: DevicesDesignSystem.ProgressSpinnerModel? = nil, accessibility: Swift.String? = nil) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.LegacyButtonModel, b: DevicesDesignSystem.LegacyButtonModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum LegacyButtonModelStyle : Swift.String, Swift.Decodable {
  case `default`
  case transparent
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension DevicesDesignSystem.ListCardModel : DevicesDesignSystem.WidgetCard {
}
extension DevicesDesignSystem.ListCardModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.ListCardModel : DevicesUI.ViewRenderable, DevicesDesignSystem.CardBase {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct ListCardModel : Swift.Hashable {
  public let cells: [DevicesDesignSystem.CellModel]
  public let paddings: DevicesDesignSystem.Paddings
  public let canBeDisabled: Swift.Bool
  public let actions: [DevicesDesignSystem.AnyAction]?
  public let logId: DevicesDesignSystem.LogID?
  public let backgroundImage: DevicesDesignSystem.FlexibleImageModel?
  public let backgroundColor: DevicesDesignSystem.ColorProtocol
  public let topAccessibility: Swift.String?
  public init(cells: [DevicesDesignSystem.CellModel], paddings: DevicesDesignSystem.Paddings? = nil, canBeDisabled: Swift.Bool = false, actions: [DevicesDesignSystem.AnyAction]? = nil, logId: DevicesDesignSystem.LogID? = nil, backgroundImage: DevicesDesignSystem.FlexibleImageModel? = nil, backgroundColor: DevicesDesignSystem.ColorProtocol = SurfaceColor.card, topAccessibility: Swift.String? = nil)
  public static func == (lhs: DevicesDesignSystem.ListCardModel, rhs: DevicesDesignSystem.ListCardModel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.LoadingDotsModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing _: DevicesUI.View?) -> DevicesUI.View
}
public struct LoadingDotsModel {
  public let dotSideSize: CoreFoundation.CGFloat
  public let dotCount: Swift.Int
  public let color: DevicesDesignSystem.TypeColor
  public let spacing: CoreFoundation.CGFloat
  public let shouldShowAnimation: Swift.Bool
  public let animationDuration: Swift.Double
  public init(dotSideSize: CoreFoundation.CGFloat, dotCount: Swift.Int, color: DevicesDesignSystem.TypeColor, spacing: CoreFoundation.CGFloat, shouldShowAnimation: Swift.Bool = true, animationDuration: Swift.Double)
}
public enum LogIDTag {
}
public typealias LogID = DevicesCore.Tagged<DevicesDesignSystem.LogIDTag, Swift.String>
public struct LoopedAnimationModel : DevicesUI.ViewRenderable {
  public init(animationID: DevicesDesignSystem.AnimationID, makeAnimationAreaFrame: ((_ bounds: CoreFoundation.CGSize) -> CoreFoundation.CGRect)? = nil, loopMode: DevicesDesignSystem.LottieLoopMode, backgroundBehavior: DevicesDesignSystem.LottieBackgroundBehavior = .pauseAndRestore)
  public func renderView(context: DevicesUI.ViewContext, reusing _: DevicesUI.View?) -> DevicesUI.View
}
public enum LottieBackgroundBehavior : Swift.Equatable {
  case stop
  case pause
  case pauseAndRestore
  case forceFinish
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.LottieBackgroundBehavior, b: DevicesDesignSystem.LottieBackgroundBehavior) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol LottieImageFactory {
  func makeLottieView(id: DevicesDesignSystem.AnimationID) -> DevicesDesignSystem.LottieView
  func makeLottieView(dynamicAnimation: Foundation.Data) -> DevicesDesignSystem.LottieView?
}
public enum LottieLoopMode : Swift.Equatable {
  case playOnce
  case loop
  case autoReverse
  case `repeat`(Swift.Float)
  case repeatBackwards(Swift.Float)
  public static func == (a: DevicesDesignSystem.LottieLoopMode, b: DevicesDesignSystem.LottieLoopMode) -> Swift.Bool
}
public protocol LottieView : AnyObject, DevicesUI.View {
  var isAnimationPlaying: Swift.Bool { get }
  var currentProgress: CoreFoundation.CGFloat { get set }
  var sdBackgroundBehavior: DevicesDesignSystem.LottieBackgroundBehavior { get set }
  func play(fromProgress: CoreFoundation.CGFloat?, toProgress: CoreFoundation.CGFloat, loopMode: DevicesDesignSystem.LottieLoopMode?, completion: ((Swift.Bool) -> Swift.Void)?)
  func play(fromMarker: Swift.String?, toMarker: Swift.String, loopMode: DevicesDesignSystem.LottieLoopMode?, completion: ((Swift.Bool) -> Swift.Void)?)
}
public protocol MarkdownStyleProvider {
  var markdownStyle: DevicesCore.MarkdownStyler { get }
}
extension DevicesDesignSystem.MessageToastModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct MessageToastModel {
  public let text: DevicesDesignSystem.TextModel
  public let backgroundColor: DevicesDesignSystem.ColorProtocol
  public let cornerRadius: CoreFoundation.CGFloat
  public init(message: DevicesUI.StringContent, backgroundColor: DevicesDesignSystem.ColorProtocol = TypeColor.globalBlack, cornerRadius: CoreFoundation.CGFloat = 20.0, maxLines: Swift.Int = 3)
}
public protocol ModalScreenDismisser {
  var isModalPresented: Swift.Bool { get }
  func dismissScreen()
}
public protocol ModalScreenPresenter : DevicesDesignSystem.ModalScreenDismisser {
  func presentScreen(_ screen: DevicesCore.ModalScreen)
  func forgetPresentedModalScreen()
}
final public class ModalScreenPresenterProxy : DevicesDesignSystem.ModalScreenPresenter {
  final public var subject: DevicesDesignSystem.ModalScreenPresenter!
  public init()
  final public func presentScreen(_ screen: DevicesCore.ModalScreen)
  final public var isModalPresented: Swift.Bool {
    get
  }
  final public func dismissScreen()
  final public func forgetPresentedModalScreen()
  @objc deinit
}
public struct MultilineDefaultTextStyle : DevicesUI.MultilineTextStyle {
  public init(typeface: DevicesDesignSystem.Typeface, typeColor: DevicesDesignSystem.TypeColor)
  public func makeMultilineTextConfig(context: DevicesUI.ViewContext) -> DevicesUI.MultilineTextConfig
}
public protocol NativeStyleProvider {
  var interfaceStyle: DevicesDesignSystem.UserInterfaceStyle { get }
}
extension DevicesDesignSystem.NativeStyleProvider {
  public var keyboardAppearance: UIKit.UIKeyboardAppearance {
    get
  }
  public var navigationBarStyle: UIKit.UIBarStyle {
    get
  }
  public var statusBarStyle: UIKit.UIStatusBarStyle {
    get
  }
}
extension DevicesUI.NativeViewRenderable {
  @inlinable public func backgroundColor(_ color: DevicesDesignSystem.ColorProtocol) -> DevicesUI.NativeViewRenderable {
		transform(label: "backgroundColor") { subject, context, view in
			let newColor = context[.brandbook].value(for: color)
			return subject.backgroundColor(newColor).renderNativeView(context: context, reusing: view)
		}
	}
  @inlinable public func backgroundColor(_ color: DevicesDesignSystem.SurfaceColor) -> DevicesUI.NativeViewRenderable {
		transform(label: "backgroundColor") { subject, context, view in
			let newColor = context[.brandbook].value(for: color)
			return subject.backgroundColor(newColor).renderNativeView(context: context, reusing: view)
		}
	}
  @inlinable public func backgroundColor(_ color: DevicesDesignSystem.BackgroundColor) -> DevicesUI.NativeViewRenderable {
		transform(label: "backgroundColor") { subject, context, view in
			let newColor = context[.brandbook].value(for: color)
			return subject.backgroundColor(newColor).renderNativeView(context: context, reusing: view)
		}
	}
  @inlinable public func backgroundColor(_ color: DevicesDesignSystem.ButtonColor) -> DevicesUI.NativeViewRenderable {
		transform(label: "backgroundColor") { subject, context, view in
			let newColor = context[.brandbook].value(for: color)
			return subject.backgroundColor(newColor).renderNativeView(context: context, reusing: view)
		}
	}
  @inlinable public func backgroundColor(_ color: DevicesDesignSystem.SpeechBubbleColor) -> DevicesUI.NativeViewRenderable {
		transform(label: "backgroundColor") { subject, context, view in
			let newColor = context[.brandbook].value(for: color)
			return subject.backgroundColor(newColor).renderNativeView(context: context, reusing: view)
		}
	}
  @inlinable public func tintColor(_ color: DevicesDesignSystem.BackgroundColor?) -> DevicesUI.NativeViewRenderable {
		transform(label: "tintColor") { subject, context, view in
			let newColor = color.map(context[.brandbook].value)
			return subject.tintColor(newColor).renderNativeView(context: context, reusing: view)
		}
	}
  @inlinable public func tintColor(_ color: DevicesDesignSystem.TypeColor?) -> DevicesUI.NativeViewRenderable {
		transform(label: "tintColor") { subject, context, view in
			let newColor = color.map(context[.brandbook].value)
			return subject.tintColor(newColor).renderNativeView(context: context, reusing: view)
		}
	}
  @inlinable public func animatableLayout(_ duration: DevicesDesignSystem.AnimationDurationID) -> DevicesUI.NativeViewRenderable {
		transform(label: "animatableLayout") { subject, context, view in
			let animationDuration = context[.brandbook].duration(for: duration)
			return subject.animatableLayout(animationDuration).renderNativeView(context: context, reusing: view)
		}
	}
  @inlinable public func cornerRadius(_ cornerRadius: DevicesDesignSystem.Dimensions, cornerMask: QuartzCore.CACornerMask = .layerAllCorners) -> DevicesUI.NativeViewRenderable {
		transform(label: "cornerRadius") { subject, context, view in
			let cornerRadius = context[.brandbook].value(for: cornerRadius)
			return subject
				.cornerRadius(cornerRadius, corners: cornerMask)
				.renderNativeView(context: context, reusing: view)
		}
	}
}
extension DevicesDesignSystem.NestedContentGalleryModel : DevicesCore.Deserializable {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.NestedContentGalleryModel.Item : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.NestedContentGalleryModel.ImageTextItem : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.NestedContentGalleryModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
extension DevicesDesignSystem.NestedContentGalleryModel.Item : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
extension DevicesDesignSystem.NestedContentGalleryModel.ImageTextItem : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct NestedContentGalleryModel : Swift.Hashable {
  public struct ImageTextItem : Swift.Hashable {
    public init(image: DevicesDesignSystem.FlexibleImageModel?, texts: DevicesDesignSystem.VerticalTextsModel?, width: DevicesDesignSystem.ContentWidth, actions: [DevicesDesignSystem.AnyAction]?, logId: DevicesDesignSystem.LogID? = nil)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.NestedContentGalleryModel.ImageTextItem, b: DevicesDesignSystem.NestedContentGalleryModel.ImageTextItem) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Item : Swift.Hashable {
    case imageText(DevicesDesignSystem.NestedContentGalleryModel.ImageTextItem)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.NestedContentGalleryModel.Item, b: DevicesDesignSystem.NestedContentGalleryModel.Item) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public var contentInsets: DevicesDesignSystem.Insets
  public let logId: DevicesDesignSystem.LogID?
  public let items: [DevicesDesignSystem.NestedContentGalleryModel.Item]
  public init(logId: DevicesDesignSystem.LogID?, items: [DevicesDesignSystem.NestedContentGalleryModel.Item], contentInsets: DevicesDesignSystem.Insets = .zero)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.NestedContentGalleryModel, b: DevicesDesignSystem.NestedContentGalleryModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.NestedContentListModel : DevicesCore.Deserializable {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.NestedContentListModel.Item : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.NestedContentListModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
extension DevicesDesignSystem.NestedContentListModel.Item : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct NestedContentListModel : Swift.Hashable {
  public enum Item : Swift.Hashable {
    case leftRightCell(DevicesDesignSystem.LeftRightCellModel)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.NestedContentListModel.Item, b: DevicesDesignSystem.NestedContentListModel.Item) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public let items: [DevicesDesignSystem.NestedContentListModel.Item]
  public let divider: DevicesDesignSystem.DividerModel?
  public let bottomCell: DevicesDesignSystem.CellModel?
  public init(items: [DevicesDesignSystem.NestedContentListModel.Item], divider: DevicesDesignSystem.DividerModel?, bottomCell: DevicesDesignSystem.CellModel?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.NestedContentListModel, b: DevicesDesignSystem.NestedContentListModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.NestedContentModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.NestedContentModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public enum NestedContentModel : Swift.Hashable {
  case list(DevicesDesignSystem.NestedContentListModel)
  case gallery(DevicesDesignSystem.NestedContentGalleryModel)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.NestedContentModel, b: DevicesDesignSystem.NestedContentModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct OpenURLAction : DevicesDesignSystem.Action, Swift.Equatable {
  public let url: Foundation.URL
  public init(url: Foundation.URL)
  public static func == (lhs: DevicesDesignSystem.OpenURLAction, rhs: DevicesDesignSystem.OpenURLAction) -> Swift.Bool
}
extension DevicesDesignSystem.AnyAction {
  public static func open(url: Foundation.URL) -> DevicesDesignSystem.AnyAction
}
final public class OpenURLActionPerformer : DevicesDesignSystem.ActionPerformer {
  public init(linkHandler: DevicesCore.URLHandler)
  final public func perform(_ action: DevicesDesignSystem.AnyAction, sender _: DevicesDesignSystem.ActionSender) -> Swift.Bool
  @objc deinit
}
extension DevicesDesignSystem.OperatorCardCellModel : DevicesCore.Deserializable {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.OperatorCardCellModel.TextPlug : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.OperatorCardCellModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct OperatorCardCellModel : Swift.Hashable {
  public let icon: DevicesDesignSystem.IconModel
  public let placeholder: DevicesDesignSystem.TextModel
  public let badgeColor: DevicesDesignSystem.BackgroundColor
  public let titleStyle: DevicesDesignSystem.OperatorCardCellModel.TextPlug
  public let subtitleStyle: DevicesDesignSystem.OperatorCardCellModel.TextPlug
  public let paddings: DevicesDesignSystem.Paddings
  public let accessibility: Swift.String?
  public struct TextPlug : Swift.Hashable {
    public let style: DevicesDesignSystem.TextViewStyle
    public let margins: DevicesDesignSystem.Margins
    public init(style: DevicesDesignSystem.TextViewStyle, margins: DevicesDesignSystem.Margins?)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.OperatorCardCellModel.TextPlug, b: DevicesDesignSystem.OperatorCardCellModel.TextPlug) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(icon: DevicesDesignSystem.IconModel, placeholder: DevicesDesignSystem.TextModel, badgeColor: DevicesDesignSystem.BackgroundColor, titleMock: DevicesDesignSystem.OperatorCardCellModel.TextPlug, subtitleMock: DevicesDesignSystem.OperatorCardCellModel.TextPlug, paddings: DevicesDesignSystem.Paddings?, accessibility: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.OperatorCardCellModel, b: DevicesDesignSystem.OperatorCardCellModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct OperatorCardChatInfo : Swift.Equatable {
  public enum ChatMessage : Swift.Equatable {
    case personal(DevicesDesignSystem.OperatorCardChatInfo.ChatMessage.Personal)
    case system(text: Swift.String)
    public struct Personal : Swift.Equatable {
      public let text: Swift.String
      public let isMine: Swift.Bool
      public let ownerName: Swift.String
      public init(text: Swift.String, isMine: Swift.Bool, ownerName: Swift.String)
      public static func == (a: DevicesDesignSystem.OperatorCardChatInfo.ChatMessage.Personal, b: DevicesDesignSystem.OperatorCardChatInfo.ChatMessage.Personal) -> Swift.Bool
    }
    public static func == (a: DevicesDesignSystem.OperatorCardChatInfo.ChatMessage, b: DevicesDesignSystem.OperatorCardChatInfo.ChatMessage) -> Swift.Bool
  }
  public let lastMessage: DevicesDesignSystem.OperatorCardChatInfo.ChatMessage
  public let unreadCounter: Swift.Int
  public let lastUpdate: Swift.Double
  public init(lastMessage: DevicesDesignSystem.OperatorCardChatInfo.ChatMessage, unreadCounter: Swift.Int, lastUpdate: Swift.Double)
  public static func == (a: DevicesDesignSystem.OperatorCardChatInfo, b: DevicesDesignSystem.OperatorCardChatInfo) -> Swift.Bool
}
public enum PaymentColor : Swift.String {
  case popupDimmedBackgroundColor
  case rightArrowTintColor
  case sbp
  case sbpInverse
  case tinkoff
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension DevicesUI.NativeViewRenderable {
  @inlinable public func tintColor(_ color: DevicesDesignSystem.PaymentColor) -> DevicesUI.NativeViewRenderable {
		transform(label: "tintColor") { subject, context, view in
			let newColor = context[.brandbook].value(for: color)
			return subject.tintColor(newColor).renderNativeView(context: context, reusing: view)
		}
	}
}
extension DevicesDesignSystem.PaymentColor : DevicesDesignSystem.ColorProtocol {
  public func value(characterSemantic _: DevicesDesignSystem.CharacterSemantic, userInterfaceStyle: DevicesDesignSystem.UserInterfaceStyle) -> UIKit.UIColor
}
public enum PhoneContactHashTag {
}
public typealias PhoneContactHash = DevicesCore.Tagged<DevicesDesignSystem.PhoneContactHashTag, Swift.String>
public typealias PlasmaButtonCellModel = DevicesDesignSystem.SingleContentCellModel<DevicesDesignSystem.PlasmaButtonModel>
public struct PlasmaButtonModel : Swift.Hashable {
  public init(text: Swift.String, actions: [DevicesDesignSystem.AnyAction], logId: DevicesDesignSystem.LogID? = nil, style: DevicesDesignSystem.PlasmaButtonStyleID? = nil, icon: DevicesDesignSystem.ImageAddress? = nil, paddings: DevicesDesignSystem.Paddings? = nil, roundedCorners: DevicesDesignSystem.CornersRounding? = nil, accessibility: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.PlasmaButtonModel, b: DevicesDesignSystem.PlasmaButtonModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.PlasmaButtonModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.PlasmaButtonModel : DevicesUI.ViewRenderable {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct PlasmaButtonStyle : DevicesUI.ButtonStyle {
  public init(style: DevicesDesignSystem.PlasmaButtonStyleID? = nil, paddings: DevicesDesignSystem.Paddings? = nil, roundedCorners: DevicesDesignSystem.CornersRounding? = nil)
  public func transformContent(config: DevicesUI.ButtonStyleConfig, context: DevicesUI.ViewContext) -> DevicesUI.ViewRenderable
}
extension DevicesDesignSystem.PlasmaButtonStyle : SwiftUI.ButtonStyle {
  public func makeBody(configuration: SwiftUI.ButtonStyleConfiguration) -> some SwiftUI.View
  
  public typealias Body = @_opaqueReturnTypeOf("$s19DevicesDesignSystem17PlasmaButtonStyleV8makeBody13configurationQr7SwiftUI0eF13ConfigurationV_tF", 0) __
}
public enum PlasmaButtonStyleID : Swift.String, Swift.CaseIterable {
  case primary
  case secondary
  case warning
  case checked
  case critical
  case clear
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DevicesDesignSystem.PlasmaButtonStyleID]
  public typealias RawValue = Swift.String
  public static var allCases: [DevicesDesignSystem.PlasmaButtonStyleID] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum PlasmaTokensColor {
  public static let baseBlack: UIKit.UIColor
  public static let baseBlackPrimary: UIKit.UIColor
  public static let baseBlackSecondary: UIKit.UIColor
  public static let baseBlackTertiary: UIKit.UIColor
  public static let baseButtonBlack: UIKit.UIColor
  public static let baseButtonBlackSecondary: UIKit.UIColor
  public static let baseButtonBlackTransparent: UIKit.UIColor
  public static let baseButtonClear: UIKit.UIColor
  public static let baseButtonWhite: UIKit.UIColor
  public static let baseButtonWhiteSecondary: UIKit.UIColor
  public static let baseDark01: UIKit.UIColor
  public static let baseDark02: UIKit.UIColor
  public static let baseDark03: UIKit.UIColor
  public static let baseTransparent: UIKit.UIColor
  public static let baseWhite: UIKit.UIColor
  public static let baseWhitePrimary: UIKit.UIColor
  public static let baseWhiteSecondary: UIKit.UIColor
  public static let baseWhiteTertiary: UIKit.UIColor
  public static let darkEvaAccent: UIKit.UIColor
  public static let darkEvaBackground: UIKit.UIColor
  public static let darkEvaBackgroundPrimary: UIKit.UIColor
  public static let darkEvaBackgroundSecondary: UIKit.UIColor
  public static let darkEvaBackgroundTertiary: UIKit.UIColor
  public static let darkEvaBlackPrimary: UIKit.UIColor
  public static let darkEvaBlackSecondary: UIKit.UIColor
  public static let darkEvaBlackTertiary: UIKit.UIColor
  public static let darkEvaButtonAccent: UIKit.UIColor
  public static let darkEvaButtonBlack: UIKit.UIColor
  public static let darkEvaButtonBlackSecondary: UIKit.UIColor
  public static let darkEvaButtonBlackTransparent: UIKit.UIColor
  public static let darkEvaButtonChecked: UIKit.UIColor
  public static let darkEvaButtonClear: UIKit.UIColor
  public static let darkEvaButtonCritical: UIKit.UIColor
  public static let darkEvaButtonFocused: UIKit.UIColor
  public static let darkEvaButtonPrimary: UIKit.UIColor
  public static let darkEvaButtonSecondary: UIKit.UIColor
  public static let darkEvaButtonSuccess: UIKit.UIColor
  public static let darkEvaButtonWarning: UIKit.UIColor
  public static let darkEvaButtonWhite: UIKit.UIColor
  public static let darkEvaButtonWhiteSecondary: UIKit.UIColor
  public static let darkEvaCritical: UIKit.UIColor
  public static let darkEvaInverse: UIKit.UIColor
  public static let darkEvaOverlay: UIKit.UIColor
  public static let darkEvaParagraph: UIKit.UIColor
  public static let darkEvaPrimary: UIKit.UIColor
  public static let darkEvaSecondary: UIKit.UIColor
  public static let darkEvaSpeechBubbleReceived: UIKit.UIColor
  public static let darkEvaSpeechBubbleSent: UIKit.UIColor
  public static let darkEvaSuccess: UIKit.UIColor
  public static let darkEvaSurfaceCard: UIKit.UIColor
  public static let darkEvaSurfaceLiquid01: UIKit.UIColor
  public static let darkEvaSurfaceLiquid02: UIKit.UIColor
  public static let darkEvaSurfaceLiquid03: UIKit.UIColor
  public static let darkEvaSurfaceSolid01: UIKit.UIColor
  public static let darkEvaSurfaceSolid02: UIKit.UIColor
  public static let darkEvaSurfaceSolid03: UIKit.UIColor
  public static let darkEvaTertiary: UIKit.UIColor
  public static let darkEvaText: UIKit.UIColor
  public static let darkEvaWarning: UIKit.UIColor
  public static let darkEvaWhitePrimary: UIKit.UIColor
  public static let darkEvaWhiteSecondary: UIKit.UIColor
  public static let darkEvaWhiteTertiary: UIKit.UIColor
  public static let darkJoyAccent: UIKit.UIColor
  public static let darkJoyBackground: UIKit.UIColor
  public static let darkJoyBackgroundPrimary: UIKit.UIColor
  public static let darkJoyBackgroundSecondary: UIKit.UIColor
  public static let darkJoyBackgroundTertiary: UIKit.UIColor
  public static let darkJoyBlackPrimary: UIKit.UIColor
  public static let darkJoyBlackSecondary: UIKit.UIColor
  public static let darkJoyBlackTertiary: UIKit.UIColor
  public static let darkJoyButtonAccent: UIKit.UIColor
  public static let darkJoyButtonBlack: UIKit.UIColor
  public static let darkJoyButtonBlackSecondary: UIKit.UIColor
  public static let darkJoyButtonBlackTransparent: UIKit.UIColor
  public static let darkJoyButtonChecked: UIKit.UIColor
  public static let darkJoyButtonClear: UIKit.UIColor
  public static let darkJoyButtonCritical: UIKit.UIColor
  public static let darkJoyButtonFocused: UIKit.UIColor
  public static let darkJoyButtonPrimary: UIKit.UIColor
  public static let darkJoyButtonSecondary: UIKit.UIColor
  public static let darkJoyButtonSuccess: UIKit.UIColor
  public static let darkJoyButtonWarning: UIKit.UIColor
  public static let darkJoyButtonWhite: UIKit.UIColor
  public static let darkJoyButtonWhiteSecondary: UIKit.UIColor
  public static let darkJoyCritical: UIKit.UIColor
  public static let darkJoyInverse: UIKit.UIColor
  public static let darkJoyOverlay: UIKit.UIColor
  public static let darkJoyParagraph: UIKit.UIColor
  public static let darkJoyPrimary: UIKit.UIColor
  public static let darkJoySecondary: UIKit.UIColor
  public static let darkJoySpeechBubbleReceived: UIKit.UIColor
  public static let darkJoySpeechBubbleSent: UIKit.UIColor
  public static let darkJoySuccess: UIKit.UIColor
  public static let darkJoySurfaceCard: UIKit.UIColor
  public static let darkJoySurfaceLiquid01: UIKit.UIColor
  public static let darkJoySurfaceLiquid02: UIKit.UIColor
  public static let darkJoySurfaceLiquid03: UIKit.UIColor
  public static let darkJoySurfaceSolid01: UIKit.UIColor
  public static let darkJoySurfaceSolid02: UIKit.UIColor
  public static let darkJoySurfaceSolid03: UIKit.UIColor
  public static let darkJoyTertiary: UIKit.UIColor
  public static let darkJoyText: UIKit.UIColor
  public static let darkJoyWarning: UIKit.UIColor
  public static let darkJoyWhitePrimary: UIKit.UIColor
  public static let darkJoyWhiteSecondary: UIKit.UIColor
  public static let darkJoyWhiteTertiary: UIKit.UIColor
  public static let darkSberAccent: UIKit.UIColor
  public static let darkSberBackground: UIKit.UIColor
  public static let darkSberBackgroundPrimary: UIKit.UIColor
  public static let darkSberBackgroundSecondary: UIKit.UIColor
  public static let darkSberBackgroundTertiary: UIKit.UIColor
  public static let darkSberBlackPrimary: UIKit.UIColor
  public static let darkSberBlackSecondary: UIKit.UIColor
  public static let darkSberBlackTertiary: UIKit.UIColor
  public static let darkSberButtonAccent: UIKit.UIColor
  public static let darkSberButtonBlack: UIKit.UIColor
  public static let darkSberButtonBlackSecondary: UIKit.UIColor
  public static let darkSberButtonBlackTransparent: UIKit.UIColor
  public static let darkSberButtonChecked: UIKit.UIColor
  public static let darkSberButtonClear: UIKit.UIColor
  public static let darkSberButtonCritical: UIKit.UIColor
  public static let darkSberButtonFocused: UIKit.UIColor
  public static let darkSberButtonPrimary: UIKit.UIColor
  public static let darkSberButtonSecondary: UIKit.UIColor
  public static let darkSberButtonSuccess: UIKit.UIColor
  public static let darkSberButtonWarning: UIKit.UIColor
  public static let darkSberButtonWhite: UIKit.UIColor
  public static let darkSberButtonWhiteSecondary: UIKit.UIColor
  public static let darkSberCritical: UIKit.UIColor
  public static let darkSberInverse: UIKit.UIColor
  public static let darkSberOverlay: UIKit.UIColor
  public static let darkSberParagraph: UIKit.UIColor
  public static let darkSberPrimary: UIKit.UIColor
  public static let darkSberSecondary: UIKit.UIColor
  public static let darkSberSpeechBubbleReceived: UIKit.UIColor
  public static let darkSberSpeechBubbleSent: UIKit.UIColor
  public static let darkSberSuccess: UIKit.UIColor
  public static let darkSberSurfaceCard: UIKit.UIColor
  public static let darkSberSurfaceLiquid01: UIKit.UIColor
  public static let darkSberSurfaceLiquid02: UIKit.UIColor
  public static let darkSberSurfaceLiquid03: UIKit.UIColor
  public static let darkSberSurfaceSolid01: UIKit.UIColor
  public static let darkSberSurfaceSolid02: UIKit.UIColor
  public static let darkSberSurfaceSolid03: UIKit.UIColor
  public static let darkSberTertiary: UIKit.UIColor
  public static let darkSberText: UIKit.UIColor
  public static let darkSberWarning: UIKit.UIColor
  public static let darkSberWhitePrimary: UIKit.UIColor
  public static let darkSberWhiteSecondary: UIKit.UIColor
  public static let darkSberWhiteTertiary: UIKit.UIColor
  public static let lightEvaAccent: UIKit.UIColor
  public static let lightEvaBackground: UIKit.UIColor
  public static let lightEvaBackgroundPrimary: UIKit.UIColor
  public static let lightEvaBackgroundSecondary: UIKit.UIColor
  public static let lightEvaBackgroundTertiary: UIKit.UIColor
  public static let lightEvaBlackPrimary: UIKit.UIColor
  public static let lightEvaBlackSecondary: UIKit.UIColor
  public static let lightEvaBlackTertiary: UIKit.UIColor
  public static let lightEvaButtonAccent: UIKit.UIColor
  public static let lightEvaButtonBlack: UIKit.UIColor
  public static let lightEvaButtonBlackSecondary: UIKit.UIColor
  public static let lightEvaButtonBlackTransparent: UIKit.UIColor
  public static let lightEvaButtonChecked: UIKit.UIColor
  public static let lightEvaButtonClear: UIKit.UIColor
  public static let lightEvaButtonCritical: UIKit.UIColor
  public static let lightEvaButtonFocused: UIKit.UIColor
  public static let lightEvaButtonPrimary: UIKit.UIColor
  public static let lightEvaButtonSecondary: UIKit.UIColor
  public static let lightEvaButtonSuccess: UIKit.UIColor
  public static let lightEvaButtonWarning: UIKit.UIColor
  public static let lightEvaButtonWhite: UIKit.UIColor
  public static let lightEvaButtonWhiteSecondary: UIKit.UIColor
  public static let lightEvaCritical: UIKit.UIColor
  public static let lightEvaInverse: UIKit.UIColor
  public static let lightEvaOverlay: UIKit.UIColor
  public static let lightEvaParagraph: UIKit.UIColor
  public static let lightEvaPrimary: UIKit.UIColor
  public static let lightEvaSecondary: UIKit.UIColor
  public static let lightEvaSpeechBubbleReceived: UIKit.UIColor
  public static let lightEvaSpeechBubbleSent: UIKit.UIColor
  public static let lightEvaSuccess: UIKit.UIColor
  public static let lightEvaSurfaceCard: UIKit.UIColor
  public static let lightEvaSurfaceLiquid01: UIKit.UIColor
  public static let lightEvaSurfaceLiquid02: UIKit.UIColor
  public static let lightEvaSurfaceLiquid03: UIKit.UIColor
  public static let lightEvaSurfaceSolid01: UIKit.UIColor
  public static let lightEvaSurfaceSolid02: UIKit.UIColor
  public static let lightEvaSurfaceSolid03: UIKit.UIColor
  public static let lightEvaTertiary: UIKit.UIColor
  public static let lightEvaText: UIKit.UIColor
  public static let lightEvaWarning: UIKit.UIColor
  public static let lightEvaWhitePrimary: UIKit.UIColor
  public static let lightEvaWhiteSecondary: UIKit.UIColor
  public static let lightEvaWhiteTertiary: UIKit.UIColor
  public static let lightJoyAccent: UIKit.UIColor
  public static let lightJoyBackground: UIKit.UIColor
  public static let lightJoyBackgroundPrimary: UIKit.UIColor
  public static let lightJoyBackgroundSecondary: UIKit.UIColor
  public static let lightJoyBackgroundTertiary: UIKit.UIColor
  public static let lightJoyBlackPrimary: UIKit.UIColor
  public static let lightJoyBlackSecondary: UIKit.UIColor
  public static let lightJoyBlackTertiary: UIKit.UIColor
  public static let lightJoyButtonAccent: UIKit.UIColor
  public static let lightJoyButtonBlack: UIKit.UIColor
  public static let lightJoyButtonBlackSecondary: UIKit.UIColor
  public static let lightJoyButtonBlackTransparent: UIKit.UIColor
  public static let lightJoyButtonChecked: UIKit.UIColor
  public static let lightJoyButtonClear: UIKit.UIColor
  public static let lightJoyButtonCritical: UIKit.UIColor
  public static let lightJoyButtonFocused: UIKit.UIColor
  public static let lightJoyButtonPrimary: UIKit.UIColor
  public static let lightJoyButtonSecondary: UIKit.UIColor
  public static let lightJoyButtonSuccess: UIKit.UIColor
  public static let lightJoyButtonWarning: UIKit.UIColor
  public static let lightJoyButtonWhite: UIKit.UIColor
  public static let lightJoyButtonWhiteSecondary: UIKit.UIColor
  public static let lightJoyCritical: UIKit.UIColor
  public static let lightJoyInverse: UIKit.UIColor
  public static let lightJoyOverlay: UIKit.UIColor
  public static let lightJoyParagraph: UIKit.UIColor
  public static let lightJoyPrimary: UIKit.UIColor
  public static let lightJoySecondary: UIKit.UIColor
  public static let lightJoySpeechBubbleReceived: UIKit.UIColor
  public static let lightJoySpeechBubbleSent: UIKit.UIColor
  public static let lightJoySuccess: UIKit.UIColor
  public static let lightJoySurfaceCard: UIKit.UIColor
  public static let lightJoySurfaceLiquid01: UIKit.UIColor
  public static let lightJoySurfaceLiquid02: UIKit.UIColor
  public static let lightJoySurfaceLiquid03: UIKit.UIColor
  public static let lightJoySurfaceSolid01: UIKit.UIColor
  public static let lightJoySurfaceSolid02: UIKit.UIColor
  public static let lightJoySurfaceSolid03: UIKit.UIColor
  public static let lightJoyTertiary: UIKit.UIColor
  public static let lightJoyText: UIKit.UIColor
  public static let lightJoyWarning: UIKit.UIColor
  public static let lightJoyWhitePrimary: UIKit.UIColor
  public static let lightJoyWhiteSecondary: UIKit.UIColor
  public static let lightJoyWhiteTertiary: UIKit.UIColor
  public static let lightSberAccent: UIKit.UIColor
  public static let lightSberBackground: UIKit.UIColor
  public static let lightSberBackgroundPrimary: UIKit.UIColor
  public static let lightSberBackgroundSecondary: UIKit.UIColor
  public static let lightSberBackgroundTertiary: UIKit.UIColor
  public static let lightSberBlackPrimary: UIKit.UIColor
  public static let lightSberBlackSecondary: UIKit.UIColor
  public static let lightSberBlackTertiary: UIKit.UIColor
  public static let lightSberButtonAccent: UIKit.UIColor
  public static let lightSberButtonBlack: UIKit.UIColor
  public static let lightSberButtonBlackSecondary: UIKit.UIColor
  public static let lightSberButtonBlackTransparent: UIKit.UIColor
  public static let lightSberButtonChecked: UIKit.UIColor
  public static let lightSberButtonClear: UIKit.UIColor
  public static let lightSberButtonCritical: UIKit.UIColor
  public static let lightSberButtonFocused: UIKit.UIColor
  public static let lightSberButtonPrimary: UIKit.UIColor
  public static let lightSberButtonSecondary: UIKit.UIColor
  public static let lightSberButtonSuccess: UIKit.UIColor
  public static let lightSberButtonWarning: UIKit.UIColor
  public static let lightSberButtonWhite: UIKit.UIColor
  public static let lightSberButtonWhiteSecondary: UIKit.UIColor
  public static let lightSberCritical: UIKit.UIColor
  public static let lightSberInverse: UIKit.UIColor
  public static let lightSberOverlay: UIKit.UIColor
  public static let lightSberParagraph: UIKit.UIColor
  public static let lightSberPrimary: UIKit.UIColor
  public static let lightSberSecondary: UIKit.UIColor
  public static let lightSberSpeechBubbleReceived: UIKit.UIColor
  public static let lightSberSpeechBubbleSent: UIKit.UIColor
  public static let lightSberSuccess: UIKit.UIColor
  public static let lightSberSurfaceCard: UIKit.UIColor
  public static let lightSberSurfaceLiquid01: UIKit.UIColor
  public static let lightSberSurfaceLiquid02: UIKit.UIColor
  public static let lightSberSurfaceLiquid03: UIKit.UIColor
  public static let lightSberSurfaceSolid01: UIKit.UIColor
  public static let lightSberSurfaceSolid02: UIKit.UIColor
  public static let lightSberSurfaceSolid03: UIKit.UIColor
  public static let lightSberTertiary: UIKit.UIColor
  public static let lightSberText: UIKit.UIColor
  public static let lightSberWarning: UIKit.UIColor
  public static let lightSberWhitePrimary: UIKit.UIColor
  public static let lightSberWhiteSecondary: UIKit.UIColor
  public static let lightSberWhiteTertiary: UIKit.UIColor
}
extension DevicesDesignSystem.ProgressSpinnerModel : DevicesUI.NativeViewRenderable {
  public func renderNativeView(context: DevicesUI.ViewContext, reusing _: DevicesUI.View?) -> DevicesUI.NativeView
}
public struct ProgressSpinnerModel {
  public let image: DevicesCore.ImageID
  public let imageSize: CoreFoundation.CGSize
  public let contentMode: UIKit.UIView.ContentMode
  public let tintColor: DevicesDesignSystem.BackgroundColor?
  public init(image: DevicesCore.ImageID, imageSize: CoreFoundation.CGSize, contentMode: UIKit.UIView.ContentMode = .center, tintColor: DevicesDesignSystem.BackgroundColor? = nil)
}
extension DevicesDesignSystem.ProgressSpinnerModel {
  public init(style: DevicesDesignSystem.ProgressSpinnerStyle)
}
extension DevicesDesignSystem.ProgressSpinnerModel : Swift.Hashable {
  public static func == (lhs: DevicesDesignSystem.ProgressSpinnerModel, rhs: DevicesDesignSystem.ProgressSpinnerModel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ProgressSpinnerStyle {
  case whiteSpinner
  case blackSpinner
  case largeCircle
  case smallCircle
  case mediumCircle
  case blueCircle
  case smallBlueCircle
  case thickBlueCircle
  public static func == (a: DevicesDesignSystem.ProgressSpinnerStyle, b: DevicesDesignSystem.ProgressSpinnerStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_Concurrency.MainActor(unsafe) public struct ProgressSpinnerView : SwiftUI.View {
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s19DevicesDesignSystem19ProgressSpinnerViewV4bodyQrvp", 0) __
}
extension DevicesDesignSystem.ProgressSpinnerView {
  @_Concurrency.MainActor(unsafe) public init(style: DevicesDesignSystem.ProgressSpinnerStyle)
}
final public class PropertyObservableObject<T> : Foundation.ObservableObject {
  @Combine.Published @_projectedValueProperty($value) final public var value: T {
    get
    set
    _modify
  }
  final public var $value: Combine.Published<T>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  public init(_ property: DevicesCore.Property<T>)
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
}
extension DevicesDesignSystem.RadialProgressBar : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct RadialProgressBar {
  public let progress: CoreFoundation.CGFloat
  public let lineWidth: CoreFoundation.CGFloat
  public let color: DevicesDesignSystem.BackgroundColor
  public init(progress: CoreFoundation.CGFloat, lineWidth: CoreFoundation.CGFloat, color: DevicesDesignSystem.BackgroundColor = .solidWhite)
}
public struct RefreshModel {
  public let action: () -> Swift.Void
  public let animationDuration: Foundation.TimeInterval
  public let tintColor: UIKit.UIColor?
  public init(action: @escaping () -> Swift.Void, animationDuration: Foundation.TimeInterval = 0.6, tintColor: UIKit.UIColor? = nil)
}
extension DevicesDesignSystem.RefreshModel : DevicesUI.RefreshViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
  public func renderRefreshControl(context _: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> UIKit.UIRefreshControl
}
extension DevicesDesignSystem.RightModel {
  public struct Deserializable : DevicesCore.Deserializable, Swift.Equatable {
    public let model: DevicesDesignSystem.RightModel
    public init(model: DevicesDesignSystem.RightModel)
    public init(deserializer: DevicesCore.Deserializer) throws
    public static func == (a: DevicesDesignSystem.RightModel.Deserializable, b: DevicesDesignSystem.RightModel.Deserializable) -> Swift.Bool
  }
}
extension DevicesDesignSystem.RightModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public enum RightModel : Swift.Hashable {
  case disclosure(DevicesDesignSystem.DisclosureRightModel)
  case detail(DevicesDesignSystem.DetailRightModel)
  case flexibleImage(DevicesDesignSystem.FlexibleImageCellModel)
  case roundButton(DevicesDesignSystem.RoundButtonCellModel)
  case array(DevicesDesignSystem.ArrayRightModel)
  case tag(DevicesDesignSystem.TagCellModel)
  case plasmaButton(DevicesDesignSystem.PlasmaButtonCellModel)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.RightModel, b: DevicesDesignSystem.RightModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public typealias RoundButtonCellModel = DevicesDesignSystem.SingleContentCellModel<DevicesDesignSystem.RoundButtonModel>
extension DevicesDesignSystem.RoundButtonModel : DevicesCore.Deserializable {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.RoundButtonModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct RoundButtonModel : Swift.Hashable {
  public enum Error : Foundation.LocalizedError {
    case actionsAreEmpty
    public static func == (a: DevicesDesignSystem.RoundButtonModel.Error, b: DevicesDesignSystem.RoundButtonModel.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var icon: DevicesDesignSystem.ImageAddress
  public var iconSize: DevicesDesignSystem.Icon.Size.Dimension
  public var isEnabled: Swift.Bool
  public var tintColor: DevicesDesignSystem.BackgroundColor?
  public var backgroundColor: DevicesDesignSystem.BackgroundColor?
  public let logId: DevicesDesignSystem.LogID?
  public var actions: [DevicesDesignSystem.AnyAction]
  public let accessibility: Swift.String?
  public init(icon: DevicesDesignSystem.ImageAddress, iconSize: DevicesDesignSystem.Icon.Size.Dimension, isEnabled: Swift.Bool, tintColor: DevicesDesignSystem.BackgroundColor? = nil, backgroundColor: DevicesDesignSystem.BackgroundColor? = nil, logId: DevicesDesignSystem.LogID? = nil, actions: [DevicesDesignSystem.AnyAction], accessibility: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.RoundButtonModel, b: DevicesDesignSystem.RoundButtonModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.RoundButtonModel.Error {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum ScaleMode : Swift.String, Swift.CaseIterable {
  case center
  case top
  case bottom
  case left
  case right
  case scaleToFill
  case scaleAspectFill
  case scaleAspectFit
  case topLeft
  case topRight
  case bottomLeft
  case bottomRight
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DevicesDesignSystem.ScaleMode]
  public typealias RawValue = Swift.String
  public static var allCases: [DevicesDesignSystem.ScaleMode] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct ScrollListAppearance {
  public let contentInsets: UIKit.UIEdgeInsets
  public let decelerationRate: UIKit.UIScrollView.DecelerationRate
  public let showsVerticalScrollIndicator: Swift.Bool
  public let showsHorizontalScrollIndicator: Swift.Bool
  public init(contentInsets: UIKit.UIEdgeInsets = UIEdgeInsets(horizontal: 16), decelerationRate: UIKit.UIScrollView.DecelerationRate = .normal, showsVerticalScrollIndicator: Swift.Bool = true, showsHorizontalScrollIndicator: Swift.Bool = true)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class ScrollListReusableView : UIKit.UICollectionReusableView {
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override final public func sizeThatFits(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @_Concurrency.MainActor(unsafe) final public func configure(with renderable: DevicesUI.ViewRenderable, context: DevicesUI.ViewContext)
  @objc deinit
}
@_Concurrency.MainActor(unsafe) public struct SegmentedText : SwiftUI.View {
  @_Concurrency.MainActor(unsafe) public init(segments: [DevicesDesignSystem.SegmentedText.Segment], onURLInteraction: ((Foundation.URL) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s19DevicesDesignSystem13SegmentedTextV4bodyQrvp", 0) __
}
extension DevicesDesignSystem.SegmentedText {
  public struct Segment : Swift.Hashable {
    public init(text: DevicesUI.StringContent, color: DevicesDesignSystem.TypeColor, typeface: DevicesDesignSystem.Typeface, extraAttributes: [Foundation.NSAttributedString.Key : Any]? = nil)
    public static func == (lhs: DevicesDesignSystem.SegmentedText.Segment, rhs: DevicesDesignSystem.SegmentedText.Segment) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public enum SelectType : Swift.String {
  case tap
  case swipe
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct SeparatorModel : DevicesUI.NativeViewRenderable {
  public let color: UIKit.UIColor
  public init(color: UIKit.UIColor)
  public func renderNativeView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.NativeView
}
extension DevicesDesignSystem.ShareScreenConfig {
  public enum ShareItem {
    case string(Swift.String)
    case url(Foundation.URL)
    case image(UIKit.UIImage)
    case custom(UIKit.UIActivityItemSource)
    public var value: Any {
      get
    }
  }
}
extension DevicesDesignSystem.ShareScreenConfig {
  public enum Destination {
    case postToWeibo
    case print
    case assignToContact
    case saveToCameraRoll
    case addToReadingList
    case postToFlickr
    case postToVimeo
    case postToTencentWeibo
    case postToFacebook
    public var asActivityType: UIKit.UIActivity.ActivityType {
      get
    }
    public static func == (a: DevicesDesignSystem.ShareScreenConfig.Destination, b: DevicesDesignSystem.ShareScreenConfig.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public struct ShareScreenConfig {
  public let items: [DevicesDesignSystem.ShareScreenConfig.ShareItem]
  public let excludedDestinations: [DevicesDesignSystem.ShareScreenConfig.Destination]
  public let onDismiss: (_ parameters: DevicesDesignSystem.CloseShareScreenParameters) -> Swift.Void
  public init(items: [DevicesDesignSystem.ShareScreenConfig.ShareItem], excludedDestinations: [DevicesDesignSystem.ShareScreenConfig.Destination], onDismiss: @escaping (_ parameters: DevicesDesignSystem.CloseShareScreenParameters) -> Swift.Void)
}
final public class ShareScreenCoordinatorMock : DevicesCore.ModalScreen {
  final public var viewController: UIKit.UIViewController {
    get
  }
  public init(shareScreen: DevicesCore.ModalScreen & DevicesDesignSystem.ActivityItemsContainer = ShareScreenMock(), config: DevicesDesignSystem.ShareScreenConfig = ShareScreenConfig(
				items: [.string("yo"), .url("https://ya.ru")],
				excludedDestinations: [],
				onDismiss: { _ in }
			))
  final public func onDidDismiss()
  @objc deinit
}
public typealias ShareScreenFactory = DevicesCore.Factory<DevicesDesignSystem.ShareScreenConfig, DevicesCore.ModalScreen>
extension DevicesCore.Factory where Arg == DevicesDesignSystem.ShareScreenConfig, Item == DevicesCore.ModalScreen {
  public init()
}
final public class ShareScreenMock : DevicesCore.ModalScreen, DevicesDesignSystem.ActivityItemsContainer {
  public enum Input {
    case setCompletionWithItemsHandler((DevicesDesignSystem.CloseShareScreenParameters) -> Swift.Void)
    case setExcludedActivityTypes
    case onDidDismiss
  }
  final public var inputs: [DevicesDesignSystem.ShareScreenMock.Input]
  public init()
  final public let parameters: DevicesDesignSystem.CloseShareScreenParameters
  final public var viewController: UIKit.UIViewController
  final public func setCompletionWithItemsHandler(_ handler: @escaping (DevicesDesignSystem.CloseShareScreenParameters) -> Swift.Void)
  final public func setExcludedActivityTypes(_: [DevicesDesignSystem.ShareScreenConfig.Destination])
  final public func onDidDismiss()
  final public func mockCompletionWithItemsHandler()
  @objc deinit
}
extension DevicesDesignSystem.ShareScreenMock.Input : Swift.Equatable {
  public static func == (lhs: DevicesDesignSystem.ShareScreenMock.Input, rhs: DevicesDesignSystem.ShareScreenMock.Input) -> Swift.Bool
}
public struct SheetModel {
  public struct StripModel {
    public let color: DevicesDesignSystem.ColorProtocol
    public let width: CoreFoundation.CGFloat
    public init(color: DevicesDesignSystem.ColorProtocol = BackgroundColor.deprecatedPrimary, width: CoreFoundation.CGFloat = 46)
  }
  public let stripStack: DevicesUI.ViewRenderable?
  public let content: DevicesUI.ViewRenderable
  public let background: DevicesUI.ViewRenderable?
  public let cornerRadius: CoreFoundation.CGFloat
  public let insetContentOnCornerRadius: Swift.Bool
  public init(content: DevicesUI.ViewRenderable, background: DevicesUI.ViewRenderable?, borderLine: DevicesDesignSystem.SheetModel.StripModel?, cornerRadius: CoreFoundation.CGFloat, insetContentOnCornerRadius: Swift.Bool)
  public init(content: DevicesUI.ViewRenderable, background: DevicesUI.ViewRenderable?, hasBorderLine: Swift.Bool, cornerRadius: CoreFoundation.CGFloat, insetContentOnCornerRadius: Swift.Bool = true)
}
public struct SheetScreen : DevicesCore.StackScreen {
  public var viewController: UIKit.UIViewController {
    get
  }
  public let sizeRestriction: DevicesCore.StackScreenSizeRestriction
  public let flags: DevicesCore.Property<DevicesCore.StackScreenFlags>
  public init(content: DevicesDesignSystem.SheetViewController, sizeRestriction: DevicesCore.StackScreenSizeRestriction = .none, flags: DevicesCore.Property<DevicesCore.StackScreenFlags> = .constant(StackScreenFlags()))
  public init(model: DevicesDesignSystem.SheetModel, context: DevicesUI.ViewContext, onFirstDidDisappear: (() -> Swift.Void)? = nil, ignoreSafeArea: Swift.Bool = false, clipsToBounds: Swift.Bool = true, coordinator: DevicesDesignSystem.SheetScreenCoordinator? = nil, sizeRestriction: DevicesCore.StackScreenSizeRestriction = .none, flags: DevicesCore.Property<DevicesCore.StackScreenFlags> = .constant(StackScreenFlags()))
  public func sizeThatFits(_ size: CoreFoundation.CGSize, safeAreaInsets: UIKit.UIEdgeInsets) -> CoreFoundation.CGSize
}
public protocol SheetScreenCoordinator {
  func viewDidLoad()
  func viewWillAppear(_ animated: Swift.Bool)
  func viewDidAppear(_ animated: Swift.Bool)
  func viewWillDisappear(_ animated: Swift.Bool)
  func viewDidDisappear(_ animated: Swift.Bool)
  func viewWillLayoutSubviews()
}
extension DevicesDesignSystem.SheetScreenCoordinator {
  public func viewDidLoad()
  public func viewWillAppear(_: Swift.Bool)
  public func viewDidAppear(_: Swift.Bool)
  public func viewWillDisappear(_: Swift.Bool)
  public func viewDidDisappear(_: Swift.Bool)
  public func viewWillLayoutSubviews()
}
@objc @_Concurrency.MainActor(unsafe) final public class SheetViewController : UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public init(model: DevicesDesignSystem.SheetModel, context: DevicesUI.ViewContext, onFirstDidDisappear: (() -> Swift.Void)? = nil, ignoreSafeArea: Swift.Bool = false, clipsToBounds: Swift.Bool = true, coordinator: DevicesDesignSystem.SheetScreenCoordinator? = nil)
  @available(*, unavailable)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder _: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override final public func loadView()
  @_Concurrency.MainActor(unsafe) @objc override final public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override final public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override final public func viewDidDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override final public func viewWillLayoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override final public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override final public func viewWillDisappear(_ animated: Swift.Bool)
  @objc deinit
}
public enum ShimmerItemRenderType {
  case shimmerPart
  case visiblePart
  public static func == (a: DevicesDesignSystem.ShimmerItemRenderType, b: DevicesDesignSystem.ShimmerItemRenderType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.ShimmerItemRenderType {
  public var isVisiblePart: Swift.Bool {
    get
  }
}
public protocol ShimmerMaskRenderable {
  func renderShimmerMask(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesDesignSystem.ShimmerMaskView
}
public protocol ShimmerMaskView : DevicesUI.View {
  var shimmerParts: [UIKit.UIView] { get }
}
extension DevicesUI.NativeViewRenderable {
  @inlinable public func shimmerPart() -> DevicesUI.NativeViewRenderable {
		ConcreteViewModifier(label: "shimmerPart", subject: self) { view, _ in
			view.backgroundColor = .white
			view.layer.cornerRadius = 12
			view.layer.masksToBounds = true
		}
	}
}
extension DevicesDesignSystem.ShimmerModel : DevicesUI.NativeViewRenderable {
  public func renderNativeView(context: DevicesUI.ViewContext, reusing _: DevicesUI.View?) -> DevicesUI.NativeView
}
public struct ShimmerModel {
  public let mask: DevicesDesignSystem.ShimmerMaskRenderable
  public init(mask: DevicesDesignSystem.ShimmerMaskRenderable)
}
extension DevicesDesignSystem.ShimmerMaskRenderable {
  @inlinable public func shimmer() -> DevicesDesignSystem.ShimmerModel {
		ShimmerModel(mask: self)
	}
}
extension DevicesUI.ViewRenderable {
  @inlinable public func shimmerNativeChildrenMask() -> DevicesDesignSystem.ShimmerMaskRenderable {
		ShimmerNativeChildrenMask(subject: self)
	}
}
public struct ShimmerNativeChildrenMask : DevicesDesignSystem.ShimmerMaskRenderable {
  public init(subject: DevicesUI.ViewRenderable)
  public func renderShimmerMask(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesDesignSystem.ShimmerMaskView
}
extension DevicesDesignSystem.SimpleLeftModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.SimpleLeftModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct SimpleLeftModel : Swift.Hashable {
  public let icon: DevicesDesignSystem.IconModel?
  public let iconVerticalGravity: DevicesUI.VerticalGravity
  public let textsVerticalGravity: DevicesUI.VerticalGravity
  public let texts: DevicesDesignSystem.VerticalTextsModel?
  public let accessibility: Swift.String?
  public init(icon: DevicesDesignSystem.IconModel?, iconVerticalGravity: DevicesUI.VerticalGravity?, textsVerticalGravity: DevicesUI.VerticalGravity?, texts: DevicesDesignSystem.VerticalTextsModel?, accessibility: Swift.String? = nil)
  public init(icon: DevicesDesignSystem.IconModel, texts: DevicesDesignSystem.VerticalTextsModel, iconVerticalGravity: DevicesUI.VerticalGravity? = nil, textsVerticalGravity: DevicesUI.VerticalGravity? = nil, accessibility: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.SimpleLeftModel, b: DevicesDesignSystem.SimpleLeftModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.SimpleListCardItemModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct SimpleListCardItemModel : Swift.Hashable {
  public init(title: Swift.String, body: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.SimpleListCardItemModel, b: DevicesDesignSystem.SimpleListCardItemModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.SimpleListCardModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.SimpleListCardModel : DevicesUI.ViewRenderable, DevicesDesignSystem.CardBase {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct SimpleListCardModel : Swift.Hashable {
  public init(header: Swift.String, items: [DevicesDesignSystem.SimpleListCardItemModel], footer: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.SimpleListCardModel, b: DevicesDesignSystem.SimpleListCardModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.SingleContentCellModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.SingleContentCellModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct SingleContentCellModel<Content> : Swift.Hashable where Content : DevicesCore.Deserializable, Content : DevicesUI.ViewRenderable, Content : Swift.Hashable {
  public let content: Content
  public let paddings: DevicesDesignSystem.Paddings
  public init(content: Content, paddings: DevicesDesignSystem.Paddings?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.SingleContentCellModel<Content>, b: DevicesDesignSystem.SingleContentCellModel<Content>) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol SizeProvider {
  func value(for iconSize: DevicesDesignSystem.Icon.Size) -> CoreFoundation.CGSize
  func value(for dimension: DevicesDesignSystem.Icon.Size.Dimension) -> CoreFoundation.CGFloat
  func value(for contentWidth: DevicesDesignSystem.GridContentWidth, canvasWidth: CoreFoundation.CGFloat) -> DevicesDesignSystem.LayoutGridMetrics
}
public enum SmartAppColor : Swift.String {
  case smartAppBackground
  case smartAppStripView
  case smartAppDimView
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension DevicesDesignSystem.SpacerModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct SpacerModel : Swift.Hashable {
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.SpacerModel, b: DevicesDesignSystem.SpacerModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.SpacerModel : DevicesCore.Deserializable {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public init(deserializer _: DevicesCore.Deserializer) throws
}
public enum SpeechBubbleColor : Swift.String {
  case sent
  case received
  @available(*, deprecated, message: "Will be deleted")
  case contrast
  @available(*, deprecated, message: "Will be deleted")
  case oldSent
  @available(*, deprecated, message: "Will be deleted")
  case oldReceived
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension DevicesDesignSystem.SpeechBubbleColor : DevicesDesignSystem.ColorProtocol {
  public func value(characterSemantic: DevicesDesignSystem.CharacterSemantic, userInterfaceStyle: DevicesDesignSystem.UserInterfaceStyle) -> UIKit.UIColor
}
extension DevicesDesignSystem.HorizontalStackCellContent : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
extension DevicesCore.StackScreen {
  public func asStyledPresentationScreen(with mode: DevicesCore.StackPresentationMode) -> DevicesCore.StackScreen
}
public struct StringValidator {
  public typealias Failure = DevicesCore.Tagged<DevicesDesignSystem.StringValidator.FailureTag, Swift.String>
  public enum FailureTag {
  }
  public enum Validity : Swift.Equatable {
    case valid
    case failure(failure: DevicesDesignSystem.StringValidator.Failure, description: DevicesUI.StringContent)
    public var isValid: Swift.Bool {
      get
    }
    public var isCorrectOrEmpty: Swift.Bool {
      get
    }
    public static func == (lhs: DevicesDesignSystem.StringValidator.Validity, rhs: DevicesDesignSystem.StringValidator.Validity) -> Swift.Bool
  }
  public init(_ predicate: @escaping (Swift.String) -> DevicesDesignSystem.StringValidator.Validity)
  public func validate(_ input: Swift.String) -> DevicesDesignSystem.StringValidator.Validity
}
extension DevicesCore.Tagged where Tag == DevicesDesignSystem.StringValidator.FailureTag, T == Swift.String {
  public static let empty: DevicesCore.Tagged<DevicesDesignSystem.StringValidator.FailureTag, Swift.String>
  public static let nonMatching: DevicesCore.Tagged<DevicesDesignSystem.StringValidator.FailureTag, Swift.String>
}
extension DevicesDesignSystem.StringValidator {
  @inlinable public func isValid(_ input: Swift.String) -> Swift.Bool {
		validate(input) == .valid
	}
}
extension DevicesDesignSystem.StringValidator {
  public static func nonEmpty(description: DevicesUI.StringContent) -> DevicesDesignSystem.StringValidator
}
extension DevicesDesignSystem.StringValidator {
  public static func codeSMSValidator(_ digsCount: Swift.Int = 5) -> DevicesDesignSystem.StringValidator
}
public enum SurfaceColor : Swift.String {
  case card
  case transparentPrimary
  case transparentSecondary
  case transparentTertiary
  case solidPrimary
  case solidSecondary
  case solidTertiary
  case clear
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension DevicesDesignSystem.SurfaceColor : DevicesDesignSystem.ColorProtocol {
  public func value(characterSemantic: DevicesDesignSystem.CharacterSemantic, userInterfaceStyle: DevicesDesignSystem.UserInterfaceStyle) -> UIKit.UIColor
}
extension SwiftUI.View {
  public func plasmaButtonStyle(_ style: DevicesDesignSystem.PlasmaButtonStyleID) -> some SwiftUI.View
  
}
extension SwiftUI.Button where Label == DevicesDesignSystem.DesignText {
  public init(text: DevicesUI.StringContent, action: @escaping () -> Swift.Void)
}
extension SwiftUI.View {
  public func typecolor(_ typecolor: DevicesDesignSystem.TypeColor) -> some SwiftUI.View
  
  public func typeface(_ typeface: DevicesDesignSystem.Typeface) -> some SwiftUI.View
  
  public func plausibleKeyboardType(_ keyboardType: UIKit.UIKeyboardType) -> some SwiftUI.View
  
  public func hideAutocorrection(_ value: Swift.Bool) -> some SwiftUI.View
  
}
extension SwiftUI.View {
  public func background(_ color: DevicesDesignSystem.ColorProtocol) -> some SwiftUI.View
  
  public func foregroundColor(_ color: DevicesDesignSystem.TypeColor) -> some SwiftUI.View
  
  public func fill(_ color: DevicesDesignSystem.ColorProtocol) -> some SwiftUI.View
  
  public func accentColor(_ color: DevicesDesignSystem.ColorProtocol) -> some SwiftUI.View
  
}
public enum SwipeType : Swift.String {
  case tap
  case swipe
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct SwitchModel {
  @DevicesCore.MutableProperty @_projectedValueProperty($isOn) public var isOn: Swift.Bool {
    get
    nonmutating set
    nonmutating _modify
  }
  public var $isOn: DevicesCore.MutableProperty<Swift.Bool> {
    get
  }
  public let onColor: DevicesDesignSystem.ColorProtocol
  public var isEnabled: Swift.Bool
  public init(isOn: DevicesCore.MutableProperty<Swift.Bool>, isEnabled: Swift.Bool = true, onColor: DevicesDesignSystem.ColorProtocol)
}
extension DevicesDesignSystem.SwitchModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public typealias TagCellModel = DevicesDesignSystem.SingleContentCellModel<DevicesDesignSystem.TagModel>
extension DevicesDesignSystem.TagModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
public struct TagModel : Swift.Hashable {
  public let text: DevicesDesignSystem.TextModel
  public let background: DevicesDesignSystem.BackgroundColor
  public let accessibility: Swift.String?
  public init(text: DevicesDesignSystem.TextModel, background: DevicesDesignSystem.BackgroundColor? = nil, accessibility: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.TagModel, b: DevicesDesignSystem.TagModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.TagModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
extension DevicesDesignSystem.TextAttributes : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
public struct TextAttributes : Swift.Equatable, Swift.Hashable {
  public let start: Swift.Int
  public let length: Swift.Int
  public let color: UIKit.UIColor?
  public init(start: Swift.Int, length: Swift.Int, color: UIKit.UIColor?)
  public var nsAttributes: [Foundation.NSAttributedString.Key : Any] {
    get
  }
  public var nsRange: Foundation.NSRange {
    get
  }
  public static func == (a: DevicesDesignSystem.TextAttributes, b: DevicesDesignSystem.TextAttributes) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.TextCellModel {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public struct Deserializable : DevicesCore.Deserializable, Swift.Equatable {
    public let model: DevicesDesignSystem.TextCellModel
    public init(model: DevicesDesignSystem.TextCellModel)
    public init(deserializer: DevicesCore.Deserializer) throws
    public static func == (a: DevicesDesignSystem.TextCellModel.Deserializable, b: DevicesDesignSystem.TextCellModel.Deserializable) -> Swift.Bool
  }
}
extension DevicesDesignSystem.TextCellModel {
  public static func sample(text: DevicesUI.StringContent = ExternalString(value: "Текст ячейки"), textColor: DevicesDesignSystem.TypeColor = .accent, paddings: DevicesDesignSystem.Paddings = Paddings(horizontal: .x2, vertical: .x2)) -> DevicesDesignSystem.TextCellModel
}
extension DevicesDesignSystem.TextCellModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct TextCellModel : Swift.Hashable {
  public let content: DevicesDesignSystem.TextModel
  public let divider: DevicesDesignSystem.DividerModel?
  public let paddings: DevicesDesignSystem.Paddings
  public let gravity: DevicesUI.HorizontalGravity
  public init(content: DevicesDesignSystem.TextModel, divider: DevicesDesignSystem.DividerModel? = nil, paddings: DevicesDesignSystem.Paddings? = nil, gravity: DevicesUI.HorizontalGravity? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.TextCellModel, b: DevicesDesignSystem.TextCellModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.TextModel : DevicesCore.Deserializable {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public init(deserializer: DevicesCore.Deserializer) throws
}
public struct TextModel {
  public let text: DevicesUI.StringContent
  public let typeface: DevicesDesignSystem.Typeface
  public let textColor: DevicesDesignSystem.ColorProtocol
  public let textAttributes: [DevicesDesignSystem.TextAttributes]?
  public let margins: DevicesDesignSystem.Margins
  public let alignment: DevicesUI.TextAlignment
  public let maxLines: Swift.Int
  public let minimumScaleFactor: CoreFoundation.CGFloat
  public let useHyphen: Swift.Bool
  public let gradient: DevicesUI.Gradient?
  public let actions: [DevicesDesignSystem.AnyAction]?
  public let logId: DevicesDesignSystem.LogID?
  public let isAccessibilityElement: Swift.Bool
  public let accessibility: Swift.String?
  public var adjustsFontSizeToFitWidth: Swift.Bool {
    get
  }
  public enum Error : Foundation.LocalizedError {
    case emptyText
    public static func == (a: DevicesDesignSystem.TextModel.Error, b: DevicesDesignSystem.TextModel.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(text: DevicesUI.StringContent, typeface: DevicesDesignSystem.Typeface, unifiedTextColor: DevicesDesignSystem.ColorProtocol, textAttributes: [DevicesDesignSystem.TextAttributes]? = nil, margins: DevicesDesignSystem.Margins? = nil, alignment: DevicesUI.TextAlignment? = nil, maxLines: Swift.Int? = nil, minimumScaleFactor: CoreFoundation.CGFloat = 0, useHyphen: Swift.Bool? = nil, gradient: DevicesUI.Gradient? = nil, actions: [DevicesDesignSystem.AnyAction]? = nil, logId: DevicesDesignSystem.LogID? = nil, isAccessibilityElement: Swift.Bool = true, accessibility: Swift.String? = nil)
  public init(text: DevicesUI.StringContent, typeface: DevicesDesignSystem.Typeface, textColor: DevicesDesignSystem.TypeColor, textAttributes: [DevicesDesignSystem.TextAttributes]? = nil, margins: DevicesDesignSystem.Margins? = nil, alignment: DevicesUI.TextAlignment? = nil, maxLines: Swift.Int? = nil, minimumScaleFactor: CoreFoundation.CGFloat = 0, useHyphen: Swift.Bool? = nil, gradient: DevicesUI.Gradient? = nil, actions: [DevicesDesignSystem.AnyAction]? = nil, logId: DevicesDesignSystem.LogID? = nil, isAccessibilityElement: Swift.Bool = true, accessibility: Swift.String? = nil)
}
extension DevicesDesignSystem.TextModel.Error {
  public var errorDescription: Swift.String? {
    get
  }
}
extension DevicesDesignSystem.TextModel : DevicesUI.NativeViewRenderable {
  public func renderNativeView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.NativeView
}
extension DevicesDesignSystem.TextModel : Swift.Equatable {
  public static func == (lhs: DevicesDesignSystem.TextModel, rhs: DevicesDesignSystem.TextModel) -> Swift.Bool
}
extension DevicesDesignSystem.TextModel : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.TextViewStyle : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
public struct TextViewStyle : Swift.Equatable, Swift.Hashable {
  public let typeface: DevicesDesignSystem.Typeface
  public let textColor: DevicesDesignSystem.TypeColor
  public let maxLines: Swift.Int
  public let alignment: DevicesUI.TextAlignment
  public let useHyphen: Swift.Bool
  public init(typeface: DevicesDesignSystem.Typeface, textColor: DevicesDesignSystem.TypeColor, maxLines: Swift.Int?, alignment: DevicesUI.TextAlignment?, useHyphen: Swift.Bool?)
  public static func == (a: DevicesDesignSystem.TextViewStyle, b: DevicesDesignSystem.TextViewStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesCore.AnalyticsEvent {
  public func asToast() -> DevicesDesignSystem.Toast
}
public struct Toast {
  public typealias TapAction = () -> Swift.Void
  public enum TapBehaviour {
    case hide
    case action(DevicesDesignSystem.Toast.TapAction)
  }
  public enum Gravity {
    case top
    case center
    case bottom
    public static func == (a: DevicesDesignSystem.Toast.Gravity, b: DevicesDesignSystem.Toast.Gravity) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let duration: Foundation.TimeInterval
  public let content: DevicesUI.ViewRenderable
  public let gravity: DevicesDesignSystem.Toast.Gravity
  public let tapBehaviour: DevicesDesignSystem.Toast.TapBehaviour?
  public init(duration: Foundation.TimeInterval, content: DevicesUI.ViewRenderable, gravity: DevicesDesignSystem.Toast.Gravity, tapBehaviour: DevicesDesignSystem.Toast.TapBehaviour? = nil)
  public static func message(_ message: DevicesUI.StringContent, duration: Foundation.TimeInterval = 5, gravity: DevicesDesignSystem.Toast.Gravity = .top, maxLines: Swift.Int = 3) -> DevicesDesignSystem.Toast
  public static func alert(text: DevicesUI.StringContent, duration: Foundation.TimeInterval = 20, iconImage: DevicesCore.ImageID? = nil, actionTitle: DevicesUI.StringContent, gravity: DevicesDesignSystem.Toast.Gravity = .bottom, tapBehaviour: DevicesDesignSystem.Toast.TapBehaviour? = nil, action: (() -> Swift.Void)?) -> DevicesDesignSystem.Toast
}
public protocol ToastRouter : AnyObject {
  func showToast(_ toast: DevicesDesignSystem.Toast)
}
final public class ToastRouterProxy : DevicesDesignSystem.ToastRouter {
  public init()
  final public func set(_ subject: DevicesDesignSystem.ToastRouter)
  final public func showToast(_ toast: DevicesDesignSystem.Toast)
  @objc deinit
}
final public class ToastWindowPerformer : DevicesDesignSystem.ToastRouter {
  public init(frame: CoreFoundation.CGRect, context: DevicesUI.ViewContext)
  final public func showToast(_ toast: DevicesDesignSystem.Toast)
  @objc deinit
}
@objc final public class TransitionDriver : ObjectiveC.NSObject {
  public enum Direction {
    case present
    case dismiss
    public static func == (a: DevicesDesignSystem.TransitionDriver.Direction, b: DevicesDesignSystem.TransitionDriver.Direction) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum WorkingArea {
    case allContent
    case header(height: CoreFoundation.CGFloat)
  }
  final public var isRunning: Swift.Bool {
    get
  }
  final public var direction: DevicesDesignSystem.TransitionDriver.Direction
  public init(linkedTo view: UIKit.UIView, delegate: DevicesDesignSystem.TransitionDriverDelegate, maxTranslation: CoreFoundation.CGFloat, workingArea: DevicesDesignSystem.TransitionDriver.WorkingArea = .allContent, assertionCaller: DevicesCore.AssertionCaller)
  final public func cancel()
  @objc deinit
}
extension DevicesDesignSystem.TransitionDriver : UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizerShouldBegin(_: UIKit.UIGestureRecognizer) -> Swift.Bool
}
public protocol TransitionDriverDelegate : AnyObject {
  var percentComplete: CoreFoundation.CGFloat { get }
  func start()
  func cancel()
  func finish()
  func update(_ percent: CoreFoundation.CGFloat)
}
public enum TypeColor : Swift.String, Swift.Decodable {
  case `default`
  case secondary
  case tertiary
  case paragraph
  case inverse
  case accent
  case brand
  case link
  case success
  case warning
  case critical
  case globalWhite
  case globalWhiteSecondary
  case globalWhiteTertiary
  case globalBlack
  case globalBlackSecondary
  case globalBlackTertiary
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension DevicesDesignSystem.TypeColor : DevicesDesignSystem.ColorProtocol {
  public func value(characterSemantic: DevicesDesignSystem.CharacterSemantic, userInterfaceStyle: DevicesDesignSystem.UserInterfaceStyle) -> UIKit.UIColor
}
public typealias Typeface = DevicesCore.Tagged<DevicesDesignSystem.TypefaceTag, Swift.String>
public enum TypefaceTag {
}
extension DevicesCore.Tagged where Tag == DevicesDesignSystem.TypefaceTag, T == Swift.String {
  public static let display1: DevicesDesignSystem.Typeface
  public static let display2: DevicesDesignSystem.Typeface
  public static let display3: DevicesDesignSystem.Typeface
  public static let headline: DevicesDesignSystem.Typeface
  public static let headline1: DevicesDesignSystem.Typeface
  public static let headline2: DevicesDesignSystem.Typeface
  public static let headline3: DevicesDesignSystem.Typeface
  public static let headline4: DevicesDesignSystem.Typeface
  public static let headline5: DevicesDesignSystem.Typeface
  public static let headline6: DevicesDesignSystem.Typeface
  public static let title1: DevicesDesignSystem.Typeface
  public static let title2: DevicesDesignSystem.Typeface
  public static let body1: DevicesDesignSystem.Typeface
  public static let body2: DevicesDesignSystem.Typeface
  public static let body3: DevicesDesignSystem.Typeface
  public static let body4: DevicesDesignSystem.Typeface
  public static let bodyAi: DevicesDesignSystem.Typeface
  public static let text1: DevicesDesignSystem.Typeface
  public static let paragraphText1: DevicesDesignSystem.Typeface
  public static let paragraphText2: DevicesDesignSystem.Typeface
  public static let footnote1: DevicesDesignSystem.Typeface
  public static let footnote2: DevicesDesignSystem.Typeface
  public static let footnote3: DevicesDesignSystem.Typeface
  public static let button1: DevicesDesignSystem.Typeface
  public static let button2: DevicesDesignSystem.Typeface
  public static let caption: DevicesDesignSystem.Typeface
  public static let underline: DevicesDesignSystem.Typeface
  public static let dsCases: [DevicesDesignSystem.Typeface]
}
final public class TypographyDesignProvider : DevicesDesignSystem.TypographyProvider {
  public init(fontProvider: DevicesDesignSystem.FontProvider, assertionCaller: DevicesCore.AssertionCaller)
  final public func makeGlyphTypo(for typeface: DevicesDesignSystem.Typeface) -> DevicesDesignSystem.GlyphTypo
  @objc deinit
}
extension DevicesDesignSystem.TypographyDesignProvider {
  convenience public init(assertionCaller: DevicesCore.AssertionCaller)
}
public protocol TypographyProvider {
  func makeGlyphTypo(for typeface: DevicesDesignSystem.Typeface) -> DevicesDesignSystem.GlyphTypo
}
final public class TypographySystemProvider : DevicesDesignSystem.TypographyProvider {
  public init(fontProvider: DevicesDesignSystem.FontProvider, assertionCaller: DevicesCore.AssertionCaller)
  final public func makeGlyphTypo(for typeface: DevicesDesignSystem.Typeface) -> DevicesDesignSystem.GlyphTypo
  @objc deinit
}
extension DevicesDesignSystem.TypographySystemProvider {
  convenience public init(assertionCaller: DevicesCore.AssertionCaller)
}
extension UIKit.UIColor : DevicesDesignSystem.ColorProtocol {
  public func value(characterSemantic _: DevicesDesignSystem.CharacterSemantic, userInterfaceStyle _: DevicesDesignSystem.UserInterfaceStyle) -> UIKit.UIColor
}
extension UIKit.UIColor {
  public enum HexParsingError : Foundation.LocalizedError, Swift.Equatable {
    case invalidHexColor
    public var errorDescription: Swift.String? {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: UIKit.UIColor.HexParsingError, b: UIKit.UIColor.HexParsingError) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  convenience public init(hexString: Swift.String) throws
  public func toHex() -> Swift.String
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public func setBackAction(context: DevicesUI.ViewContext, imageID: DevicesCore.ImageID = DesignSystemLocalImageID.color(.back), action: @escaping () -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func setRightButtonAction(context: DevicesUI.ViewContext, imageID: DevicesCore.ImageID, action: @escaping () -> Swift.Void)
  @discardableResult
  @_Concurrency.MainActor(unsafe) public func setRightButtonAction(context: DevicesUI.ViewContext, titleID: DevicesCore.StringID, tintColor: DevicesDesignSystem.TypeColor = .default, action: @escaping () -> Swift.Void) -> UIKit.UIBarButtonItem
  @_Concurrency.MainActor(unsafe) public func setTitle(_ title: DevicesUI.StringContent, context: DevicesUI.ViewContext, maxLines: Swift.Int = 1, aligment: DevicesUI.TextAlignment? = nil, applyWorkaroundForCenterAlignment: Swift.Bool = false)
}
public enum UserInterfaceStyle : Swift.String, Swift.Equatable, Swift.CaseIterable {
  case light
  case dark
  public mutating func switchToNext()
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DevicesDesignSystem.UserInterfaceStyle]
  public typealias RawValue = Swift.String
  public static var allCases: [DevicesDesignSystem.UserInterfaceStyle] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension UIKit.UIUserInterfaceStyle {
  public var uiStyle: DevicesDesignSystem.UserInterfaceStyle {
    get
  }
}
extension DevicesDesignSystem.VStackShimmer : DevicesDesignSystem.ShimmerMaskRenderable, DevicesUI.NativeViewRenderable {
  public func renderShimmerMask(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesDesignSystem.ShimmerMaskView
  public func renderNativeView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.NativeView
}
public struct VStackShimmer {
  public init(items: [DevicesDesignSystem.VStackShimmerItem], spacing: CoreFoundation.CGFloat = 0)
}
public struct VStackShimmerItem {
  public let content: DevicesUI.ViewRenderable
  public let cornerRadius: CoreFoundation.CGFloat
  public let margins: UIKit.UIEdgeInsets
  public let gravity: DevicesUI.HorizontalGravity
  public let greediness: DevicesUI.Greediness
  public let renderType: DevicesDesignSystem.ShimmerItemRenderType
  public init(content: DevicesUI.ViewRenderable, cornerRadius: CoreFoundation.CGFloat, margins: UIKit.UIEdgeInsets = .zero, gravity: DevicesUI.HorizontalGravity, greediness: DevicesUI.Greediness = .intrinsic, renderType: DevicesDesignSystem.ShimmerItemRenderType? = nil)
  @inlinable public init(width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat, cornerRadius: CoreFoundation.CGFloat, margins: UIKit.UIEdgeInsets = .zero, gravity: DevicesUI.HorizontalGravity, greediness: DevicesUI.Greediness = .intrinsic, renderType: DevicesDesignSystem.ShimmerItemRenderType? = nil) {
		self.init(
			content: Spacer(width: width, height: height),
			cornerRadius: cornerRadius,
			margins: margins,
			gravity: gravity,
			greediness: greediness,
			renderType: renderType
		)
	}
}
extension DevicesUI.ViewRenderable {
  @inlinable public func asVStackShimmerItem(cornerRadius: CoreFoundation.CGFloat, margins: UIKit.UIEdgeInsets = .zero, gravity: DevicesUI.HorizontalGravity = .center, greediness: DevicesUI.Greediness = .intrinsic, renderType: DevicesDesignSystem.ShimmerItemRenderType? = nil) -> DevicesDesignSystem.VStackShimmerItem {
		VStackShimmerItem(
			content: self,
			cornerRadius: cornerRadius,
			margins: margins,
			gravity: gravity,
			greediness: greediness,
			renderType: renderType
		)
	}
}
public struct VerticalIconTextModel : Swift.Hashable {
  public let icon: DevicesDesignSystem.IconModel?
  public let texts: DevicesDesignSystem.VerticalTextsModel?
  public let actions: [DevicesDesignSystem.AnyAction]?
  public let logId: DevicesDesignSystem.LogID?
  public let accessibility: Swift.String?
  public init(icon: DevicesDesignSystem.IconModel?, texts: DevicesDesignSystem.VerticalTextsModel?, actions: [DevicesDesignSystem.AnyAction]?, logId: DevicesDesignSystem.LogID?, accessibility: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.VerticalIconTextModel, b: DevicesDesignSystem.VerticalIconTextModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.VerticalIconTextModel : DevicesCore.Deserializable {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.VerticalIconTextModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
extension DevicesDesignSystem.VerticalTextsModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.VerticalTextsModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct VerticalTextsModel : Swift.Hashable {
  public let title: DevicesDesignSystem.TextModel?
  public let subtitle: DevicesDesignSystem.TextModel?
  public let caption: DevicesDesignSystem.TextModel?
  public let margins: DevicesDesignSystem.Margins
  public let accessibility: Swift.String?
  public init(title: DevicesDesignSystem.TextModel?, subtitle: DevicesDesignSystem.TextModel?, caption: DevicesDesignSystem.TextModel?, margins: DevicesDesignSystem.Margins?, accessibility: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.VerticalTextsModel, b: DevicesDesignSystem.VerticalTextsModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension SwiftUI.View {
  public func hideKeyboard()
}
extension DevicesCore.KeyValueContext where Tag == DevicesUI.ViewContextTag {
  public var applicationState: DevicesCore.Property<DevicesCore.ApplicationState> {
    get
  }
  public var stringProvider: DevicesCore.StringProvider {
    get
  }
  public var imageProvider: DevicesCore.ImageProvider {
    get
  }
  public var remoteImageProvider: DevicesCore.RemoteImageProvider {
    get
  }
  public var brandbook: DevicesDesignSystem.Brandbook {
    get
  }
  public var areAnimationsEnabled: Swift.Bool {
    get
  }
  public var accessibilityEnabled: Swift.Bool {
    get
  }
  public var interfaceOrientation: DevicesCore.Property<UIKit.UIInterfaceOrientation> {
    get
  }
  public var actionPerformer: DevicesDesignSystem.ActionPerformer {
    get
    set
  }
  public func addingDesignSystem(lottieImageFactory: DevicesDesignSystem.LottieImageFactory?, brandbook: DevicesDesignSystem.Brandbook, actionPerformer: DevicesDesignSystem.ActionPerformer, areAnimationsEnabled: Swift.Bool, applicationState: DevicesCore.Property<DevicesCore.ApplicationState>, accessibilityEnabled: Swift.Bool = false) -> DevicesCore.KeyValueContext<Tag>
}
extension DevicesCore.KeyValueContextKey where Tag == DevicesUI.ViewContextTag {
  public static var applicationState: DevicesUI.ViewContextKey<DevicesCore.Property<DevicesCore.ApplicationState>> {
    get
  }
  public static var actionPerformer: DevicesUI.ViewContextKey<DevicesDesignSystem.ActionPerformer> {
    get
  }
  public static var lottieImageFactory: DevicesUI.ViewContextKey<DevicesDesignSystem.LottieImageFactory?> {
    get
  }
  public static var brandbook: DevicesUI.ViewContextKey<DevicesDesignSystem.Brandbook> {
    get
  }
  public static var areAnimationsEnabled: DevicesUI.ViewContextKey<Swift.Bool> {
    get
  }
  public static var contactHashProvider: DevicesUI.ViewContextKey<DevicesDesignSystem.ContactHashProvider?> {
    get
  }
  public static var accessibilityEnabled: DevicesUI.ViewContextKey<Swift.Bool> {
    get
  }
  public static var interfaceOrientation: DevicesUI.ViewContextKey<DevicesCore.Property<UIKit.UIInterfaceOrientation>> {
    get
  }
  public static var operatorCardChatInfo: DevicesUI.ViewContextKey<DevicesCore.Property<DevicesDesignSystem.OperatorCardChatInfo?>?> {
    get
  }
}
extension DevicesUI.ViewRenderable {
  @inlinable public func asButton(style: DevicesUI.ButtonStyle = PlainButtonStyle(), actions: [DevicesDesignSystem.AnyAction], sender: DevicesDesignSystem.ActionSender = .unspecified, accessibilityLabel: DevicesUI.StringContent? = nil) -> DevicesUI.ViewRenderable {
		transform(label: "button") { subject, context, view in
			subject
				.asButton(style: style, accessibilityLabel: accessibilityLabel) {
					context[.actionPerformer].perform(
						actions,
						sender: sender
					)
				}
				.renderNativeView(context: context, reusing: view)
		}
	}
  @inlinable public func asButton(style: DevicesUI.ButtonStyle = PlainButtonStyle(), actions: [DevicesDesignSystem.AnyAction]?, sender: DevicesDesignSystem.ActionSender = .unspecified, accessibilityLabel: DevicesUI.StringContent? = nil) -> DevicesUI.ViewRenderable {
		withWrapped(actions) { _, actions in
			asButton(
				style: style,
				actions: actions,
				sender: sender,
				accessibilityLabel: accessibilityLabel
			)
		}
	}
}
extension DevicesUI.ViewRenderable {
  @inlinable public func inset(by insets: DevicesDesignSystem.Insets) -> DevicesUI.ViewRenderable {
		transform(label: "inset") { subject, context, view in
			let insets = context[.brandbook].value(for: insets)
			return subject.inset(by: insets).renderView(context: context, reusing: view)
		}
	}
  @inlinable public func insetBy(dx: DevicesDesignSystem.Dimensions = .x0, dy: DevicesDesignSystem.Dimensions = .x0) -> DevicesUI.ViewRenderable {
		inset(by: Margins(horizontal: dx, vertical: dy))
	}
  @inlinable public func insetBy(top: DevicesDesignSystem.Dimensions = .x0, bottom: DevicesDesignSystem.Dimensions = .x0, left: DevicesDesignSystem.Dimensions = .x0, right: DevicesDesignSystem.Dimensions = .x0) -> DevicesUI.ViewRenderable {
		inset(by: Insets(
			left: left,
			top: top,
			right: right,
			bottom: bottom
		))
	}
  @inlinable public func inset(eachSide inset: DevicesDesignSystem.Dimensions = .x0) -> DevicesUI.ViewRenderable {
		self.inset(by: Insets(
			left: inset,
			top: inset,
			right: inset,
			bottom: inset
		))
	}
  @inlinable public func resizeTo(_ size: DevicesDesignSystem.Icon.Size) -> DevicesUI.ViewRenderable {
		transform(label: "resize") { subject, context, view in
			let value = context[.brandbook].value(for: size)
			return subject
				.resizeTo(value)
				.renderView(context: context, reusing: view)
		}
	}
}
extension DevicesUI.ViewRenderable {
  public func brandbookUpdatable() -> DevicesUI.NativeViewRenderable
}
extension DevicesUI.ViewRenderable {
  public func resizeTo(_ contentSize: DevicesDesignSystem.ContentSize) -> DevicesUI.ViewRenderable
  public func resizeTo(_ contentHeight: DevicesDesignSystem.ContentHeight) -> DevicesUI.ViewRenderable
  public func resizeTo(contentWidth: DevicesDesignSystem.ContentWidth, contentHeight: DevicesDesignSystem.ContentHeight) -> DevicesUI.ViewRenderable
}
@available(iOS 13.0, *)
public struct ViewRenderableAdapter<Content> : DevicesUI.ViewRenderable where Content : SwiftUI.View {
  public init(_ swiftUIView: Content)
  public func renderView(context: DevicesUI.ViewContext, reusing _: DevicesUI.View?) -> DevicesUI.View
}
@available(iOS 13.0, *)
extension SwiftUI.View {
  public func adaptToSDUI() -> DevicesDesignSystem.ViewRenderableAdapter<Self>
}
@available(iOS 13.0, *)
extension SwiftUI.UIHostingController {
  @_Concurrency.MainActor(unsafe) convenience public init(rootView: Content, ignoreSafeArea: Swift.Bool)
}
extension DevicesDesignSystem.WeatherCellModel {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public struct Deserializable : DevicesCore.Deserializable, Swift.Equatable {
    public let model: DevicesDesignSystem.WeatherCellModel
    public init(model: DevicesDesignSystem.WeatherCellModel)
    public init(deserializer: DevicesCore.Deserializer) throws
    public static func == (a: DevicesDesignSystem.WeatherCellModel.Deserializable, b: DevicesDesignSystem.WeatherCellModel.Deserializable) -> Swift.Bool
  }
}
extension DevicesDesignSystem.WeatherCellModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct WeatherCellModel : Swift.Hashable {
  public enum Error : Foundation.LocalizedError, Swift.Hashable {
    case emptyContent
    public static func == (a: DevicesDesignSystem.WeatherCellModel.Error, b: DevicesDesignSystem.WeatherCellModel.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let content: [DevicesDesignSystem.WeatherModel]
  public let paddings: DevicesDesignSystem.Paddings
  public init(content: [DevicesDesignSystem.WeatherModel], paddings: DevicesDesignSystem.Paddings?) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.WeatherCellModel, b: DevicesDesignSystem.WeatherCellModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.WeatherCellModel.Error {
  public var errorDescription: Swift.String? {
    get
  }
}
extension DevicesDesignSystem.WeatherModel {
  public struct Deserializable : DevicesCore.Deserializable, Swift.Equatable {
    public let model: DevicesDesignSystem.WeatherModel
    public init(model: DevicesDesignSystem.WeatherModel)
    public init(deserializer: DevicesCore.Deserializer) throws
    public static func == (a: DevicesDesignSystem.WeatherModel.Deserializable, b: DevicesDesignSystem.WeatherModel.Deserializable) -> Swift.Bool
  }
}
public struct WeatherModel : Swift.Hashable {
  public let weekday: Swift.String
  public let date: Swift.String
  public let day: Swift.String
  public let night: Swift.String
  public let icon: DevicesDesignSystem.IconModel
  public let accessibility: Swift.String?
  public init(weekday: Swift.String, date: Swift.String, day: Swift.String, night: Swift.String, icon: DevicesDesignSystem.IconModel, accessibility: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesDesignSystem.WeatherModel, b: DevicesDesignSystem.WeatherModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.WidgetButtonModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.WidgetButtonModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct WidgetButtonModel : Swift.Equatable, DevicesDesignSystem.WidgetCard, DevicesDesignSystem.CardBase {
  public let elementType: DevicesDesignSystem.ElementType
  public enum Size : Swift.String, Swift.Decodable {
    case small
    case medium
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Error : Foundation.LocalizedError {
    case actionsAreEmpty
    public static func == (a: DevicesDesignSystem.WidgetButtonModel.Error, b: DevicesDesignSystem.WidgetButtonModel.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let style: DevicesDesignSystem.PlasmaButtonStyleID
  public let size: DevicesDesignSystem.WidgetButtonModel.Size
  public let text: Swift.String
  public let icon: DevicesDesignSystem.ImageAddress?
  public let actions: [DevicesDesignSystem.AnyAction]
  public let logId: DevicesDesignSystem.LogID?
  public init(style: DevicesDesignSystem.PlasmaButtonStyleID, size: DevicesDesignSystem.WidgetButtonModel.Size, text: Swift.String, icon: DevicesDesignSystem.ImageAddress?, actions: [DevicesDesignSystem.AnyAction], logId: DevicesDesignSystem.LogID?)
  public static func == (a: DevicesDesignSystem.WidgetButtonModel, b: DevicesDesignSystem.WidgetButtonModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.WidgetButtonModel.Error {
  public var errorDescription: Swift.String? {
    get
  }
}
public protocol WidgetCard : DevicesUI.ViewRenderable, Swift.Hashable {
  var widgetId: DevicesDesignSystem.WidgetID? { get }
}
extension DevicesDesignSystem.WidgetCard {
  public var widgetId: DevicesDesignSystem.WidgetID? {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension DevicesDesignSystem.WidgetCategoriesGalleryModel : DevicesCore.Deserializable {
  public enum ItemsType : Swift.String {
    case discoveryCard
    case listCard
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.WidgetCategoriesGalleryModel.Chip : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.WidgetCategoriesGalleryModel.Category : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.WidgetCategoriesGalleryModel : DevicesUI.ViewRenderable, DevicesDesignSystem.CardBase {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct WidgetCategoriesGalleryModel : Swift.Hashable, DevicesDesignSystem.WidgetCard {
  public struct Chip : Swift.Hashable {
    public init(typeColor: DevicesDesignSystem.TypeColor, selectedTypeColor: DevicesDesignSystem.TypeColor, selectedBackgroundColor: DevicesDesignSystem.ButtonColor)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.WidgetCategoriesGalleryModel.Chip, b: DevicesDesignSystem.WidgetCategoriesGalleryModel.Chip) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ChipKind : Swift.String {
    case title
    case image
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct Category : Swift.Hashable {
    public init(title: DevicesDesignSystem.ChipGallerySection.ChipHeader, items: [DevicesDesignSystem.WidgetCategoriesGalleryModel.WidgetCategoriesItemModel])
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.WidgetCategoriesGalleryModel.Category, b: DevicesDesignSystem.WidgetCategoriesGalleryModel.Category) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum WidgetCategoriesItemModel : Swift.Hashable {
    case discoveryCard(DevicesDesignSystem.WidgetDiscoveryCardModel)
    case listCard(DevicesDesignSystem.ListCardModel)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.WidgetCategoriesGalleryModel.WidgetCategoriesItemModel, b: DevicesDesignSystem.WidgetCategoriesGalleryModel.WidgetCategoriesItemModel) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public let logId: DevicesDesignSystem.LogID?
  public init(chip: DevicesDesignSystem.WidgetCategoriesGalleryModel.Chip, chipsType: DevicesDesignSystem.WidgetCategoriesGalleryModel.ChipKind, categories: [DevicesDesignSystem.WidgetCategoriesGalleryModel.Category], categoriesPadding: DevicesDesignSystem.Paddings, contentInset: UIKit.UIEdgeInsets, logId: DevicesDesignSystem.LogID?)
  public static func == (a: DevicesDesignSystem.WidgetCategoriesGalleryModel, b: DevicesDesignSystem.WidgetCategoriesGalleryModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.WidgetCategoriesGalleryModel {
  public var cardsCount: Swift.Int {
    get
  }
  public var categoriesCount: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.WidgetCategoriesGalleryModel.WidgetCategoriesItemModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.WidgetDiscoveryCardModel : DevicesCore.Deserializable {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.WidgetDiscoveryCardModel {
  public static func sample(topCell: DevicesDesignSystem.CellModel? = .textCell(.sample()), middleCell: DevicesDesignSystem.CellModel? = .textCell(.sample()), bottomCell: DevicesDesignSystem.CellModel? = .textCell(.sample()), paddings: DevicesDesignSystem.Paddings = Paddings(horizontal: .x2, vertical: .x1), backgroundImage: DevicesDesignSystem.FlexibleImageModel? = .sample(), backgroundColor: UIKit.UIColor = UIColor(white: 0.9, alpha: 0.8), hasFade: Swift.Bool = true, height: DevicesDesignSystem.ContentHeight = .aspectRatio(16.0 / 9.0), width: DevicesDesignSystem.ContentWidth = .columns(4), actions: [DevicesDesignSystem.AnyAction] = [], logId: DevicesDesignSystem.LogID? = nil, widgetId: DevicesDesignSystem.WidgetID? = nil) -> DevicesDesignSystem.WidgetDiscoveryCardModel
}
extension DevicesDesignSystem.WidgetDiscoveryCardModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
extension DevicesDesignSystem.WidgetDiscoveryCardModel {
  public func resize() -> DevicesUI.ViewRenderable
}
public struct WidgetDiscoveryCardModel : Swift.Hashable, DevicesDesignSystem.WidgetCard, DevicesDesignSystem.CardBase {
  public let paddings: DevicesDesignSystem.Paddings
  public let topCell: DevicesDesignSystem.CellModel?
  public let middleCell: DevicesDesignSystem.CellModel?
  public let bottomCell: DevicesDesignSystem.CellModel?
  public let backgroundImage: DevicesDesignSystem.FlexibleImageModel?
  public let backgroundColor: UIKit.UIColor
  public let hasFade: Swift.Bool
  public let height: DevicesDesignSystem.ContentHeight
  public let width: DevicesDesignSystem.ContentWidth
  public let actions: [DevicesDesignSystem.AnyAction]?
  public let logId: DevicesDesignSystem.LogID?
  public var widgetId: DevicesDesignSystem.WidgetID?
  public init(paddings: DevicesDesignSystem.Paddings, topCell: DevicesDesignSystem.CellModel?, middleCell: DevicesDesignSystem.CellModel?, bottomCell: DevicesDesignSystem.CellModel?, backgroundImage: DevicesDesignSystem.FlexibleImageModel?, backgroundColor: UIKit.UIColor, hasFade: Swift.Bool = false, height: DevicesDesignSystem.ContentHeight, width: DevicesDesignSystem.ContentWidth, actions: [DevicesDesignSystem.AnyAction]?, logId: DevicesDesignSystem.LogID? = nil, widgetId: DevicesDesignSystem.WidgetID? = nil)
  public static func == (a: DevicesDesignSystem.WidgetDiscoveryCardModel, b: DevicesDesignSystem.WidgetDiscoveryCardModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.WidgetGalleryModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.WidgetGalleryModel {
  public static func sample(logId: DevicesDesignSystem.LogID? = "log_id", items: [DevicesDesignSystem.WidgetDiscoveryCardModel] = [
			.sample(),
		], spacing: DevicesDesignSystem.Dimensions = .x1, contentInset: UIKit.UIEdgeInsets = UIEdgeInsets(inset: 8)) -> DevicesDesignSystem.WidgetGalleryModel
}
extension DevicesDesignSystem.WidgetGalleryModel : DevicesUI.ViewRenderable, DevicesDesignSystem.CardBase {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct WidgetGalleryModel : Swift.Hashable, DevicesDesignSystem.WidgetCard {
  public let logId: DevicesDesignSystem.LogID?
  public init(logId: DevicesDesignSystem.LogID?, items: [DevicesDesignSystem.WidgetDiscoveryCardModel], spacing: DevicesDesignSystem.Dimensions, contentInset: UIKit.UIEdgeInsets)
  public static func == (lhs: DevicesDesignSystem.WidgetGalleryModel, rhs: DevicesDesignSystem.WidgetGalleryModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.WidgetGalleryModel {
  public var cardsCount: Swift.Int {
    get
  }
}
public typealias WidgetID = DevicesCore.Tagged<DevicesDesignSystem.WidgetTag, Swift.String>
public enum WidgetTag {
}
public enum WidgetLeaf {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public var widgetId: DevicesDesignSystem.WidgetID? {
    get
  }
  case discoveryCard(DevicesDesignSystem.WidgetDiscoveryCardModel)
}
extension DevicesDesignSystem.WidgetModel : DevicesCore.Deserializable {
  public enum UserInfoKeys {
    public static let logId: Swift.String
    public static let widgetType: Swift.String
  }
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.WidgetModel {
  public var reuseID: DevicesUI.ReuseID {
    get
  }
}
extension DevicesDesignSystem.WidgetModel : DevicesDesignSystem.CardBase, DevicesUI.ViewRenderable {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
@frozen public enum WidgetModel : Swift.Equatable {
  case titleCard(DevicesDesignSystem.WidgetTitleCardModel)
  case singleCard(DevicesDesignSystem.WidgetSingleCardModel)
  case gallery(DevicesDesignSystem.WidgetGalleryModel)
  case categoriesGallery(DevicesDesignSystem.WidgetCategoriesGalleryModel)
  case twoColumns(DevicesDesignSystem.WidgetTwoColumnModel)
  case listCard(DevicesDesignSystem.ListCardModel)
  case verticalCards(DevicesDesignSystem.WidgetVerticalCardsModel)
  case nestedContentCard(DevicesDesignSystem.WidgetNestedContentCardModel)
  case widgetButton(DevicesDesignSystem.WidgetButtonModel)
  public static func == (a: DevicesDesignSystem.WidgetModel, b: DevicesDesignSystem.WidgetModel) -> Swift.Bool
}
extension DevicesDesignSystem.WidgetModel {
  public static let preferredMargins: CoreFoundation.CGFloat
  public var isScrollable: Swift.Bool {
    get
  }
}
extension DevicesDesignSystem.WidgetModel : DevicesDesignSystem.WidgetCard {
  public var widgetId: DevicesDesignSystem.WidgetID? {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.WidgetNestedContentCardModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.WidgetNestedContentCardModel.Header : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.WidgetNestedContentCardModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct WidgetNestedContentCardModel : Swift.Hashable, DevicesDesignSystem.CardBase, DevicesDesignSystem.WidgetCard {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public struct Header : Swift.Hashable {
    public let backgroundImage: DevicesDesignSystem.FlexibleImageModel?
    public let cell: DevicesDesignSystem.CellModel?
    public let height: DevicesDesignSystem.ContentHeight?
    public let actions: [DevicesDesignSystem.AnyAction]?
    public init(backgroundImage: DevicesDesignSystem.FlexibleImageModel?, cell: DevicesDesignSystem.CellModel?, height: DevicesDesignSystem.ContentHeight?, actions: [DevicesDesignSystem.AnyAction]?)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesDesignSystem.WidgetNestedContentCardModel.Header, b: DevicesDesignSystem.WidgetNestedContentCardModel.Header) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public let header: DevicesDesignSystem.WidgetNestedContentCardModel.Header?
  public let backgroundColor: UIKit.UIColor
  public let bodyCell: DevicesDesignSystem.CellModel?
  public let nestedContent: DevicesDesignSystem.NestedContentModel?
  public let paddings: DevicesDesignSystem.Paddings
  public let logId: DevicesDesignSystem.LogID?
  public init(header: DevicesDesignSystem.WidgetNestedContentCardModel.Header?, backgroundColor: UIKit.UIColor, bodyCell: DevicesDesignSystem.CellModel?, nestedContent: DevicesDesignSystem.NestedContentModel?, paddings: DevicesDesignSystem.Paddings?, logId: DevicesDesignSystem.LogID?)
  public static func == (a: DevicesDesignSystem.WidgetNestedContentCardModel, b: DevicesDesignSystem.WidgetNestedContentCardModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.WidgetSingleCardModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.WidgetSingleCardModel : DevicesUI.ViewRenderable, DevicesDesignSystem.CardBase {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct WidgetSingleCardModel : Swift.Hashable, DevicesDesignSystem.WidgetCard {
  public let logId: DevicesDesignSystem.LogID?
  public init(logId: DevicesDesignSystem.LogID?, item: DevicesDesignSystem.WidgetDiscoveryCardModel)
  public static func == (a: DevicesDesignSystem.WidgetSingleCardModel, b: DevicesDesignSystem.WidgetSingleCardModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.WidgetTitleCardModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.WidgetTitleCardModel : DevicesUI.ViewRenderable, DevicesDesignSystem.CardBase {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct WidgetTitleCardModel : Swift.Hashable, DevicesDesignSystem.WidgetCard {
  public let logId: DevicesDesignSystem.LogID?
  public init(logId: DevicesDesignSystem.LogID?, cell: DevicesDesignSystem.LeftRightCellModel)
  public static func == (a: DevicesDesignSystem.WidgetTitleCardModel, b: DevicesDesignSystem.WidgetTitleCardModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct WidgetTree : Swift.Equatable {
  public enum Error : Swift.Error, Swift.Equatable {
    case missingWidgetId
    case unsupportedLeafKind(DevicesDesignSystem.ElementType)
    case unsupportedWidgetKind(DevicesDesignSystem.ElementType)
    public static func == (a: DevicesDesignSystem.WidgetTree.Error, b: DevicesDesignSystem.WidgetTree.Error) -> Swift.Bool
  }
  public var widgets: [DevicesDesignSystem.WidgetModel] {
    get
  }
  public init(widgets: [DevicesDesignSystem.WidgetModel])
  public mutating func replace(_ newWidget: DevicesDesignSystem.WidgetLeaf) throws
  public static func == (a: DevicesDesignSystem.WidgetTree, b: DevicesDesignSystem.WidgetTree) -> Swift.Bool
}
extension DevicesDesignSystem.WidgetTwoColumnModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.WidgetTwoColumnModel : DevicesDesignSystem.CardBase, DevicesUI.ViewRenderable {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct WidgetTwoColumnModel : Swift.Equatable, DevicesDesignSystem.WidgetCard {
  public let logId: DevicesDesignSystem.LogID?
  public init(logId: DevicesDesignSystem.LogID?, left: [DevicesDesignSystem.WidgetDiscoveryCardModel], right: [DevicesDesignSystem.WidgetDiscoveryCardModel])
  public static func == (a: DevicesDesignSystem.WidgetTwoColumnModel, b: DevicesDesignSystem.WidgetTwoColumnModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.WidgetTwoColumnModel {
  public var cardsCount: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.WidgetVerticalCardsModel : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesDesignSystem.WidgetVerticalCardsModel : DevicesUI.ViewRenderable, DevicesDesignSystem.CardBase {
  public var elementType: DevicesDesignSystem.ElementType {
    get
  }
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct WidgetVerticalCardsModel : Swift.Hashable {
  public let logId: DevicesDesignSystem.LogID?
  @DevicesCore.MutableProperty @_projectedValueProperty($disclosedItemsCount) public var disclosedItemsCount: Swift.Int {
    get
    nonmutating set
    nonmutating _modify
  }
  public var $disclosedItemsCount: DevicesCore.MutableProperty<Swift.Int> {
    get
  }
  public init(logId: DevicesDesignSystem.LogID?, widgetId: DevicesDesignSystem.WidgetID?, items: [DevicesDesignSystem.WidgetDiscoveryCardModel], contentInset: UIKit.UIEdgeInsets)
  public static func == (lhs: DevicesDesignSystem.WidgetVerticalCardsModel, rhs: DevicesDesignSystem.WidgetVerticalCardsModel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.WidgetVerticalCardsModel {
  public var cardsCount: Swift.Int {
    get
  }
}
extension DevicesDesignSystem.AnimationDurationID : Swift.Equatable {}
extension DevicesDesignSystem.AnimationDurationID : Swift.Hashable {}
extension DevicesDesignSystem.AnimationDurationID : Swift.RawRepresentable {}
extension DevicesDesignSystem.ArrayRightModel.Orientation : Swift.RawRepresentable {}
extension DevicesDesignSystem.BackgroundColor : Swift.Equatable {}
extension DevicesDesignSystem.BackgroundColor : Swift.Hashable {}
extension DevicesDesignSystem.BackgroundColor : Swift.RawRepresentable {}
extension DevicesDesignSystem.ButtonColor : Swift.Equatable {}
extension DevicesDesignSystem.ButtonColor : Swift.Hashable {}
extension DevicesDesignSystem.ButtonColor : Swift.RawRepresentable {}
extension DevicesDesignSystem.ButtonColorKind : Swift.Equatable {}
extension DevicesDesignSystem.ButtonColorKind : Swift.Hashable {}
extension DevicesDesignSystem.ButtonColorKind : Swift.RawRepresentable {}
extension DevicesDesignSystem.ButtonModel.Error : Swift.Equatable {}
extension DevicesDesignSystem.ButtonModel.Error : Swift.Hashable {}
extension DevicesDesignSystem.ButtonSpinnerStyle : Swift.Equatable {}
extension DevicesDesignSystem.ButtonSpinnerStyle : Swift.Hashable {}
extension DevicesDesignSystem.ButtonSpinnerStyle : Swift.RawRepresentable {}
extension DevicesDesignSystem.CharacterSemantic : Swift.Equatable {}
extension DevicesDesignSystem.CharacterSemantic : Swift.Hashable {}
extension DevicesDesignSystem.CommonAlertType : Swift.Equatable {}
extension DevicesDesignSystem.CommonAlertType : Swift.Hashable {}
extension DevicesDesignSystem.CornersRounding : Swift.Equatable {}
extension DevicesDesignSystem.CornersRounding : Swift.Hashable {}
extension DevicesDesignSystem.CornersRounding : Swift.RawRepresentable {}
extension DevicesDesignSystem.DesignSystemLocalImageID.Mono : Swift.Equatable {}
extension DevicesDesignSystem.DesignSystemLocalImageID.Mono : Swift.Hashable {}
extension DevicesDesignSystem.DesignSystemLocalImageID.Mono : Swift.RawRepresentable {}
extension DevicesDesignSystem.DesignSystemLocalImageID.Color : Swift.Equatable {}
extension DevicesDesignSystem.DesignSystemLocalImageID.Color : Swift.Hashable {}
extension DevicesDesignSystem.DesignSystemLocalImageID.Color : Swift.RawRepresentable {}
extension DevicesDesignSystem.DetailRightModel.Error : Swift.Equatable {}
extension DevicesDesignSystem.DetailRightModel.Error : Swift.Hashable {}
extension DevicesDesignSystem.DetailRightModel.DetailPosition : Swift.Equatable {}
extension DevicesDesignSystem.DetailRightModel.DetailPosition : Swift.Hashable {}
extension DevicesDesignSystem.DetailRightModel.DetailPosition : Swift.RawRepresentable {}
extension DevicesDesignSystem.DetailsCellModel.Error : Swift.Hashable {}
extension DevicesDesignSystem.Device.App : Swift.Hashable {}
extension DevicesDesignSystem.Dimensions : Swift.Equatable {}
extension DevicesDesignSystem.Dimensions : Swift.Hashable {}
extension DevicesDesignSystem.Dimensions : Swift.RawRepresentable {}
extension DevicesDesignSystem.DividerModel.Size : Swift.Equatable {}
extension DevicesDesignSystem.DividerModel.Size : Swift.Hashable {}
extension DevicesDesignSystem.DividerModel.Size : Swift.RawRepresentable {}
extension DevicesDesignSystem.DividerModel.Style : Swift.Equatable {}
extension DevicesDesignSystem.DividerModel.Style : Swift.Hashable {}
extension DevicesDesignSystem.DividerModel.Style : Swift.RawRepresentable {}
extension DevicesDesignSystem.ExtendedImageRatio : Swift.Equatable {}
extension DevicesDesignSystem.ExtendedImageRatio : Swift.Hashable {}
extension DevicesDesignSystem.ExtendedImageRatio : Swift.RawRepresentable {}
extension DevicesDesignSystem.FlexibleImageModel.Mask : Swift.Equatable {}
extension DevicesDesignSystem.FlexibleImageModel.Mask : Swift.Hashable {}
extension DevicesDesignSystem.FlexibleImageModel.Mask : Swift.RawRepresentable {}
extension DevicesDesignSystem.GalleryCardItemKind : Swift.Equatable {}
extension DevicesDesignSystem.GalleryCardItemKind : Swift.Hashable {}
extension DevicesDesignSystem.GalleryCardItemKind : Swift.RawRepresentable {}
extension DevicesDesignSystem.GalleryMediaCardItem.Error : Swift.Equatable {}
extension DevicesDesignSystem.GalleryMediaCardItem.Error : Swift.Hashable {}
extension DevicesDesignSystem.GradientStyleID : Swift.Equatable {}
extension DevicesDesignSystem.GradientStyleID : Swift.Hashable {}
extension DevicesDesignSystem.GradientStyleID : Swift.RawRepresentable {}
extension DevicesDesignSystem.GridCardModel.GridContentHeight : Swift.Equatable {}
extension DevicesDesignSystem.GridCardModel.GridContentHeight : Swift.Hashable {}
extension DevicesDesignSystem.GridCardModel.GridContentHeight : Swift.RawRepresentable {}
extension DevicesDesignSystem.GridContentSize.Error : Swift.Hashable {}
extension DevicesDesignSystem.GridContentWidth : Swift.Equatable {}
extension DevicesDesignSystem.GridContentWidth : Swift.Hashable {}
extension DevicesDesignSystem.GridContentWidth : Swift.RawRepresentable {}
extension DevicesDesignSystem.IconModel.RoundedCorners : Swift.Equatable {}
extension DevicesDesignSystem.IconModel.RoundedCorners : Swift.Hashable {}
extension DevicesDesignSystem.IconModel.RoundedCorners : Swift.RawRepresentable {}
extension DevicesDesignSystem.Icon.Size.Dimension : Swift.Equatable {}
extension DevicesDesignSystem.Icon.Size.Dimension : Swift.Hashable {}
extension DevicesDesignSystem.Icon.Size.Dimension : Swift.RawRepresentable {}
extension DevicesDesignSystem.ImagePickerConfig.Source : Swift.Hashable {}
extension DevicesDesignSystem.InlineAlertModel.PresentationStyle : Swift.Equatable {}
extension DevicesDesignSystem.InlineAlertModel.PresentationStyle : Swift.Hashable {}
extension DevicesDesignSystem.InlineAlertView.IconType : Swift.Equatable {}
extension DevicesDesignSystem.InlineAlertView.IconType : Swift.Hashable {}
extension DevicesDesignSystem.LegacyButtonModel.Error : Swift.Equatable {}
extension DevicesDesignSystem.LegacyButtonModel.Error : Swift.Hashable {}
extension DevicesDesignSystem.LegacyButtonModelStyle : Swift.Equatable {}
extension DevicesDesignSystem.LegacyButtonModelStyle : Swift.Hashable {}
extension DevicesDesignSystem.LegacyButtonModelStyle : Swift.RawRepresentable {}
extension DevicesDesignSystem.LottieBackgroundBehavior : Swift.Hashable {}
extension DevicesDesignSystem.PaymentColor : Swift.Equatable {}
extension DevicesDesignSystem.PaymentColor : Swift.Hashable {}
extension DevicesDesignSystem.PaymentColor : Swift.RawRepresentable {}
extension DevicesDesignSystem.PlasmaButtonStyleID : Swift.Equatable {}
extension DevicesDesignSystem.PlasmaButtonStyleID : Swift.Hashable {}
extension DevicesDesignSystem.PlasmaButtonStyleID : Swift.RawRepresentable {}
extension DevicesDesignSystem.ProgressSpinnerStyle : Swift.Equatable {}
extension DevicesDesignSystem.ProgressSpinnerStyle : Swift.Hashable {}
extension DevicesDesignSystem.RoundButtonModel.Error : Swift.Equatable {}
extension DevicesDesignSystem.RoundButtonModel.Error : Swift.Hashable {}
extension DevicesDesignSystem.ScaleMode : Swift.Equatable {}
extension DevicesDesignSystem.ScaleMode : Swift.Hashable {}
extension DevicesDesignSystem.ScaleMode : Swift.RawRepresentable {}
extension DevicesDesignSystem.SelectType : Swift.Equatable {}
extension DevicesDesignSystem.SelectType : Swift.Hashable {}
extension DevicesDesignSystem.SelectType : Swift.RawRepresentable {}
extension DevicesDesignSystem.ShareScreenConfig.Destination : Swift.Equatable {}
extension DevicesDesignSystem.ShareScreenConfig.Destination : Swift.Hashable {}
extension DevicesDesignSystem.ShimmerItemRenderType : Swift.Equatable {}
extension DevicesDesignSystem.ShimmerItemRenderType : Swift.Hashable {}
extension DevicesDesignSystem.SmartAppColor : Swift.Equatable {}
extension DevicesDesignSystem.SmartAppColor : Swift.Hashable {}
extension DevicesDesignSystem.SmartAppColor : Swift.RawRepresentable {}
extension DevicesDesignSystem.SpeechBubbleColor : Swift.Equatable {}
extension DevicesDesignSystem.SpeechBubbleColor : Swift.Hashable {}
extension DevicesDesignSystem.SpeechBubbleColor : Swift.RawRepresentable {}
extension DevicesDesignSystem.SurfaceColor : Swift.Equatable {}
extension DevicesDesignSystem.SurfaceColor : Swift.Hashable {}
extension DevicesDesignSystem.SurfaceColor : Swift.RawRepresentable {}
extension DevicesDesignSystem.SwipeType : Swift.Equatable {}
extension DevicesDesignSystem.SwipeType : Swift.Hashable {}
extension DevicesDesignSystem.SwipeType : Swift.RawRepresentable {}
extension DevicesDesignSystem.TextModel.Error : Swift.Equatable {}
extension DevicesDesignSystem.TextModel.Error : Swift.Hashable {}
extension DevicesDesignSystem.Toast.Gravity : Swift.Equatable {}
extension DevicesDesignSystem.Toast.Gravity : Swift.Hashable {}
extension DevicesDesignSystem.TransitionDriver.Direction : Swift.Equatable {}
extension DevicesDesignSystem.TransitionDriver.Direction : Swift.Hashable {}
extension DevicesDesignSystem.TypeColor : Swift.Equatable {}
extension DevicesDesignSystem.TypeColor : Swift.Hashable {}
extension DevicesDesignSystem.TypeColor : Swift.RawRepresentable {}
extension UIKit.UIColor.HexParsingError : Swift.Hashable {}
extension DevicesDesignSystem.UserInterfaceStyle : Swift.Hashable {}
extension DevicesDesignSystem.UserInterfaceStyle : Swift.RawRepresentable {}
extension DevicesDesignSystem.WidgetButtonModel.Size : Swift.Equatable {}
extension DevicesDesignSystem.WidgetButtonModel.Size : Swift.Hashable {}
extension DevicesDesignSystem.WidgetButtonModel.Size : Swift.RawRepresentable {}
extension DevicesDesignSystem.WidgetButtonModel.Error : Swift.Equatable {}
extension DevicesDesignSystem.WidgetButtonModel.Error : Swift.Hashable {}
extension DevicesDesignSystem.WidgetCategoriesGalleryModel.ItemsType : Swift.Equatable {}
extension DevicesDesignSystem.WidgetCategoriesGalleryModel.ItemsType : Swift.Hashable {}
extension DevicesDesignSystem.WidgetCategoriesGalleryModel.ItemsType : Swift.RawRepresentable {}
extension DevicesDesignSystem.WidgetCategoriesGalleryModel.ChipKind : Swift.Equatable {}
extension DevicesDesignSystem.WidgetCategoriesGalleryModel.ChipKind : Swift.Hashable {}
extension DevicesDesignSystem.WidgetCategoriesGalleryModel.ChipKind : Swift.RawRepresentable {}
