// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.1 (swiftlang-5.7.1.135.3 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name JazzServices
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFAudio
import AVFoundation
import CoreBluetooth
import DevicesCore
import Foundation
import JazzAPI
import JazzCore
import LibSberCast
import Swift
import UIKit
import WebRTC
import _Concurrency
import _StringProcessing
public struct AnalyticsRequestParameters {
  public enum Error : Swift.Error {
    case serialize
    public static func == (a: JazzServices.AnalyticsRequestParameters.Error, b: JazzServices.AnalyticsRequestParameters.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let events: [JazzServices.SingleAnalyticsEventParameters]
  public init(events: [JazzServices.SingleAnalyticsEventParameters])
}
public typealias AnalyticsRequestPerformer = DevicesCore.RequestPerformer<(JazzAPI.BackendURL, JazzServices.AnalyticsRequestParameters), Swift.Void>
extension DevicesCore.RequestPerformer where Request == (JazzAPI.BackendURL, JazzServices.AnalyticsRequestParameters), Response == () {
  public static func make(urlRequestPerformer: DevicesCore.URLRequestPerformer, logger: DevicesCore.Logger, assertionCaller: DevicesCore.AssertionCaller, errorHandler: DevicesCore.SerializationErrorHandler) -> JazzServices.AnalyticsRequestPerformer
}
public enum AsrError : Swift.Error {
  case alreadyEnabled
  case disabledByAdmin
  case forbidden
  public static func == (a: JazzServices.AsrError, b: JazzServices.AsrError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias AsrPerformer = DevicesCore.RequestPerformer<(JazzAPI.BackendURL, Swift.Bool), Swift.Void>
extension DevicesCore.RequestPerformer where Request == (JazzAPI.BackendURL, Swift.Bool), Response == () {
  public static func make(urlRequestPerformer: DevicesCore.URLRequestPerformer, logger: DevicesCore.Logger, assertionCaller: DevicesCore.AssertionCaller) -> JazzServices.AsrPerformer
}
public protocol AsrService {
  func toggleAsr(isEnabled: Swift.Bool, roomHost: JazzAPI.JazzHost?, with completion: @escaping (Swift.Result<Swift.Void, JazzServices.AsrError>) -> Swift.Void)
}
final public class AsrServiceImpl : JazzServices.AsrService {
  public init(asrPerformer: JazzServices.AsrPerformer, backendURLResolver: JazzServices.BackendURLResolver)
  final public func toggleAsr(isEnabled: Swift.Bool, roomHost: JazzAPI.JazzHost?, with completion: @escaping (Swift.Result<Swift.Void, JazzServices.AsrError>) -> Swift.Void)
  @objc deinit
}
public struct AudioTrackModel : DevicesCore.Deserializable, Swift.Equatable {
  public let reactTag: JazzServices.AudioTrackModel.ReactTag?
  public let muted: Swift.Bool
  public init(deserializer: DevicesCore.Deserializer) throws
  public init(reactTag: JazzServices.AudioTrackModel.ReactTag?, muted: Swift.Bool)
  public static func == (a: JazzServices.AudioTrackModel, b: JazzServices.AudioTrackModel) -> Swift.Bool
}
extension JazzServices.AudioTrackModel {
  public typealias ReactTag = DevicesCore.Tagged<JazzServices.AudioTrackModel.ReactTagTag, Swift.String>
  public enum ReactTagTag {
  }
}
public protocol BackendURLResolver {
  func resolve(host: JazzAPI.JazzHost?, completion: @escaping (Swift.Result<JazzAPI.BackendURL, DevicesCore.RequestError>) -> Swift.Void)
}
public typealias BackendURLResolverRequestPerformer = DevicesCore.RequestPerformer<JazzAPI.JazzHost, JazzServices.JazzConfig>
extension DevicesCore.RequestPerformer where Request == DevicesCore.Tagged<JazzAPI.JazzHostTag, JazzAPI.Host>, Response == JazzServices.JazzConfig {
  public static func make(urlRequestPerformer: DevicesCore.URLRequestPerformer, logger: DevicesCore.Logger, assertionCaller: DevicesCore.AssertionCaller) -> JazzServices.BackendURLResolverRequestPerformer
}
extension Swift.Bool {
  public var stringValue: Swift.String {
    get
  }
}
public struct CallConfig : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension JazzServices.CallConfig {
  public init()
}
extension JazzServices.CallConfig {
  public func toDict(authToken: Swift.String?) -> [Swift.AnyHashable : Any]
}
public struct CancellableConferenceConnection : DevicesCore.Cancellable {
  public init(cancelToken: DevicesCore.Cancellable, rejectCall: @escaping () -> Swift.Void)
  public func cancel()
  public func reject()
}
extension JazzServices.CancellableConferenceConnection {
  public func addingRejectClosure(_ closure: @escaping () -> Swift.Void) -> JazzServices.CancellableConferenceConnection
}
public struct ChatMessageModel : DevicesCore.Deserializable, Swift.Equatable {
  public enum MessageType : Swift.String {
    case local
    case remote
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Status : Swift.Equatable {
    case processing
    case delivered
    case timeout
    case rejected
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: JazzServices.ChatMessageModel.Status, b: JazzServices.ChatMessageModel.Status) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public let id: JazzServices.ChatMessageModel.ID
  public let participantId: JazzServices.ConferenceParticipant.ID
  public var currentName: JazzServices.ConferenceParticipant.Name?
  public var userNameWhenMessageSent: JazzServices.ConferenceParticipant.Name?
  public let messageType: JazzServices.ChatMessageModel.MessageType
  public var message: JazzServices.ChatMessageModel.Message
  public let timestamp: Swift.Double
  public let isAsr: Swift.Bool
  public var status: JazzServices.ChatMessageModel.Status
  public init(deserializer: DevicesCore.Deserializer) throws
  public init(participantId: JazzServices.ConferenceParticipant.ID, currentName: JazzServices.ConferenceParticipant.Name?, userNameWhenMessageSent: JazzServices.ConferenceParticipant.Name?, messageType: JazzServices.ChatMessageModel.MessageType, message: JazzServices.ChatMessageModel.Message, timestamp: Swift.Double, isAsr: Swift.Bool, status: JazzServices.ChatMessageModel.Status, id: JazzServices.ChatMessageModel.ID = ID(value: UUID().uuidString))
  public static func == (a: JazzServices.ChatMessageModel, b: JazzServices.ChatMessageModel) -> Swift.Bool
}
extension JazzServices.ChatMessageModel {
  public var userName: Swift.String {
    get
  }
}
extension JazzServices.ChatMessageModel {
  public typealias Message = DevicesCore.Tagged<JazzServices.ChatMessageModel.MessageTag, Swift.String>
  public typealias ID = DevicesCore.Tagged<JazzServices.ChatMessageModel.IDTag, Swift.String>
  public enum MessageTag {
  }
  public enum IDTag {
  }
}
public struct ChatParticipantsData : Swift.Equatable {
  public struct Participant : Swift.Equatable {
    public var id: JazzServices.ConferenceParticipant.ID
    public var name: JazzServices.ConferenceParticipant.Name
    public init(id: JazzServices.ConferenceParticipant.ID, name: JazzServices.ConferenceParticipant.Name)
    public static func == (a: JazzServices.ChatParticipantsData.Participant, b: JazzServices.ChatParticipantsData.Participant) -> Swift.Bool
  }
  public let participants: [JazzServices.ChatParticipantsData.Participant]
  public init(participants: [JazzServices.ChatParticipantsData.Participant])
  public static func == (a: JazzServices.ChatParticipantsData, b: JazzServices.ChatParticipantsData) -> Swift.Bool
}
extension JazzServices.ChatParticipantsData : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension JazzServices.ChatParticipantsData.Participant : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
public typealias ChatParticipantsRequestPerformer = DevicesCore.RequestPerformer<JazzServices.ConferenceRooms, JazzServices.ChatParticipantsData>
extension DevicesCore.RequestPerformer where Request == JazzServices.ConferenceRooms, Response == JazzServices.ChatParticipantsData {
  public static func make(urlRequestPerformer: DevicesCore.URLRequestPerformer, logger: DevicesCore.Logger) -> JazzServices.ChatParticipantsRequestPerformer
}
public protocol ChatParticipantsService {
  func getChatParticipants(parameters: JazzServices.ConferenceRooms, cancelToken: DevicesCore.CancellationToken?, completion: @escaping DevicesCore.ResultCompletion<JazzServices.ChatParticipantsData>)
}
final public class ChatParticipantsServiceImpl : JazzServices.ChatParticipantsService {
  public init(urlRequestPerformer: DevicesCore.URLRequestPerformer, logger: DevicesCore.Logger)
  final public func getChatParticipants(parameters: JazzServices.ConferenceRooms, cancelToken: DevicesCore.CancellationToken?, completion: @escaping DevicesCore.ResultCompletion<JazzServices.ChatParticipantsData>)
  @objc deinit
}
public typealias ClientID = DevicesCore.Tagged<JazzServices.ClientIDTag, Swift.String>
public enum ClientIDTag {
}
public protocol ClientIDStorage {
  var clientId: JazzServices.ClientID { get }
}
public class ClientIDStorageImpl : JazzServices.ClientIDStorage {
  final public let clientId: JazzServices.ClientID
  public init(storage: DevicesCore.KeyValueStorage)
  @objc deinit
}
public struct CloseRoomRequestParameters : DevicesCore.Serializable, Swift.Equatable {
  public init(publicRoomPassword: JazzAPI.Jazz.DecodedPassword)
  public func toJSONDictionary() -> DevicesCore.JSONDictionary
  public static func == (a: JazzServices.CloseRoomRequestParameters, b: JazzServices.CloseRoomRequestParameters) -> Swift.Bool
}
public typealias CloseRoomRequestPerformer = DevicesCore.RequestPerformer<JazzServices.CloseRoomRequestParameters, Swift.Void>
extension DevicesCore.RequestPerformer where Request == JazzServices.CloseRoomRequestParameters, Response == () {
  public static func make(url: Foundation.URL, headerBuilder: DevicesCore.HeaderBuilder, urlRequestPerformer: DevicesCore.URLRequestPerformer, logger: DevicesCore.Logger, assertionCaller: DevicesCore.AssertionCaller) -> JazzServices.CloseRoomRequestPerformer
}
public protocol ClosurePerformer {
  func enqueue(label: Swift.String?, _ closure: @escaping () -> Swift.Void)
  func clear()
}
final public class ConditionBasedClosurePerformer : JazzServices.ClosurePerformer {
  public init(canExecute: DevicesCore.Property<Swift.Bool>, cleanSignal: DevicesCore.DefaultSignal<Swift.Void>? = nil, logger: DevicesCore.Logger? = nil, logLabel: Swift.String? = nil)
  final public func enqueue(label: Swift.String?, _ closure: @escaping () -> Swift.Void)
  final public func clear()
  @objc deinit
}
public protocol ConferenceAudioManager {
  func cameraIsOnChanged(isCameraOn: Swift.Bool)
}
public typealias ConferenceAudioManagerFactory = DevicesCore.Factory<JazzAPI.ConferencePreferredSpeaker?, JazzServices.ConferenceAudioManager>
@objc final public class ConferenceAudioManagerImpl : ObjectiveC.NSObject, JazzServices.ConferenceAudioManager {
  public init(controller: DevicesCore.AudioSessionController, rtcAudioSession: JazzServices.RTCAudioSessionProtocol, isAudioRoutePickerShown: DevicesCore.Property<Swift.Bool>, asyncPerformer: DevicesCore.AsyncPerformer = DispatchSerialQueue(
			label: "ru.sberbank.ConferenceAudioManagerQueue",
			qos: .userInitiated
		), logger: DevicesCore.Logger?, prefferedSpeaker: JazzAPI.ConferencePreferredSpeaker)
  @objc deinit
  final public func cameraIsOnChanged(isCameraOn: Swift.Bool)
}
extension JazzServices.ConferenceAudioManagerImpl : WebRTC.RTCAudioSessionDelegate {
  @objc final public func audioSessionDidChangeRoute(_ session: WebRTC.RTCAudioSession, reason: AVFAudio.AVAudioSession.RouteChangeReason, previousRoute _: AVFAudio.AVAudioSessionRouteDescription)
}
public protocol ConferenceBaseState : JazzServices.ConferenceEventsProvider {
  var phase: DevicesCore.Property<JazzServices.ConferencePhase> { get }
  var onXmppConnectionEstablished: DevicesCore.Signal<Foundation.TimeInterval> { get }
  var onIceConnectionEstablished: DevicesCore.Signal<Foundation.TimeInterval> { get }
  var onMediaConnectionEstablished: DevicesCore.Signal<Foundation.TimeInterval> { get }
  var isConferenceJoined: DevicesCore.Property<Swift.Bool> { get }
  var isMounted: DevicesCore.Property<Swift.Bool> { get }
  var isDataChannelOpened: DevicesCore.Property<Swift.Bool> { get }
  var onInitialParticipantsCount: DevicesCore.Signal<Swift.Int> { get }
  var onShouldDisableCamera: DevicesCore.Signal<Swift.Void> { get }
  var onShouldDisableScreenShare: DevicesCore.Signal<Swift.Void> { get }
  var onShouldDisableMicrophone: DevicesCore.Signal<Swift.Void> { get }
  var onChatMessageReceived: DevicesCore.Signal<JazzServices.ChatMessageModel> { get }
  var dominantSpeakerChanged: DevicesCore.Signal<JazzServices.ConferenceParticipant.ID> { get }
  var onRoomPolicyUpdated: DevicesCore.Signal<JazzAPI.PrivateRoom.RoomPolicy> { get }
  var onRoomSettingsUpdated: DevicesCore.Signal<JazzServices.RoomSettingsUpdate> { get }
  var onCanShareAudioGranted: DevicesCore.Signal<Swift.Bool> { get }
  var onCanShareVideoGranted: DevicesCore.Signal<Swift.Bool> { get }
  var onCanShareScreenGranted: DevicesCore.Signal<Swift.Bool> { get }
  var onCanSendMessageGranted: DevicesCore.Signal<Swift.Bool> { get }
  var onCanEditOwnNameGranted: DevicesCore.Signal<Swift.Bool> { get }
  var watermarkText: DevicesCore.Property<Swift.String> { get }
  var onLobbyJoined: DevicesCore.Signal<Swift.Void> { get }
  var onLobbyAccessGranted: DevicesCore.Signal<Swift.Void> { get }
  var onLobbyAccessDenied: DevicesCore.Signal<Swift.Void> { get }
  var isAsrEnabled: DevicesCore.Property<Swift.Bool> { get }
  var webinarStarted: DevicesCore.Signal<JazzServices.WebinarBroadcastInfo> { get }
  var onServerVideoRecordStarted: DevicesCore.Signal<JazzServices.ConferenceParticipant.UserID?> { get }
  var onServerVideoRecordStopped: DevicesCore.Signal<JazzServices.ServerVideoRecordStopReason?> { get }
  var onServerVideoRecordAutoStartError: DevicesCore.Signal<JazzServices.ServerVideoRecordError> { get }
}
public protocol ConferenceBluetoothService {
  var authorizationStatus: DevicesCore.Property<DevicesCore.AuthorizationStatus?> { get }
  func startAuthorization()
}
@objc @_inheritsConvenienceInitializers final public class ConferenceBluetoothServiceImpl : ObjectiveC.NSObject, JazzServices.ConferenceBluetoothService {
  final public var authorizationStatus: DevicesCore.Property<DevicesCore.AuthorizationStatus?> {
    get
  }
  @objc override dynamic public init()
  final public func startAuthorization()
  @objc deinit
}
extension JazzServices.ConferenceBluetoothServiceImpl : CoreBluetooth.CBCentralManagerDelegate {
  @objc final public func centralManagerDidUpdateState(_: CoreBluetooth.CBCentralManager)
}
public typealias ConferenceConnectionController = JazzServices.ConferenceJoiner & JazzServices.ConferenceLeaver
final public class ConferenceConnectionControllerImpl : JazzServices.ConferenceConnectionController {
  final public var willLeave: DevicesCore.Signal<Swift.Void> {
    get
  }
  public init(jitsiController: JazzServices.JitsiConferenceConnectionController, conferenceSettings: JazzServices.ConferenceSettings, callConfig: JazzServices.CallConfig, logger: DevicesCore.Logger)
  final public func join(mediaSettings: JazzAPI.ConferenceMediaSettings, room: JazzAPI.PrivateRoom, userName: Swift.String, title: Swift.String?, peerName: Swift.String?, isCall: Swift.Bool)
  final public func leave()
  @objc deinit
}
final public class ConferenceConnectionControllerProxy : JazzServices.JitsiConferenceConnectionController {
  public init(connectionController: JazzServices.JitsiConferenceConnectionController, performer: JazzServices.ClosurePerformer)
  final public func join(_ options: JazzCore.JitsiMeetConferenceOptions?)
  final public func leave()
  @objc deinit
}
extension JazzAPI.ConferenceTokenError {
  public var asConnectionError: JazzServices.ConferenceConnectionError {
    get
  }
}
public enum ConferenceConnectionError : Swift.Error, Swift.Equatable {
  case deniedForNonSbStaffUser(JazzAPI.PublicRoom)
  case unathorized
  case roomClosed
  case roomNotFound(JazzAPI.PublicRoom?)
  case rejectedDueToConnectionProblem
  case canceled
  public static func == (a: JazzServices.ConferenceConnectionError, b: JazzServices.ConferenceConnectionError) -> Swift.Bool
}
public typealias ConferenceConnectionResult<Success> = (Swift.Result<Success, JazzServices.ConferenceConnectionError>) -> Swift.Void
public protocol ConferenceDeviceCast {
  var status: DevicesCore.Property<JazzServices.ConferenceDeviceCastStatus> { get }
  var onDeviceStatusReceived: DevicesCore.Signal<(JazzServices.ConferenceDeviceCastDevice.ID, JazzServices.ConferenceDeviceCastDeviceStatus)> { get }
  var onDeeplinkStatusReceived: DevicesCore.Signal<JazzServices.ConferenceDeviceCastDeeplinkStatus> { get }
  var onError: DevicesCore.Signal<JazzServices.ConferenceDeviceCastError> { get }
  func start()
  func stop()
  func pause()
  func restart()
  func enableBLE(_ isEnabled: Swift.Bool)
  func connectToDevice(_ deviceId: JazzServices.ConferenceDeviceCastDevice.ID)
  func cancelDeviceConnectionRequest(_ deviceId: JazzServices.ConferenceDeviceCastDevice.ID)
  func confirmDeviceConnectionCode(deviceId: JazzServices.ConferenceDeviceCastDevice.ID, code: Swift.String)
  func sendDeeplink(to deviceId: JazzServices.ConferenceDeviceCastDevice.ID, link: Swift.String)
  func setBLEDeeplink(_ link: Swift.String?)
}
public enum ConferenceDeviceCastDeeplinkStatus : Swift.Equatable {
  public enum Error : Swift.Equatable {
    case bleDisabledInDeviceCast
    case bleErrorInDeviceCast
    case unsupportedDevice
    case unknownDevice
    case deviceNotConnected
    case cancelled
    case sendDirectiveError
    case parseError
    case tokenError
    case unhandled
    case unknownError
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: JazzServices.ConferenceDeviceCastDeeplinkStatus.Error, b: JazzServices.ConferenceDeviceCastDeeplinkStatus.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  case success
  case failure(JazzServices.ConferenceDeviceCastDeeplinkStatus.Error)
  public static func == (a: JazzServices.ConferenceDeviceCastDeeplinkStatus, b: JazzServices.ConferenceDeviceCastDeeplinkStatus) -> Swift.Bool
}
public struct ConferenceDeviceCastDevice : Swift.Equatable {
  public enum DeviceType : Swift.String, Swift.Equatable {
    case boxTop
    case portal
    case unknown
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let id: JazzServices.ConferenceDeviceCastDevice.ID
  public let name: JazzServices.ConferenceDeviceCastDevice.Name
  public let type: JazzServices.ConferenceDeviceCastDevice.DeviceType
  public init(id: JazzServices.ConferenceDeviceCastDevice.ID, name: JazzServices.ConferenceDeviceCastDevice.Name, type: JazzServices.ConferenceDeviceCastDevice.DeviceType)
  public static func == (a: JazzServices.ConferenceDeviceCastDevice, b: JazzServices.ConferenceDeviceCastDevice) -> Swift.Bool
}
extension JazzServices.ConferenceDeviceCastDevice {
  public typealias ID = DevicesCore.Tagged<JazzServices.ConferenceDeviceCastDevice.IDTag, Swift.String>
  public typealias Name = DevicesCore.Tagged<JazzServices.ConferenceDeviceCastDevice.NameTag, Swift.String>
  public enum IDTag {
  }
  public enum NameTag {
  }
}
extension JazzServices.ConferenceDeviceCastDevice {
  public var serialNumber: Swift.String {
    get
  }
}
public enum ConferenceDeviceCastDeviceStatus : Swift.Equatable {
  case connected
  case authorized
  case pinRequired
  case cancelRequest
  case wrongPin
  case attemptsLimitReached
  case tooManyRequests
  case error
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: JazzServices.ConferenceDeviceCastDeviceStatus, b: JazzServices.ConferenceDeviceCastDeviceStatus) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum ConferenceDeviceCastError {
  case discovery
  case backendNetwork
  case ble
  case authId
  case unknown
  public static func == (a: JazzServices.ConferenceDeviceCastError, b: JazzServices.ConferenceDeviceCastError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class ConferenceDeviceCastImpl : JazzServices.ConferenceDeviceCast {
  final public var status: DevicesCore.Property<JazzServices.ConferenceDeviceCastStatus> {
    get
  }
  final public var onDeviceStatusReceived: DevicesCore.Signal<(JazzServices.ConferenceDeviceCastDevice.ID, JazzServices.ConferenceDeviceCastDeviceStatus)> {
    get
  }
  final public var onDeeplinkStatusReceived: DevicesCore.Signal<JazzServices.ConferenceDeviceCastDeeplinkStatus> {
    get
  }
  final public var onError: DevicesCore.Signal<JazzServices.ConferenceDeviceCastError> {
    get
  }
  public init(clientName: Swift.String, deviceCast: LibSberCast.SberCast, logger: DevicesCore.Logger)
  final public func start()
  final public func pause()
  final public func stop()
  final public func restart()
  final public func enableBLE(_ isEnabled: Swift.Bool)
  final public func connectToDevice(_ deviceId: JazzServices.ConferenceDeviceCastDevice.ID)
  final public func cancelDeviceConnectionRequest(_ deviceId: JazzServices.ConferenceDeviceCastDevice.ID)
  final public func confirmDeviceConnectionCode(deviceId: JazzServices.ConferenceDeviceCastDevice.ID, code: Swift.String)
  final public func sendDeeplink(to deviceId: JazzServices.ConferenceDeviceCastDevice.ID, link: Swift.String)
  final public func setBLEDeeplink(_ link: Swift.String?)
  @objc deinit
}
extension JazzServices.ConferenceDeviceCastImpl : LibSberCast.SberCastListener {
  final public func onStatusChanged(status: LibSberCast.CastStatus)
  final public func onError(error: LibSberCast.CastError)
  final public func onDevicesChanged(_ devices: [LibSberCast.SberCastDevice])
  final public func onCastMessageResponse(message: LibSberCast.CastMessage)
  final public func onCastRequestResponse(response: LibSberCast.CastRequestResponse)
  final public func onBLEDeeplinkReceived(deeplink _: Swift.String)
  final public func onBLEDeeplinkRunInfo(_ info: LibSberCast.RunBLEDeeplinkOnDeviceInfo)
}
public enum ConferenceDeviceCastStatus : Swift.Equatable {
  case stopped
  case running
  case devicesReceived([JazzServices.ConferenceDeviceCastDevice])
  public static func == (a: JazzServices.ConferenceDeviceCastStatus, b: JazzServices.ConferenceDeviceCastStatus) -> Swift.Bool
}
extension JazzServices.ConferenceDeviceCastStatus {
  public var isRunning: Swift.Bool {
    get
  }
}
public enum ConferenceEmoji : Swift.String, Swift.Equatable, Swift.CaseIterable {
  case applause
  case like
  case dislike
  case smile
  case surprise
  public init?(rawValue: Swift.String)
  public typealias AllCases = [JazzServices.ConferenceEmoji]
  public typealias RawValue = Swift.String
  public static var allCases: [JazzServices.ConferenceEmoji] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension JazzServices.ConferenceEmoji {
  public var symbol: Swift.String {
    get
  }
}
public struct ConferenceError : DevicesCore.Deserializable, Swift.Equatable {
  public static let maxConferenceCapacityExceeded: Swift.String
  public enum ServerError : Swift.Equatable {
    case maxConferenceCapacityExceeded(maxConferenceCapacity: Swift.Int)
    case unknown
    public static func == (a: JazzServices.ConferenceError.ServerError, b: JazzServices.ConferenceError.ServerError) -> Swift.Bool
  }
  public enum ErrorType : Swift.Equatable {
    case network
    case server(JazzServices.ConferenceError.ServerError)
    case jitsi
    public static func == (a: JazzServices.ConferenceError.ErrorType, b: JazzServices.ConferenceError.ErrorType) -> Swift.Bool
  }
  public struct Params : Swift.Equatable {
    public let maxConferenceCapacity: Swift.Int?
    public static func == (a: JazzServices.ConferenceError.Params, b: JazzServices.ConferenceError.Params) -> Swift.Bool
  }
  public let type: JazzServices.ConferenceError.ErrorType
  public let message: Swift.String
  public let name: Swift.String
  public init(type: JazzServices.ConferenceError.ErrorType, message: Swift.String, name: Swift.String)
  public init(deserializer: DevicesCore.Deserializer) throws
  public static func == (a: JazzServices.ConferenceError, b: JazzServices.ConferenceError) -> Swift.Bool
}
public protocol ConferenceEventsProvider {
  var onConferenceJoined: DevicesCore.Signal<Swift.Void> { get }
  var onConferenceTerminate: DevicesCore.Signal<Swift.Void> { get }
  var onMaxParticipantsNumberReach: DevicesCore.Signal<Swift.Void> { get }
  var onKickedFromConference: DevicesCore.Signal<JazzServices.ConferenceKickReason> { get }
  var onReactionReceived: DevicesCore.Signal<JazzServices.ReactionModel> { get }
  var onError: DevicesCore.Signal<JazzServices.ConferenceError> { get }
  var onConferenceRecordingStarted: DevicesCore.Signal<Swift.Void> { get }
  var onConferenceRecordingFinished: DevicesCore.Signal<Swift.Void> { get }
  var onCallEnded: DevicesCore.Signal<Swift.Void> { get }
}
final public class ConferenceInteractorProxy {
  public init(isConferenceJoined: JazzServices.ClosurePerformer, isMountedPerformer: JazzServices.ClosurePerformer, isDataChannelOpenedPerformer: JazzServices.ClosurePerformer, isLocalVideoTrackAddedPerformer: JazzServices.ClosurePerformer, isLocalAudioTrackAddedPerformer: JazzServices.ClosurePerformer, interactor: JazzServices.ConferenceServiceInteractor, logger: DevicesCore.Logger)
  @objc deinit
}
extension JazzServices.ConferenceInteractorProxy : JazzServices.ConferenceServiceInteractor {
  final public func setRoomName(_ roomName: Swift.String)
  final public func setVideoMuted(_ isMuted: Swift.Bool, shouldChangeAudioMode: Swift.Bool)
  final public func setAudioMuted(_ isMuted: Swift.Bool)
  final public func switchCamera()
  final public func setHandRaised(_ isRaised: Swift.Bool)
  final public func setAudioDenoiserEnabled(_ isEnabled: Swift.Bool)
  final public func setAsrEnabled(_ isEnabled: Swift.Bool)
  final public func setUser(_ name: JazzAPI.Jazz.UserName)
  final public func sendEmoji(_ emoji: JazzServices.ConferenceEmoji)
  final public func sendChatMessage(_ message: JazzServices.ChatMessageModel, shouldSendMessageWithId: Swift.Bool)
  final public func requestRoomPermission(_ permission: JazzServices.ConferencePermissions.RoomPolicy)
  final public func updateVideoStream(_ endpointPayload: JazzServices.EndpointPayload)
  final public func allowParticipantToEnterFromLobby(_ participantId: JazzServices.ConferenceParticipant.ID)
  final public func rejectParticipantFromLobby(_ participantId: JazzServices.ConferenceParticipant.ID)
}
public protocol ConferenceJitsiInteractor {
  func setRoomDisplayName(_ title: Swift.String?)
  func setVideoMuted(_ muted: Swift.Bool, shouldChangeAudioMode: Swift.Bool)
  func setAudioMuted(_ muted: Swift.Bool)
  func switchCamera()
  func setHandRaised(_ raised: Swift.Bool)
  func setAudioDenoiserEnabled(_ enabled: Swift.Bool)
  func setAsrEnabled(_ isEnabled: Swift.Bool)
  func setDisplayName(_ name: Swift.String)
  func sendEmoji(_ emoji: JazzCore.JitsiReaction)
  func sendChatMessage(_ message: Swift.String, withId: Swift.String?)
  func requestRoomPermission(_ permission: Swift.String)
  func updateVideoStream(_ endpointPayload: JazzCore.JitsiEndpointPayload)
  func approveAccess(_ participantID: Swift.String)
  func denyAccess(_ participantID: Swift.String)
}
extension JazzCore.JitsiMeetView : JazzServices.ConferenceJitsiInteractor {
}
public protocol ConferenceJoiner {
  func join(mediaSettings: JazzAPI.ConferenceMediaSettings, room: JazzAPI.PrivateRoom, userName: Swift.String, title: Swift.String?, peerName: Swift.String?, isCall: Swift.Bool)
}
public enum ConferenceKickReason : Swift.String {
  case callEnded
  case beenKicked
  case maxConferenceCapacityExceeded
  case maxConferenceDurationExceeded
  case unknowned
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol ConferenceLeaver {
  func leave()
  var willLeave: DevicesCore.Signal<Swift.Void> { get }
}
public struct ConferenceLimitedDuration : Swift.Equatable {
  public let maximumDuration: Foundation.TimeInterval
  public let timeLeft: Foundation.TimeInterval
  public init(maximumDuration: Foundation.TimeInterval, timeLeft: Foundation.TimeInterval)
  public static func == (a: JazzServices.ConferenceLimitedDuration, b: JazzServices.ConferenceLimitedDuration) -> Swift.Bool
}
public struct ConferenceParticipant : DevicesCore.Deserializable, Swift.Equatable {
  public enum Role : Swift.String, Swift.Equatable {
    case moderator
    case participant
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let id: JazzServices.ConferenceParticipant.ID
  public var userID: JazzServices.ConferenceParticipant.UserID?
  public var userName: JazzServices.ConferenceParticipant.Name?
  public let isLocal: Swift.Bool
  public var role: JazzServices.ConferenceParticipant.Role?
  public var isSharingScreen: Swift.Bool
  public var isHandRaised: Swift.Bool
  public var isRecording: Swift.Bool
  public var isCloudRecording: Swift.Bool
  public var videoTrack: JazzServices.VideoTrackModel?
  public var audioTrack: JazzServices.AudioTrackModel?
  public var isGuest: Swift.Bool
  public var isSipUser: Swift.Bool
  public var hasTurnedAsrOn: Swift.Bool
  public var isVideoOn: Swift.Bool {
    get
  }
  public var isCameraOn: Swift.Bool {
    get
  }
  public var isMicOn: Swift.Bool {
    get
  }
  public var participantName: JazzServices.ConferenceParticipant.Name {
    get
  }
  public init(id: JazzServices.ConferenceParticipant.ID, userID: JazzServices.ConferenceParticipant.UserID? = nil, userName: JazzServices.ConferenceParticipant.Name?, videoTrack: JazzServices.VideoTrackModel? = nil, audioTrack: JazzServices.AudioTrackModel? = nil, isSharingScreen: Swift.Bool = false, isHandRaised: Swift.Bool = false, isRecording: Swift.Bool = false, isCloudRecording: Swift.Bool = false, isLocal: Swift.Bool = false, role: JazzServices.ConferenceParticipant.Role? = nil, isGuest: Swift.Bool = false, isSipUser: Swift.Bool = false, hasTurnedAsrOn: Swift.Bool = false)
  public static func == (a: JazzServices.ConferenceParticipant, b: JazzServices.ConferenceParticipant) -> Swift.Bool
}
extension JazzServices.ConferenceParticipant {
  public var isAdministrator: Swift.Bool {
    get
  }
}
extension JazzServices.ConferenceParticipant {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension JazzServices.ConferenceParticipant {
  public typealias ID = DevicesCore.Tagged<JazzServices.ConferenceParticipant.IDTag, Swift.String>
  public typealias UserID = DevicesCore.Tagged<JazzServices.ConferenceParticipant.UserIDTag, Swift.String>
  public typealias Name = DevicesCore.Tagged<JazzServices.ConferenceParticipant.NameTag, Swift.String>
  public enum IDTag {
  }
  public enum UserIDTag {
  }
  public enum NameTag {
  }
}
public protocol ConferenceParticipantApplyableCommand {
  func apply(to participant: inout JazzServices.ConferenceParticipant)
}
public struct ConferenceParticipantUpdate {
  public let id: JazzServices.ConferenceParticipant.ID
  public let commands: [JazzServices.ConferenceParticipantApplyableCommand]
  public init(id: JazzServices.ConferenceParticipant.ID, commands: [JazzServices.ConferenceParticipantApplyableCommand])
}
extension JazzServices.ConferenceParticipant {
  public mutating func apply(update: JazzServices.ConferenceParticipantUpdate)
}
public struct ConferenceParticipantUpdateCommand<Value> : JazzServices.ConferenceParticipantApplyableCommand {
  public init(keyPath: Swift.WritableKeyPath<JazzServices.ConferenceParticipant, Value>, newValue: Value)
  public func apply(to participant: inout JazzServices.ConferenceParticipant)
}
extension JazzServices.ConferenceParticipantUpdateCommand : Swift.Equatable where Value : Swift.Equatable {
  public static func == (a: JazzServices.ConferenceParticipantUpdateCommand<Value>, b: JazzServices.ConferenceParticipantUpdateCommand<Value>) -> Swift.Bool
}
public enum ConferencePermissions {
  public enum RoomPolicy : Swift.String {
    case canSendMessage
    case canShareAudio
    case canShareMedia
    case canShareCamera
    case canEditOwnName
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
public struct ConferencePersonCount : Swift.Equatable {
  public var participants: Swift.Int
  public var viewers: Swift.Int
  public init(participants: Swift.Int = 0, viewers: Swift.Int = 0)
  public static func == (a: JazzServices.ConferencePersonCount, b: JazzServices.ConferencePersonCount) -> Swift.Bool
}
public enum ConferencePhase {
  case inactive
  case lobby
  case activeConference
  public static func == (a: JazzServices.ConferencePhase, b: JazzServices.ConferencePhase) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ConferenceRooms {
  public let publicRoom: JazzAPI.PublicRoom
  public let privateRoom: JazzAPI.PrivateRoom
  public let keepaliveHandler: JazzServices.RoomKeepAliveHandler
  public init(publicRoom: JazzAPI.PublicRoom, privateRoom: JazzAPI.PrivateRoom, keepaliveHandler: JazzServices.RoomKeepAliveHandler)
}
extension JazzServices.ConferenceRooms : Swift.Equatable {
  public static func == (lhs: JazzServices.ConferenceRooms, rhs: JazzServices.ConferenceRooms) -> Swift.Bool
}
extension JazzServices.ConferenceRooms : DevicesCore.PrettyStringConvertible {
  public func makePrettyDescription(additionalOffset: Swift.String?) -> Swift.String
}
public protocol ConferenceServiceInteractor {
  func setRoomName(_ roomName: Swift.String)
  func setVideoMuted(_ isMuted: Swift.Bool, shouldChangeAudioMode: Swift.Bool)
  func setAudioMuted(_ isMuted: Swift.Bool)
  func setAudioDenoiserEnabled(_ isEnabled: Swift.Bool)
  func setAsrEnabled(_ isEnabled: Swift.Bool)
  func setUser(_ name: JazzAPI.Jazz.UserName)
  func sendChatMessage(_ message: JazzServices.ChatMessageModel, shouldSendMessageWithId: Swift.Bool)
  func requestRoomPermission(_ permission: JazzServices.ConferencePermissions.RoomPolicy)
  func updateVideoStream(_ endpointPayload: JazzServices.EndpointPayload)
  func switchCamera()
  func setHandRaised(_ isRaised: Swift.Bool)
  func sendEmoji(_ emoji: JazzServices.ConferenceEmoji)
  func allowParticipantToEnterFromLobby(_ participantId: JazzServices.ConferenceParticipant.ID)
  func rejectParticipantFromLobby(_ participantId: JazzServices.ConferenceParticipant.ID)
}
final public class ConferenceServiceInteractorImpl : JazzServices.ConferenceServiceInteractor {
  public init(conferenceJitsiInteractor: JazzServices.ConferenceJitsiInteractor, logger: DevicesCore.Logger)
  final public func setRoomName(_ roomName: Swift.String)
  final public func setVideoMuted(_ isMuted: Swift.Bool, shouldChangeAudioMode: Swift.Bool)
  final public func setAudioMuted(_ isMuted: Swift.Bool)
  final public func switchCamera()
  final public func setHandRaised(_ isRaised: Swift.Bool)
  final public func setAudioDenoiserEnabled(_ isEnabled: Swift.Bool)
  final public func setAsrEnabled(_ isEnabled: Swift.Bool)
  final public func setUser(_ name: JazzAPI.Jazz.UserName)
  final public func sendEmoji(_ emoji: JazzServices.ConferenceEmoji)
  final public func sendChatMessage(_ message: JazzServices.ChatMessageModel, shouldSendMessageWithId: Swift.Bool)
  final public func requestRoomPermission(_ permission: JazzServices.ConferencePermissions.RoomPolicy)
  final public func updateVideoStream(_ endpointPayload: JazzServices.EndpointPayload)
  final public func allowParticipantToEnterFromLobby(_ participantId: JazzServices.ConferenceParticipant.ID)
  final public func rejectParticipantFromLobby(_ participantId: JazzServices.ConferenceParticipant.ID)
  @objc deinit
}
public typealias ConferenceSettings = [JazzServices.ConferenceSetting : Any]
public enum ConferenceSetting : Swift.String {
  case addPeopleEnabled
  case audioFocusDisabled
  case audioMuteEnabled
  case audioOnlyEnabled
  case calendarEnabled
  case callIntegrationEnabled
  case closeCaptionsEnabled
  case conferenceTimerEnabled
  case chatEnabled
  case filmStripEnabled
  case fullscreenEnabled
  case helpEnabled
  case inviteEnabled
  case iosRecordingEnabled
  case iosScreensharingEnabled
  case kickOutEnabled
  case notificationsEnabled
  case overflowMenuEnabled
  case liveStreamingEnabled
  case lobbyEnabled
  case meetingNameEnabled
  case pipEnabled
  case raiseHandEnabled
  case recordingEnabled
  case serverUrlChangeEnabled
  case tileViewEnabled
  case toolboxAlwaysVisible
  case toolboxEnabled
  case videoMuteEnabled
  case videoShareEnabled
  case welcomepageEnabled
  case muteByLastNEndpointsEnabled
  case jsonChatEnabled
  case webinarEnabled
  public static var defaults: JazzServices.ConferenceSettings
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension JazzCore.JitsiMeetConferenceOptionsBuilder {
  public func setSetting(_ setting: JazzServices.ConferenceSetting, value: Any)
  public func setSettings(_ settings: JazzServices.ConferenceSettings)
}
public protocol ConferenceState : JazzServices.ConferenceBaseState {
  var isCameraOn: DevicesCore.Property<Swift.Bool> { get }
  var isMicrophoneOn: DevicesCore.Property<Swift.Bool> { get }
  var roomId: DevicesCore.Property<Swift.String> { get }
  var localParticipant: DevicesCore.Property<JazzServices.ConferenceParticipant> { get }
  var lobbyParticipants: DevicesCore.Property<[JazzServices.ConferenceParticipant]> { get }
  var onRemoteParticipantJoined: DevicesCore.Signal<JazzServices.ConferenceParticipant> { get }
  var onRemoteParticipantLeft: DevicesCore.Signal<JazzServices.ConferenceParticipant.ID> { get }
  var onRemoteParticipantUpdate: DevicesCore.Signal<JazzServices.ConferenceParticipantUpdate> { get }
  var conferenceLimitedDuration: DevicesCore.Property<JazzServices.ConferenceLimitedDuration?> { get }
  var onChatMessageStatusReceived: DevicesCore.Signal<(JazzServices.ChatMessageModel.ID, JazzServices.ChatMessageModel.Status)> { get }
  var personCountUpdated: DevicesCore.Signal<JazzServices.ConferencePersonCount> { get }
}
@objc final public class ConferenceStateImpl : ObjectiveC.NSObject, JazzServices.ConferenceState {
  final public var phase: DevicesCore.Property<JazzServices.ConferencePhase> {
    get
  }
  final public var onXmppConnectionEstablished: DevicesCore.Signal<Foundation.TimeInterval> {
    get
  }
  final public var onIceConnectionEstablished: DevicesCore.Signal<Foundation.TimeInterval> {
    get
  }
  final public var onMediaConnectionEstablished: DevicesCore.Signal<Foundation.TimeInterval> {
    get
  }
  final public var isConferenceJoined: DevicesCore.Property<Swift.Bool> {
    get
  }
  final public var isCameraOn: DevicesCore.Property<Swift.Bool> {
    get
  }
  final public var isMicrophoneOn: DevicesCore.Property<Swift.Bool> {
    get
  }
  final public var onError: DevicesCore.Signal<JazzServices.ConferenceError> {
    get
  }
  final public var onReactionReceived: DevicesCore.Signal<JazzServices.ReactionModel> {
    get
  }
  final public var watermarkText: DevicesCore.Property<Swift.String> {
    get
  }
  final public var onLobbyJoined: DevicesCore.Signal<Swift.Void> {
    get
  }
  final public var onLobbyAccessGranted: DevicesCore.Signal<Swift.Void> {
    get
  }
  final public var onLobbyAccessDenied: DevicesCore.Signal<Swift.Void> {
    get
  }
  final public var onInitialParticipantsCount: DevicesCore.Signal<Swift.Int> {
    get
  }
  final public var onShouldDisableCamera: DevicesCore.Signal<Swift.Void> {
    get
  }
  final public var onShouldDisableScreenShare: DevicesCore.Signal<Swift.Void> {
    get
  }
  final public var onShouldDisableMicrophone: DevicesCore.Signal<Swift.Void> {
    get
  }
  final public var roomId: DevicesCore.Property<Swift.String> {
    get
  }
  final public var localParticipant: DevicesCore.Property<JazzServices.ConferenceParticipant> {
    get
  }
  final public var onRemoteParticipantJoined: DevicesCore.Signal<JazzServices.ConferenceParticipant> {
    get
  }
  final public var onRemoteParticipantLeft: DevicesCore.Signal<JazzServices.ConferenceParticipant.ID> {
    get
  }
  final public var onRemoteParticipantUpdate: DevicesCore.Signal<JazzServices.ConferenceParticipantUpdate> {
    get
  }
  final public var lobbyParticipants: DevicesCore.Property<[JazzServices.ConferenceParticipant]> {
    get
  }
  final public var dominantSpeakerChanged: DevicesCore.Signal<JazzServices.ConferenceParticipant.ID> {
    get
  }
  final public var onConferenceTerminate: DevicesCore.Signal<Swift.Void> {
    get
  }
  final public var onConferenceJoined: DevicesCore.Signal<Swift.Void> {
    get
  }
  final public var onMaxParticipantsNumberReach: DevicesCore.Signal<Swift.Void> {
    get
  }
  final public var onNativeControlsVisibilityToggle: DevicesCore.Signal<Swift.Bool> {
    get
  }
  final public var onParticipantPin: DevicesCore.Signal<Swift.Void> {
    get
  }
  final public var isMounted: DevicesCore.Property<Swift.Bool> {
    get
  }
  final public var onKickedFromConference: DevicesCore.Signal<JazzServices.ConferenceKickReason> {
    get
  }
  final public var onConferenceRecordingStarted: DevicesCore.Signal<Swift.Void> {
    get
  }
  final public var onConferenceRecordingFinished: DevicesCore.Signal<Swift.Void> {
    get
  }
  final public var onChatMessageReceived: DevicesCore.Signal<JazzServices.ChatMessageModel> {
    get
  }
  final public var isDataChannelOpened: DevicesCore.Property<Swift.Bool> {
    get
  }
  final public var onRoomPolicyUpdated: DevicesCore.Signal<JazzAPI.PrivateRoom.RoomPolicy> {
    get
  }
  final public var onRoomSettingsUpdated: DevicesCore.Signal<JazzServices.RoomSettingsUpdate> {
    get
  }
  final public var onCanShareAudioGranted: DevicesCore.Signal<Swift.Bool> {
    get
  }
  final public var onCanShareVideoGranted: DevicesCore.Signal<Swift.Bool> {
    get
  }
  final public var onCanShareScreenGranted: DevicesCore.Signal<Swift.Bool> {
    get
  }
  final public var onCanSendMessageGranted: DevicesCore.Signal<Swift.Bool> {
    get
  }
  final public var onCanEditOwnNameGranted: DevicesCore.Signal<Swift.Bool> {
    get
  }
  final public var conferenceLimitedDuration: DevicesCore.Property<JazzServices.ConferenceLimitedDuration?> {
    get
  }
  final public var isAsrEnabled: DevicesCore.Property<Swift.Bool> {
    get
  }
  final public var onChatMessageStatusReceived: DevicesCore.Signal<(JazzServices.ChatMessageModel.ID, JazzServices.ChatMessageModel.Status)> {
    get
  }
  final public var webinarStarted: DevicesCore.Signal<JazzServices.WebinarBroadcastInfo> {
    get
  }
  final public var personCountUpdated: DevicesCore.Signal<JazzServices.ConferencePersonCount> {
    get
  }
  final public var onServerVideoRecordStarted: DevicesCore.Signal<JazzServices.ConferenceParticipant.UserID?> {
    get
  }
  final public var onServerVideoRecordStopped: DevicesCore.Signal<JazzServices.ServerVideoRecordStopReason?> {
    get
  }
  final public var onServerVideoRecordAutoStartError: DevicesCore.Signal<JazzServices.ServerVideoRecordError> {
    get
  }
  final public var onCallEnded: DevicesCore.Signal<Swift.Void> {
    get
  }
  public init(logger: DevicesCore.Logger, willLeave: DevicesCore.Signal<Swift.Void>, assertQueue: @escaping DevicesCore.DispatchQueueAssert = DispatchQueue.assertOnMain)
  @objc deinit
}
extension JazzServices.ConferenceStateImpl : JazzCore.JitsiMeetViewDelegate {
  @objc final public func xmppConnectionEstablished(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func iceConnectionEstablished(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func mediaConnectionEstablished(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func setFatalError(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func watermarksTextChanged(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func conferenceJoined(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func participantIsRecording(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func conferenceTerminated(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func appWillMount(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func appWillUnmount(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func dataChannelOpened(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func maxParticipantsNumberHasBeenReached(_ data: [Swift.AnyHashable : Any]!)
  final public func enterPicture(inPicture data: [Swift.AnyHashable : Any]!)
  @objc final public func setRoomId(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func participantJoined(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func participantLeft(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func displayNameChanged(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func dominantSpeakerChanged(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func mediaTrackRemoved(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func mediaTrackAdded(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func chatMessageReceived(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func chatMessageStatusReceived(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func phoneHashesReceived(_: [Swift.AnyHashable : Any])
  @objc final public func handRaisedReceived(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func participantMutedUs(_ data: [Swift.AnyHashable : Any])
  @objc final public func kickedOut(_ data: [Swift.AnyHashable : Any])
  @objc final public func reactionReceived(_ data: [Swift.AnyHashable : Any])
  @objc final public func screenShareToggled(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func userRoleChanged(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func setRoomPolicy(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func setRoomSettings(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func setUserGrantedPermission(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func audioMutedChanged(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func videoMutedChanged(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func lobbyLocalUserJoined(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func lobbyRemoteUserJoined(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func lobbyRemoteUserLeft(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func lobbyAccessGranted(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func lobbyAccessDenied(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func conferenceDurationReceived(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func asrStatusUpdated(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func asrResult(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func webinarStarted(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func participantCountUpdated(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func participantUpdated(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func asrUpdated(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func serverVideoRecordStarted(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func serverVideoRecordStopped(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func serverVideoRecordAutoStartError(_ data: [Swift.AnyHashable : Any]!)
  @objc final public func callEnded(_ data: [Swift.AnyHashable : Any]?)
}
public protocol ConferenceTerminationListener {
  func conferenceHasBeenTerminated()
}
public protocol CreateCustomConferenceService {
  @discardableResult
  func create(tokenProvider: JazzAPI.ConferenceTokenProvider?, roomProcessingService: JazzServices.PublicRoomProcessingService?, request: JazzAPI.CreateRoomParameters, completion: @escaping JazzServices.ConferenceConnectionResult<JazzServices.ConferenceRooms>) -> JazzServices.CancellableConferenceConnection
}
final public class CreateCustomConferenceServiceImpl : JazzServices.CreateCustomConferenceService {
  public init(publicRoomService: JazzServices.PublicRoomService, privateRoomService: JazzServices.PrivateRoomService, sessionSecretManager: JazzServices.SessionSecretManager)
  @discardableResult
  final public func create(tokenProvider: JazzAPI.ConferenceTokenProvider?, roomProcessingService: JazzServices.PublicRoomProcessingService?, request: JazzAPI.CreateRoomParameters, completion: @escaping JazzServices.ConferenceConnectionResult<JazzServices.ConferenceRooms>) -> JazzServices.CancellableConferenceConnection
  @objc deinit
}
public struct CreateRoomRequestParameters : DevicesCore.Serializable {
  public struct RoomSettings {
    public let title: Swift.String?
    public let lobbyEnabled: Swift.Bool
    public let autoRecordEnabled: Swift.Bool
  }
  public let kind: JazzAPI.PublicRoom.Kind
  public let authToken: Swift.String?
  public let guestEnabled: Swift.Bool
  public let roomSettings: JazzServices.CreateRoomRequestParameters.RoomSettings
  public init(kind: JazzAPI.PublicRoom.Kind, title: Swift.String? = nil, authToken: Swift.String? = nil, guestEnabled: Swift.Bool, lobbyEnabled: Swift.Bool, autoRecordEnabled: Swift.Bool = false)
  public func toJSONDictionary() -> DevicesCore.JSONDictionary
}
extension JazzServices.CreateRoomRequestParameters.RoomSettings : DevicesCore.Serializable {
  public func toJSONDictionary() -> DevicesCore.JSONDictionary
}
extension DevicesCore.DeserializationContainer {
  public func decodeJitsiBool(key: Key) throws -> Swift.Bool
  public func decodeJitsiBoolIfPresent(key: Key) throws -> Swift.Bool?
}
public struct Endpoint : Swift.Equatable {
  public enum ViewType {
    case thumbnail
    case primary
    case tile
    public static func == (a: JazzServices.Endpoint.ViewType, b: JazzServices.Endpoint.ViewType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let identifier: JazzServices.ConferenceParticipant.ID
  public let isPinned: Swift.Bool
  public let isSharingScreen: Swift.Bool
  public let viewType: JazzServices.Endpoint.ViewType
  public init(identifier: JazzServices.ConferenceParticipant.ID, isPinned: Swift.Bool, isSharingScreen: Swift.Bool, viewType: JazzServices.Endpoint.ViewType)
  public static func == (a: JazzServices.Endpoint, b: JazzServices.Endpoint) -> Swift.Bool
}
public struct EndpointPayload : Swift.Equatable {
  public enum ViewType : Swift.String, Swift.Equatable {
    case tile
    case speaker
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let endpoints: [JazzServices.Endpoint]
  public let maxHeight: Swift.Int
  public let viewType: JazzServices.EndpointPayload.ViewType
  public init(endpoints: [JazzServices.Endpoint], maxHeight: Swift.Int, viewType: JazzServices.EndpointPayload.ViewType)
  public static func == (a: JazzServices.EndpointPayload, b: JazzServices.EndpointPayload) -> Swift.Bool
}
extension DevicesCore.Tagged where Tag == DevicesCore.EntryLifetimeTag, T == Swift.Double {
  public init(hours: Swift.Double)
}
extension JazzServices.FastOrderedDictionary : Swift.Collection {
  public typealias Index = Swift.Int
  public typealias Element = (key: Key, value: Value)
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public func index(after i: Swift.Int) -> Swift.Int
  public subscript(index: Swift.Int) -> JazzServices.FastOrderedDictionary<Key, Value>.Element {
    get
  }
  public typealias Indices = Swift.DefaultIndices<JazzServices.FastOrderedDictionary<Key, Value>>
  public typealias Iterator = Swift.IndexingIterator<JazzServices.FastOrderedDictionary<Key, Value>>
  public typealias SubSequence = Swift.Slice<JazzServices.FastOrderedDictionary<Key, Value>>
}
extension JazzServices.FastOrderedDictionary : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Key, Value)...)
}
public struct FastOrderedDictionary<Key, Value> where Key : Swift.Hashable {
  public var keys: [Key] {
    get
  }
  public var values: [Key : Value] {
    get
  }
  public init()
  public subscript(key: Key) -> Value? {
    get
    set
  }
  public mutating func insert(value: Value, forKey key: Key)
  public mutating func insert(value: Value, forKey key: Key, at index: Swift.Int)
  public mutating func removeValue(forKey key: Key)
}
final public class InstantClosurePerformer : JazzServices.ClosurePerformer {
  public init()
  final public func enqueue(label _: Swift.String?, _ closure: @escaping () -> Swift.Void)
  final public func clear()
  @objc deinit
}
public struct JazzConfig : Swift.Equatable, DevicesCore.Deserializable {
  public let jazzServicesRemoteData: JazzServices.JazzServicesRemoteData
  public init(deserializer: DevicesCore.Deserializer) throws
  public static func == (a: JazzServices.JazzConfig, b: JazzServices.JazzConfig) -> Swift.Bool
}
final public class JazzJitsiLogger : JazzCore.JitsiCustomLogger {
  public init(logger: DevicesCore.Logger, logLevel: DevicesCore.LogLevel)
  @objc final public func logInfo(_ msg: Swift.String)
  @objc final public func logWarn(_ msg: Swift.String)
  @objc final public func logDebug(_ msg: Swift.String)
  @objc final public func logError(_ msg: Swift.String)
  @objc deinit
}
public struct JazzMeta : DevicesCore.Serializable, DevicesCore.Deserializable, Swift.Equatable {
  public let clientId: Swift.String?
  public let conferenceId: Swift.String?
  public let surface: Swift.String?
  public let platform: Swift.String?
  public let roomId: Swift.String?
  public let userId: Swift.String?
  public let email: Swift.String?
  public let version: Swift.String?
  public let os: Swift.String?
  public let conferenceType: Swift.String?
  public let userRole: Swift.String?
  public let bundleId: Swift.String
  public init(clientId: Swift.String?, conferenceId: Swift.String?, surface: Swift.String?, platform: Swift.String?, roomId: Swift.String?, userId: Swift.String?, email: Swift.String?, version: Swift.String?, os: Swift.String?, conferenceType: Swift.String?, userRole: Swift.String?, bundleId: Swift.String)
  public init(deserializer: DevicesCore.Deserializer) throws
  public func toJSONDictionary() -> DevicesCore.JSONDictionary
  public static func == (a: JazzServices.JazzMeta, b: JazzServices.JazzMeta) -> Swift.Bool
}
public protocol JazzMetaProvider : AnyObject {
  var logMeta: DevicesCore.Property<JazzServices.JazzMeta?> { get }
}
public struct JazzServicesRemoteData : Swift.Equatable, DevicesCore.Deserializable {
  public let url: JazzAPI.BackendHost
  public init(deserializer: DevicesCore.Deserializer) throws
  public static func == (a: JazzServices.JazzServicesRemoteData, b: JazzServices.JazzServicesRemoteData) -> Swift.Bool
}
public protocol JitsiConferenceConnectionController {
  func join(_ options: JazzCore.JitsiMeetConferenceOptions?)
  func leave()
}
extension JazzCore.JitsiMeetView : JazzServices.JitsiConferenceConnectionController {
}
public typealias KeepAliveRequestPerformer = DevicesCore.RequestPerformer<Swift.Void, Swift.Void>
extension DevicesCore.RequestPerformer where Request == (), Response == () {
  public static func makeKeepAliveRequestPerformer(backendURL: JazzAPI.BackendURL, roomID: JazzAPI.PublicRoom.ID, urlRequestPerformer: DevicesCore.URLRequestPerformer, logger: DevicesCore.Logger) -> JazzServices.KeepAliveRequestPerformer
}
public struct KickSelfParameters {
}
public typealias KickSelfPerformer = DevicesCore.RequestPerformer<(JazzAPI.BackendURL, JazzServices.KickSelfParameters), Swift.Void>
extension DevicesCore.RequestPerformer where Request == (JazzAPI.BackendURL, JazzServices.KickSelfParameters), Response == () {
  public static func make(urlRequestPerformer: DevicesCore.URLRequestPerformer, logger: DevicesCore.Logger, assertionCaller: DevicesCore.AssertionCaller) -> JazzServices.KickSelfPerformer
}
public struct LogsRequest : Swift.Equatable {
  public let logsUrl: Foundation.URL
  public init(logsUrl: Foundation.URL)
  public static func == (a: JazzServices.LogsRequest, b: JazzServices.LogsRequest) -> Swift.Bool
}
extension JazzServices.LogsRequest : DevicesCore.MultipartFormEncodable {
  public func encodeMultipartForm(into encoder: DevicesCore.MultipartFormEncoder) throws
}
public typealias LogsRequestPerformer = DevicesCore.RequestPerformer<(JazzAPI.BackendURL, JazzServices.LogsRequest), Swift.Void>
extension DevicesCore.RequestPerformer where Request == (JazzAPI.BackendURL, JazzServices.LogsRequest), Response == () {
  public static func make(urlRequestPerformer: DevicesCore.URLRequestPerformer, builder: DevicesCore.RequestBuilder<(JazzAPI.BackendURL, JazzServices.LogsRequest)>, logger: DevicesCore.Logger, assertionCaller: DevicesCore.AssertionCaller) -> JazzServices.LogsRequestPerformer
}
extension DevicesCore.RequestPerformer where Request == (JazzAPI.BackendURL, JazzServices.LogsRequest), Response == () {
  @_inheritsConvenienceInitializers public class LogsRequestBuilder : DevicesCore.RequestBuilder<Request> {
    override public func build(_ parameters: Request, cancelToken: DevicesCore.CancellationToken?, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
    override public init()
    @objc deinit
  }
}
public protocol MediaStreamController {
  func retrieveVideoTrack(_ reactTag: Swift.String, completion: @escaping (WebRTC.RTCVideoTrack?) -> Swift.Void)
  func execute(onMediaQueue action: @escaping () -> Swift.Void)
}
extension JazzCore.WebRTCModuleWrapper : JazzServices.MediaStreamController {
}
public enum MeetingVideoRecordError : Swift.Error {
  case forbidden
  case notEnoughSpace
  public static func == (a: JazzServices.MeetingVideoRecordError, b: JazzServices.MeetingVideoRecordError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol MeetingVideoRecordService {
  func toggleServerRecord(isRecording: Swift.Bool, for room: JazzAPI.PublicRoom, cancelToken: DevicesCore.CancellationToken?, with completion: @escaping (Swift.Result<Swift.Void, JazzServices.MeetingVideoRecordError>) -> Swift.Void)
}
final public class MeetingVideoRecordServiceImpl {
  public init(startRecordPerformer: JazzServices.MeetingVideoRecordStartPerformer, stopRecordPerformer: JazzServices.MeetingVideoRecordStopPerformer, backendURLResolver: JazzServices.BackendURLResolver, tokenProvider: JazzAPI.ConferenceTokenProvider?)
  @objc deinit
}
extension JazzServices.MeetingVideoRecordServiceImpl : JazzServices.MeetingVideoRecordService {
  final public func toggleServerRecord(isRecording: Swift.Bool, for room: JazzAPI.PublicRoom, cancelToken: DevicesCore.CancellationToken?, with completion: @escaping (Swift.Result<Swift.Void, JazzServices.MeetingVideoRecordError>) -> Swift.Void)
}
public struct MeetingVideoRecordStartParameters : DevicesCore.Serializable, Swift.Equatable {
  public func toJSONDictionary() -> DevicesCore.JSONDictionary
  public static func == (a: JazzServices.MeetingVideoRecordStartParameters, b: JazzServices.MeetingVideoRecordStartParameters) -> Swift.Bool
}
public typealias MeetingVideoRecordStartPerformer = DevicesCore.RequestPerformer<(JazzAPI.BackendURL, JazzServices.MeetingVideoRecordStartParameters), Swift.Void>
extension DevicesCore.RequestPerformer where Request == (JazzAPI.BackendURL, JazzServices.MeetingVideoRecordStartParameters), Response == () {
  public static func make(urlRequestPerformer: DevicesCore.URLRequestPerformer, logger: DevicesCore.Logger, assertionCaller: DevicesCore.AssertionCaller) -> JazzServices.MeetingVideoRecordStartPerformer
}
public struct MeetingVideoRecordStopParameters : DevicesCore.Serializable, Swift.Equatable {
  public func toJSONDictionary() -> DevicesCore.JSONDictionary
  public static func == (a: JazzServices.MeetingVideoRecordStopParameters, b: JazzServices.MeetingVideoRecordStopParameters) -> Swift.Bool
}
public typealias MeetingVideoRecordStopPerformer = DevicesCore.RequestPerformer<(JazzAPI.BackendURL, JazzServices.MeetingVideoRecordStopParameters), Swift.Void>
extension DevicesCore.RequestPerformer where Request == (JazzAPI.BackendURL, JazzServices.MeetingVideoRecordStopParameters), Response == () {
  public static func make(urlRequestPerformer: DevicesCore.URLRequestPerformer, logger: DevicesCore.Logger, assertionCaller: DevicesCore.AssertionCaller) -> JazzServices.MeetingVideoRecordStopPerformer
}
final public class ModelBasedRequestBuilder<Model> : DevicesCore.RequestBuilder<Model> {
  public typealias SyncProvider<Result> = (Model) -> Result
  public typealias AsyncProvider<Result> = (Model, @escaping (Result) -> Swift.Void) -> Swift.Void
  public enum Provider<Result> {
    case sync(JazzServices.ModelBasedRequestBuilder<Model>.SyncProvider<Result>)
    case async(JazzServices.ModelBasedRequestBuilder<Model>.AsyncProvider<Result>)
  }
  public init(urlProvider: JazzServices.ModelBasedRequestBuilder<Model>.Provider<Foundation.URL>, methodProvider: JazzServices.ModelBasedRequestBuilder<Model>.Provider<DevicesCore.HTTPMethod>, headerBuilderProvider: JazzServices.ModelBasedRequestBuilder<Model>.Provider<DevicesCore.HeaderBuilder>)
  convenience public init(urlProvider: JazzServices.ModelBasedRequestBuilder<Model>.Provider<Foundation.URL>, method: DevicesCore.HTTPMethod, headerBuilder: DevicesCore.HeaderBuilder)
  override final public func build(_ request: Model, cancelToken: DevicesCore.CancellationToken?, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public enum PasswordCoders {
  public static func `default`() -> JazzAPI.PasswordCoder
}
public protocol PrivateRoomService {
  func getPrivateRoom(cancelToken: DevicesCore.CancellationToken?, tokenProvider: JazzAPI.ConferenceTokenProvider?, room: JazzAPI.PublicRoom, shouldRetryOnConnectionError: Swift.Bool, completion: @escaping JazzServices.ConferenceConnectionResult<JazzServices.ConferenceRooms>)
}
final public class PrivateRoomServiceImpl : JazzServices.PrivateRoomService {
  public init(urlRequestPerformer: DevicesCore.URLRequestPerformer, backendURLResolver: JazzServices.BackendURLResolver, errorConverter: JazzServices.RequestErrorConverter, logger: DevicesCore.Logger, assertionCaller: DevicesCore.AssertionCaller, sessionSecretManager: JazzServices.SessionSecretManager, timerScheduler: DevicesCore.TimerScheduler = SystemTimerScheduler())
  final public func getPrivateRoom(cancelToken: DevicesCore.CancellationToken?, tokenProvider: JazzAPI.ConferenceTokenProvider?, room: JazzAPI.PublicRoom, shouldRetryOnConnectionError: Swift.Bool, completion: @escaping JazzServices.ConferenceConnectionResult<JazzServices.ConferenceRooms>)
  @objc deinit
}
public struct PrivateRoomServiceParameters : Swift.Equatable {
  public let publicRoomID: JazzAPI.PublicRoom.ID
  public let publicRoomPassword: JazzAPI.Jazz.DecodedPassword
  public let authToken: Swift.String?
  public let host: JazzAPI.JazzHost?
  public init(publicRoomID: JazzAPI.PublicRoom.ID, publicRoomPassword: JazzAPI.Jazz.DecodedPassword, authToken: Swift.String?, host: JazzAPI.JazzHost?)
  public init(room: JazzAPI.PublicRoom, authToken: Swift.String?)
  public static func == (a: JazzServices.PrivateRoomServiceParameters, b: JazzServices.PrivateRoomServiceParameters) -> Swift.Bool
}
extension JazzAPI.PublicRoom {
  public init(meta: JazzServices.PublicRoomMeta, coder: JazzAPI.PasswordCoder)
}
public struct PublicRoomMeta : DevicesCore.Deserializable {
  public let id: Swift.String
  public let url: Foundation.URL?
  public let decodedPassword: JazzAPI.Jazz.DecodedPassword
  public init(deserializer: DevicesCore.Deserializer) throws
}
public protocol PublicRoomProcessingService {
  func process(room: JazzAPI.PublicRoom, completion: @escaping JazzServices.ConferenceConnectionResult<JazzAPI.PublicRoom>)
}
public protocol PublicRoomService {
  func createPublicRoom(cancelToken: DevicesCore.CancellationToken?, tokenProvider: JazzAPI.ConferenceTokenProvider?, parameters: JazzAPI.CreateRoomParameters, completion: @escaping JazzServices.ConferenceConnectionResult<JazzAPI.PublicRoom>)
}
final public class PublicRoomServiceImpl : JazzServices.PublicRoomService {
  public enum ParsingError : Swift.Error {
    case invalidPassword
    public static func == (a: JazzServices.PublicRoomServiceImpl.ParsingError, b: JazzServices.PublicRoomServiceImpl.ParsingError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(backendURLResolver: JazzServices.BackendURLResolver, urlRequestPerformer: DevicesCore.URLRequestPerformer, errorConverter: JazzServices.RequestErrorConverter, passwordCoder: JazzAPI.PasswordCoder, logger: DevicesCore.Logger, assertionCaller: DevicesCore.AssertionCaller, onRoomCreate: ((JazzAPI.PublicRoom) -> Swift.Void)?)
  final public func createPublicRoom(cancelToken: DevicesCore.CancellationToken?, tokenProvider: JazzAPI.ConferenceTokenProvider?, parameters: JazzAPI.CreateRoomParameters, completion: @escaping JazzServices.ConferenceConnectionResult<JazzAPI.PublicRoom>)
  @objc deinit
}
public protocol RTCAudioSessionProtocol {
  func lockForConfiguration()
  func unlockForConfiguration()
  func setConfiguration(_ configuration: WebRTC.RTCAudioSessionConfiguration) throws
  func overrideOutputAudioPort(_ portOverride: AVFAudio.AVAudioSession.PortOverride) throws
  func add(_ delegate: WebRTC.RTCAudioSessionDelegate)
  func remove(_ delegate: WebRTC.RTCAudioSessionDelegate)
}
extension WebRTC.RTCAudioSession : JazzServices.RTCAudioSessionProtocol {
}
final public class RawStringRequestParser : DevicesCore.RequestParser<Swift.String> {
  public enum ParseError : Swift.Error {
    case failedToDecode(Swift.String)
  }
  public init(encoding: Swift.String.Encoding)
  override final public func parse(_ urlAnswer: DevicesCore.URLAnswer, cancelToken: DevicesCore.CancellationToken?, completion: @escaping (Swift.Result<Swift.String, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public struct ReactionModel : DevicesCore.Deserializable, Swift.Equatable {
  public var value: JazzServices.ReactionModel.Value
  public var participantId: Swift.String
  public init(deserializer: DevicesCore.Deserializer) throws
  public init(value: JazzServices.ReactionModel.Value, participantId: Swift.String)
  public static func == (a: JazzServices.ReactionModel, b: JazzServices.ReactionModel) -> Swift.Bool
}
extension JazzServices.ReactionModel {
  public typealias Value = DevicesCore.Tagged<JazzServices.ReactionModel.ValueTag, Swift.String>
  public enum ValueTag {
  }
}
final public class RemoteBackendURLResolver : JazzServices.BackendURLResolver {
  public init(cache: DevicesCore.Cache<Swift.String, JazzServices.JazzConfig> = Cache(entryLifetime: EntryLifetime(hours: 2)), backendURLResolverRequestPerformer: JazzServices.BackendURLResolverRequestPerformer, defaultConnectionHost: DevicesCore.Property<JazzAPI.JazzHost>, logger: DevicesCore.Logger)
  final public func resolve(host: JazzAPI.JazzHost?, completion: @escaping (Swift.Result<JazzAPI.BackendURL, DevicesCore.RequestError>) -> Swift.Void)
  @objc deinit
}
public protocol RequestErrorConverter {
  func convert(room: JazzAPI.PublicRoom?, error: DevicesCore.RequestError) -> JazzServices.ConferenceConnectionError
}
final public class RequestErrorConverterImpl : JazzServices.RequestErrorConverter {
  public init()
  final public func convert(room: JazzAPI.PublicRoom?, error: DevicesCore.RequestError) -> JazzServices.ConferenceConnectionError
  @objc deinit
}
extension DevicesCore.RequestPerformer {
  public func retryingOnServerErrors(maxRetriesCount: Swift.Int = 3, logger: DevicesCore.Logger, assertionCaller: DevicesCore.AssertionCaller) -> DevicesCore.RequestPerformer<Request, Response>
}
public protocol RoomKeepAliveHandler {
  func dispose()
}
public struct RoomSettingsUpdate : Swift.Equatable {
  public let title: Swift.String?
  public let isWatermarkEnabled: Swift.Bool?
  public let isLobbyEnabled: Swift.Bool?
  public let isGuestEnabled: Swift.Bool?
  public let isSipEnabled: Swift.Bool?
  public let isAsrEnabled: Swift.Bool?
  public let isJsonChatEnabled: Swift.Bool?
  public static func == (a: JazzServices.RoomSettingsUpdate, b: JazzServices.RoomSettingsUpdate) -> Swift.Bool
}
extension JazzServices.RoomSettingsUpdate : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension Swift.Sequence where Self.Element : Swift.Equatable {
  public func removing(_ element: Self.Element) -> [Self.Element]
}
extension Swift.Sequence {
  public func removing<Parameter>(_ keyPath: Swift.KeyPath<Self.Element, Parameter>, for element: Self.Element) -> [Self.Element] where Parameter : Swift.Equatable
}
public enum ServerVideoRecordError : Swift.String {
  case hasNoPermission
  case storageSizeExceeded
  case internalError
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension JazzServices.ServerVideoRecordError {
  public init(value: Swift.String?)
}
public enum ServerVideoRecordStopReason : Swift.String {
  case durationLimit
  case memoryLimit
  case error
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol SessionSecretManager {
  func updateSessionSecret(from conferenceRoom: JazzServices.ConferenceRooms, completion: @escaping () -> Swift.Void)
}
final public class SessionSecretManagerImpl : JazzServices.SessionSecretManager {
  public init(storage: JazzServices.SessionSecretStorage, kickSelfPerformer: JazzServices.KickSelfPerformer, backendResolver: JazzServices.BackendURLResolver)
  final public func updateSessionSecret(from conferenceRoom: JazzServices.ConferenceRooms, completion: @escaping () -> Swift.Void)
  @objc deinit
}
public protocol SessionSecretStorage {
  func sessionSecret(for roomID: JazzAPI.PrivateRoom.ID) -> JazzAPI.SessionSecret?
  func saveSessionSecret(from room: JazzAPI.PrivateRoom)
}
final public class SessionSecretStorageImpl {
  public init(storage: DevicesCore.KeyValueStorage)
  @objc deinit
}
extension JazzServices.SessionSecretStorageImpl : JazzServices.SessionSecretStorage {
  final public func sessionSecret(for roomID: JazzAPI.PrivateRoom.ID) -> JazzAPI.SessionSecret?
  final public func saveSessionSecret(from room: JazzAPI.PrivateRoom)
}
public struct SingleAnalyticsEventParameters : DevicesCore.Serializable {
  public let event: DevicesCore.AnalyticsEvent
  public let date: Foundation.TimeInterval
  public let meta: JazzServices.JazzMeta?
  public init(event: DevicesCore.AnalyticsEvent, date: Foundation.TimeInterval, meta: JazzServices.JazzMeta?)
  public func toJSONDictionary() -> DevicesCore.JSONDictionary
}
public struct SipData : Swift.Equatable {
  public let sipNumber: Swift.String
  public let sipPin: Swift.String?
  public let sipExpiration: Foundation.Date
  public let externalPhoneNumber: Swift.String?
  public init(sipNumber: Swift.String, sipPin: Swift.String?, sipExpiration: Foundation.Date, externalPhoneNumber: Swift.String?)
  public static func == (a: JazzServices.SipData, b: JazzServices.SipData) -> Swift.Bool
}
extension JazzServices.SipData : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
public struct SipRequestParameters : DevicesCore.Serializable, Swift.Equatable {
  public let room: JazzAPI.PublicRoom
  public init(room: JazzAPI.PublicRoom)
  public func toJSONDictionary() -> DevicesCore.JSONDictionary
  public static func == (a: JazzServices.SipRequestParameters, b: JazzServices.SipRequestParameters) -> Swift.Bool
}
public typealias SipRequestPerformer = DevicesCore.RequestPerformer<(JazzAPI.BackendURL, JazzServices.SipRequestParameters), JazzServices.SipData>
extension DevicesCore.RequestPerformer where Request == (JazzAPI.BackendURL, JazzServices.SipRequestParameters), Response == JazzServices.SipData {
  public static func make(urlRequestPerformer: DevicesCore.URLRequestPerformer, logger: DevicesCore.Logger) -> JazzServices.SipRequestPerformer
}
public protocol SipService {
  func getSipData(cancelToken: DevicesCore.CancellationToken?, parameters: JazzServices.SipRequestParameters, completion: @escaping DevicesCore.ResultCompletion<JazzServices.SipData>)
}
final public class SipServiceImpl : JazzServices.SipService {
  public init(backendURLResolver: JazzServices.BackendURLResolver, urlRequestPerformer: DevicesCore.URLRequestPerformer, logger: DevicesCore.Logger)
  final public func getSipData(cancelToken: DevicesCore.CancellationToken?, parameters: JazzServices.SipRequestParameters, completion: @escaping DevicesCore.ResultCompletion<JazzServices.SipData>)
  @objc deinit
}
extension Swift.String {
  public func withPrefix(_ prefix: Swift.String) -> Swift.String
}
public typealias Surface = DevicesCore.Tagged<JazzServices.SurfaceTag, Swift.String>
public enum SurfaceTag {
}
final public class SyncClosurePublicRoomProcessingService : JazzServices.PublicRoomProcessingService {
  public init(closure: @escaping (JazzAPI.PublicRoom) -> Swift.Void)
  final public func process(room: JazzAPI.PublicRoom, completion: @escaping JazzServices.ConferenceConnectionResult<JazzAPI.PublicRoom>)
  @objc deinit
}
final public class TaggedRawStringRequestParser<Tag> : DevicesCore.RequestParser<DevicesCore.Tagged<Tag, Swift.String>> {
  public init(tag _: Tag.Type, encoding: Swift.String.Encoding)
  override final public func parse(_ urlAnswer: DevicesCore.URLAnswer, cancelToken: DevicesCore.CancellationToken?, completion: @escaping (Swift.Result<DevicesCore.Tagged<Tag, Swift.String>, Swift.Error>) -> Swift.Void)
  @objc deinit
}
extension Foundation.URL {
  public enum Scheme : Swift.String, Swift.CaseIterable {
    case http
    case https
    public init?(rawValue: Swift.String)
    public typealias AllCases = [Foundation.URL.Scheme]
    public typealias RawValue = Swift.String
    public static var allCases: [Foundation.URL.Scheme] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public func with(scheme: Foundation.URL.Scheme) -> Foundation.URL?
}
public struct VideoTrackModel : DevicesCore.Deserializable, Swift.Equatable {
  public let reactTag: JazzServices.VideoTrackModel.ReactTag?
  public let muted: Swift.Bool
  public let videoType: JazzServices.VideoTrackModel.VideoType?
  public let isMirrored: Swift.Bool
  public init(deserializer: DevicesCore.Deserializer) throws
  public init(reactTag: JazzServices.VideoTrackModel.ReactTag?, muted: Swift.Bool, videoType: JazzServices.VideoTrackModel.VideoType?, isMirrored: Swift.Bool)
  public static func == (a: JazzServices.VideoTrackModel, b: JazzServices.VideoTrackModel) -> Swift.Bool
}
extension JazzServices.VideoTrackModel {
  public typealias ReactTag = DevicesCore.Tagged<JazzServices.VideoTrackModel.ReactTagTag, Swift.String>
  public typealias VideoType = DevicesCore.Tagged<JazzServices.VideoTrackModel.VideoTypeTag, Swift.String>
  public enum ReactTagTag {
  }
  public enum VideoTypeTag {
  }
}
final public class VideoTrackRenderer {
  public init(mediaStreamRetriever: JazzServices.MediaStreamController)
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class VideoView : UIKit.UIView {
  public enum ContentMode {
    case aspectFit
    case aspectFill
    public static func == (a: JazzServices.VideoView.ContentMode, b: JazzServices.VideoView.ContentMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) public init(renderer: JazzServices.VideoTrackRenderer)
  @objc deinit
  @_Concurrency.MainActor(unsafe) final public func update(track: JazzServices.VideoTrackModel?, videoContentMode: JazzServices.VideoView.ContentMode)
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
}
extension JazzServices.VideoView : WebRTC.RTCVideoViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func videoView(_: WebRTC.RTCVideoRenderer, didChangeVideoSize size: CoreFoundation.CGSize)
}
public struct WebinarBroadcastContent : Swift.Equatable {
  public enum StreamType : Swift.String {
    case hls
    case dash
    case smoothStreaming
    case llhls
    case lldashHook
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let type: JazzServices.WebinarBroadcastContent.StreamType
  public let url: Foundation.URL
  public static func == (a: JazzServices.WebinarBroadcastContent, b: JazzServices.WebinarBroadcastContent) -> Swift.Bool
}
extension JazzServices.WebinarBroadcastContent {
  public init?(type: JazzServices.WebinarBroadcastContent.StreamType?, url: Foundation.URL?)
  public init?(streamRawValue: Swift.String?, urlString: Swift.String?)
}
public struct WebinarBroadcastInfo : Swift.Equatable {
  public let broadcasts: [JazzServices.WebinarBroadcastContent]
  public let actualStartDate: Foundation.Date
  public static func == (a: JazzServices.WebinarBroadcastInfo, b: JazzServices.WebinarBroadcastInfo) -> Swift.Bool
}
extension JazzServices.AnalyticsRequestParameters.Error : Swift.Equatable {}
extension JazzServices.AnalyticsRequestParameters.Error : Swift.Hashable {}
extension JazzServices.AsrError : Swift.Equatable {}
extension JazzServices.AsrError : Swift.Hashable {}
extension JazzServices.ChatMessageModel.MessageType : Swift.Equatable {}
extension JazzServices.ChatMessageModel.MessageType : Swift.Hashable {}
extension JazzServices.ChatMessageModel.MessageType : Swift.RawRepresentable {}
extension JazzServices.ChatMessageModel.Status : Swift.Hashable {}
extension JazzServices.ConferenceDeviceCastDeeplinkStatus.Error : Swift.Hashable {}
extension JazzServices.ConferenceDeviceCastDevice.DeviceType : Swift.Hashable {}
extension JazzServices.ConferenceDeviceCastDevice.DeviceType : Swift.RawRepresentable {}
extension JazzServices.ConferenceDeviceCastDeviceStatus : Swift.Hashable {}
extension JazzServices.ConferenceDeviceCastError : Swift.Equatable {}
extension JazzServices.ConferenceDeviceCastError : Swift.Hashable {}
extension JazzServices.ConferenceEmoji : Swift.Hashable {}
extension JazzServices.ConferenceEmoji : Swift.RawRepresentable {}
extension JazzServices.ConferenceKickReason : Swift.Equatable {}
extension JazzServices.ConferenceKickReason : Swift.Hashable {}
extension JazzServices.ConferenceKickReason : Swift.RawRepresentable {}
extension JazzServices.ConferenceParticipant.Role : Swift.Hashable {}
extension JazzServices.ConferenceParticipant.Role : Swift.RawRepresentable {}
extension JazzServices.ConferencePermissions.RoomPolicy : Swift.Equatable {}
extension JazzServices.ConferencePermissions.RoomPolicy : Swift.Hashable {}
extension JazzServices.ConferencePermissions.RoomPolicy : Swift.RawRepresentable {}
extension JazzServices.ConferencePhase : Swift.Equatable {}
extension JazzServices.ConferencePhase : Swift.Hashable {}
extension JazzServices.ConferenceSetting : Swift.Equatable {}
extension JazzServices.ConferenceSetting : Swift.Hashable {}
extension JazzServices.ConferenceSetting : Swift.RawRepresentable {}
extension JazzServices.Endpoint.ViewType : Swift.Equatable {}
extension JazzServices.Endpoint.ViewType : Swift.Hashable {}
extension JazzServices.EndpointPayload.ViewType : Swift.Hashable {}
extension JazzServices.EndpointPayload.ViewType : Swift.RawRepresentable {}
extension JazzServices.MeetingVideoRecordError : Swift.Equatable {}
extension JazzServices.MeetingVideoRecordError : Swift.Hashable {}
extension JazzServices.PublicRoomServiceImpl.ParsingError : Swift.Equatable {}
extension JazzServices.PublicRoomServiceImpl.ParsingError : Swift.Hashable {}
extension JazzServices.ServerVideoRecordError : Swift.Equatable {}
extension JazzServices.ServerVideoRecordError : Swift.Hashable {}
extension JazzServices.ServerVideoRecordError : Swift.RawRepresentable {}
extension JazzServices.ServerVideoRecordStopReason : Swift.Equatable {}
extension JazzServices.ServerVideoRecordStopReason : Swift.Hashable {}
extension JazzServices.ServerVideoRecordStopReason : Swift.RawRepresentable {}
extension Foundation.URL.Scheme : Swift.Equatable {}
extension Foundation.URL.Scheme : Swift.Hashable {}
extension Foundation.URL.Scheme : Swift.RawRepresentable {}
extension JazzServices.VideoView.ContentMode : Swift.Equatable {}
extension JazzServices.VideoView.ContentMode : Swift.Hashable {}
extension JazzServices.WebinarBroadcastContent.StreamType : Swift.Equatable {}
extension JazzServices.WebinarBroadcastContent.StreamType : Swift.Hashable {}
extension JazzServices.WebinarBroadcastContent.StreamType : Swift.RawRepresentable {}
