// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.1 (swiftlang-5.7.1.135.3 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name DevicesCore
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import AudioToolbox
import CallKit
import Combine
import CommonCrypto
import Compression
import CoreFoundation
import CoreGraphics
import CoreLocation
import CryptoKit
import Darwin
@_exported import DevicesCore
import Foundation
import LocalAuthentication
import MachO
import MessageUI
import Network
import Photos
import PushKit
import QuartzCore
import SQLite3
import Security
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
import UserNotifications
import WebKit
import _Concurrency
import _StringProcessing
import os
import os.signpost
import zlib
public struct ABTest : DevicesCore.PrettyStringConvertible {
  public let groups: [DevicesCore.ABTestGroup]
  public let segments: [DevicesCore.ABTestSegment]
  public var groupsList: Swift.String {
    get
  }
  public var segmentsList: Swift.String {
    get
  }
  public init(groups: [DevicesCore.ABTestGroup], segments: [DevicesCore.ABTestSegment])
  public func hasGroup(_ group: DevicesCore.ABTestGroup) -> Swift.Bool
  public func hasSegment(_ segment: DevicesCore.ABTestSegment) -> Swift.Bool
}
extension DevicesCore.ABTest {
  public static func groupsFromString(_ string: Swift.String) -> [DevicesCore.ABTestGroup]
  public static func segmentsFromString(_ string: Swift.String) -> [DevicesCore.ABTestSegment]
  public static func stringFromGroups(_ groups: [DevicesCore.ABTestGroup]) -> Swift.String
  public static func stringFromSegments(_ segments: [DevicesCore.ABTestSegment]) -> Swift.String
}
public typealias ABTestGroup = DevicesCore.Tagged<DevicesCore.ABTestGroupTag, Swift.String>
public enum ABTestGroupTag {
}
public typealias ABTestSegment = DevicesCore.Tagged<DevicesCore.ABTestSegmentTag, Swift.String>
public enum ABTestSegmentTag {
}
extension AVFAudio.AVAudioPCMBuffer {
  public func toAudioPayload(format: DevicesCore.AudioFormat) -> DevicesCore.AudioPayload
}
extension AVFAudio.AVAudioPCMBuffer {
  public func floatChannelData(for channel: Swift.Int) -> Swift.UnsafeBufferPointer<Swift.Float>
  convenience public init?(pcmFormat: AVFAudio.AVAudioFormat, data: Foundation.Data)
}
extension AVFAudio.AVAudioPCMBuffer {
  public var duration: Foundation.TimeInterval {
    get
  }
}
public protocol AVAudioPlayerTwin : AnyObject {
  var currentTime: Foundation.TimeInterval { get set }
  var duration: Foundation.TimeInterval { get }
  var numberOfLoops: Swift.Int { get set }
  var delegate: AVFAudio.AVAudioPlayerDelegate? { get set }
  var isPlaying: Swift.Bool { get }
  func play() -> Swift.Bool
  func pause()
  func stop()
}
extension AVFAudio.AVAudioPlayer : DevicesCore.AVAudioPlayerTwin {
}
extension AVFoundation.AVCaptureDevice : DevicesCore.CaptureDeviceTwin {
  public func makeCaptureInput() throws -> DevicesCore.CaptureInputTwin
}
extension AVFoundation.AVCaptureDeviceInput : DevicesCore.CaptureInputTwin {
}
extension AVFoundation.AVCaptureSession : DevicesCore.CaptureSessionTwin {
  public func makePreviewLayer(orientation: AVFoundation.AVCaptureVideoOrientation) -> AVFoundation.AVCaptureVideoPreviewLayer
  public func addInput(input: DevicesCore.CaptureInputTwin?)
  public func addOutput(output: AVFoundation.AVCaptureOutput?)
  public func removeAllInputs()
}
extension DevicesCore.KeychainAttributes {
  public enum Accessibility {
    case afterFirstUnlock
    case afterFirstUnlockThisDeviceOnly
    case always
    case alwaysThisDeviceOnly
    case whenUnlocked
    case whenUnlockedThisDeviceOnly
    case whenPasscodeSetThisDeviceOnly
    public static func == (a: DevicesCore.KeychainAttributes.Accessibility, b: DevicesCore.KeychainAttributes.Accessibility) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public protocol ActionQueue {
  func enqueue(_ action: @escaping () -> Swift.Void)
  func commit()
}
final public class ActionQueueImpl : DevicesCore.ActionQueue {
  public init()
  final public func enqueue(_ action: @escaping () -> Swift.Void)
  final public func commit()
  @objc deinit
}
public struct AlertAction {
  public init(handler: @escaping () -> Swift.Void, title: Swift.String)
}
public protocol AlertPresenter {
  func presentAlert(_ alert: DevicesCore.AlertScreen)
  func dismissAlert()
}
@available(*, deprecated, message: "Необходимо использовать SDNavigation.AlertPresenter")
public protocol AlertScreen : DevicesCore.ModalScreen {
}
extension DevicesCore.StagedChangeset where Collection : Swift.RangeReplaceableCollection, Collection.Element : DevicesCore.ContentEquatable, Collection.Element : DevicesCore.ContentIdentifiable {
  @inlinable public init(source: Collection, target: Collection) {
		self.init(source: source, target: target, section: 0)
	}
  @inlinable public init(source: Collection, target: Collection, section: Swift.Int) {
		let sourceElements = ContiguousArray(source)
		let targetElements = ContiguousArray(target)

		// Return empty changesets if both are empty.
		if sourceElements.isEmpty && targetElements.isEmpty {
			self.init()
			return
		}

		// Return changesets that all deletions if source is not empty and target is empty.
		if !sourceElements.isEmpty && targetElements.isEmpty {
			self.init(
				[
					Changeset(
						data: target,
						elementDeleted: sourceElements.indices.map { ElementPath(element: $0, section: section) }
					),
				]
			)
			return
		}

		// Return changesets that all insertions if source is empty and target is not empty.
		if sourceElements.isEmpty && !targetElements.isEmpty {
			self.init(
				[
					Changeset(
						data: target,
						elementInserted: targetElements.indices.map { ElementPath(element: $0, section: section) }
					),
				]
			)
			return
		}

		var firstStageElements = ContiguousArray<Collection.Element>()
		var secondStageElements = ContiguousArray<Collection.Element>()

		let result = diff(
			source: sourceElements,
			target: targetElements,
			useTargetIndexForUpdated: false,
			mapIndex: { ElementPath(element: $0, section: section) },
			updatedElementsPointer: &firstStageElements,
			notDeletedElementsPointer: &secondStageElements
		)

		var changesets = ContiguousArray<Changeset<Collection>>()

		// The 1st stage changeset.
		// - Includes:
		//   - element updates
		if !result.updated.isEmpty {
			changesets.append(
				Changeset(
					data: Collection(firstStageElements),
					elementUpdated: result.updated
				)
			)
		}

		// The 2nd stage changeset.
		// - Includes:
		//   - element deletes
		if !result.deleted.isEmpty {
			changesets.append(
				Changeset(
					data: Collection(secondStageElements),
					elementDeleted: result.deleted
				)
			)
		}

		// The 3rd stage changeset.
		// - Includes:
		//   - element inserts
		//   - element moves
		if !result.inserted.isEmpty || !result.moved.isEmpty {
			changesets.append(
				Changeset(
					data: target,
					elementInserted: result.inserted,
					elementMoved: result.moved
				)
			)
		}

		// Set the target to `data` of the last stage.
		if !changesets.isEmpty {
			let index = changesets.index(before: changesets.endIndex)
			changesets[index].data = target
		}

		self.init(changesets)
	}
}
extension DevicesCore.StagedChangeset where Collection : Swift.RangeReplaceableCollection, Collection.Element : DevicesCore.DifferentiableSection {
  @inlinable public init(source: Collection, target: Collection) {
		typealias Section = Collection.Element
		typealias SectionIdentifier = Collection.Element.DifferenceIdentifier
		typealias Element = Collection.Element.Collection.Element
		typealias ElementIdentifier = Collection.Element.Collection.Element.DifferenceIdentifier

		let sourceSections = ContiguousArray(source)
		let targetSections = ContiguousArray(target)

		let contiguousSourceSections = ContiguousArray(sourceSections.map { ContiguousArray($0.elements) })
		let contiguousTargetSections = ContiguousArray(targetSections.map { ContiguousArray($0.elements) })

		var firstStageSections = sourceSections
		var secondStageSections = ContiguousArray<Section>()
		var thirdStageSections = ContiguousArray<Section>()
		var fourthStageSections = ContiguousArray<Section>()

		var sourceElementTraces = contiguousSourceSections.map { section in
			ContiguousArray(repeating: Trace<ElementPath>(), count: section.count)
		}
		var targetElementReferences = contiguousTargetSections.map { section in
			ContiguousArray<ElementPath?>(repeating: nil, count: section.count)
		}

		let flattenSourceCount = contiguousSourceSections.reduce(into: 0) { $0 += $1.count }
		var flattenSourceIdentifiers = ContiguousArray<ElementIdentifier>()
		var flattenSourceElementPaths = ContiguousArray<ElementPath>()

		thirdStageSections.reserveCapacity(contiguousTargetSections.count)
		fourthStageSections.reserveCapacity(contiguousTargetSections.count)

		flattenSourceIdentifiers.reserveCapacity(flattenSourceCount)
		flattenSourceElementPaths.reserveCapacity(flattenSourceCount)

		// Calculate section differences.

		let sectionResult = diff(
			source: sourceSections,
			target: targetSections,
			useTargetIndexForUpdated: true,
			mapIndex: { $0 }
		)

		// Calculate element differences.

		var elementDeleted = [ElementPath]()
		var elementInserted = [ElementPath]()
		var elementUpdated = [ElementPath]()
		var elementMoved = [(source: ElementPath, target: ElementPath)]()

		for sourceSectionIndex in contiguousSourceSections.indices {
			for sourceElementIndex in contiguousSourceSections[sourceSectionIndex].indices {
				let sourceElementPath = ElementPath(element: sourceElementIndex, section: sourceSectionIndex)
				let sourceElement = contiguousSourceSections[sourceElementPath]
				flattenSourceIdentifiers.append(sourceElement.differenceIdentifier)
				flattenSourceElementPaths.append(sourceElementPath)
			}
		}

		flattenSourceIdentifiers.withUnsafeBufferPointer { bufferPointer in
			// The pointer and the table key are for optimization.
			var sourceOccurrencesTable = [TableKey<ElementIdentifier>: Occurrence](minimumCapacity: flattenSourceCount)

			// Track indices of elements found in flatten source collection into occurrences table.
			for flattenSourceIndex in flattenSourceIdentifiers.indices {
				let pointer = bufferPointer.baseAddress!.advanced(by: flattenSourceIndex)
				let key = TableKey(pointer: pointer)

				switch sourceOccurrencesTable[key] {
				case .none:
					sourceOccurrencesTable[key] = .unique(index: flattenSourceIndex)

				case let .unique(otherIndex)?:
					let reference = IndicesReference([otherIndex, flattenSourceIndex])
					sourceOccurrencesTable[key] = .duplicate(reference: reference)

				case let .duplicate(reference)?:
					reference.push(flattenSourceIndex)
				}
			}

			// Track target and source indices of the elements having same identifier.
			for targetSectionIndex in contiguousTargetSections.indices {
				let targetElements = contiguousTargetSections[targetSectionIndex]

				for targetElementIndex in targetElements.indices {
					var targetIdentifier = targetElements[targetElementIndex].differenceIdentifier
					let key = TableKey(pointer: &targetIdentifier)

					switch sourceOccurrencesTable[key] {
					case .none:
						break

					case let .unique(flattenSourceIndex)?:
						let sourceElementPath = flattenSourceElementPaths[flattenSourceIndex]
						let targetElementPath = ElementPath(element: targetElementIndex, section: targetSectionIndex)

						if case .none = sourceElementTraces[sourceElementPath].reference {
							targetElementReferences[targetElementPath] = sourceElementPath
							sourceElementTraces[sourceElementPath].reference = targetElementPath
						}

					case let .duplicate(reference)?:
						if let flattenSourceIndex = reference.next() {
							let sourceElementPath = flattenSourceElementPaths[flattenSourceIndex]
							let targetElementPath = ElementPath(element: targetElementIndex, section: targetSectionIndex)
							targetElementReferences[targetElementPath] = sourceElementPath
							sourceElementTraces[sourceElementPath].reference = targetElementPath
						}
					}
				}
			}
		}

		// Track element deletes.
		for sourceSectionIndex in contiguousSourceSections.indices {
			let sourceSection = sourceSections[sourceSectionIndex]
			let sourceElements = contiguousSourceSections[sourceSectionIndex]
			var firstStageElements = sourceElements

			// Should not track element deletes in the deleted section.
			if case .some = sectionResult.sourceTraces[sourceSectionIndex].reference {
				var offsetByDelete = 0

				var secondStageElements = ContiguousArray<Element>()

				for sourceElementIndex in sourceElements.indices {
					let sourceElementPath = ElementPath(element: sourceElementIndex, section: sourceSectionIndex)

					sourceElementTraces[sourceElementPath].deleteOffset = offsetByDelete

					// Track element deletes if target section is tracked as inserts.
					if let targetElementPath = sourceElementTraces[sourceElementPath].reference,
					   case .some = sectionResult.targetReferences[targetElementPath.section] {
						let targetElement = contiguousTargetSections[targetElementPath]
						firstStageElements[sourceElementIndex] = targetElement
						secondStageElements.append(targetElement)
						continue
					}

					elementDeleted.append(sourceElementPath)
					sourceElementTraces[sourceElementPath].isTracked = true
					offsetByDelete += 1
				}

				let secondStageSection = Section(source: sourceSection, elements: secondStageElements)
				secondStageSections.append(secondStageSection)
			}

			let firstStageSection = Section(source: sourceSection, elements: firstStageElements)
			firstStageSections[sourceSectionIndex] = firstStageSection
		}

		// Track element updates / moves / inserts.
		for targetSectionIndex in contiguousTargetSections.indices {
			// Should not track element updates / moves / inserts in the inserted section.
			guard let sourceSectionIndex = sectionResult.targetReferences[targetSectionIndex] else {
				thirdStageSections.append(targetSections[targetSectionIndex])
				fourthStageSections.append(targetSections[targetSectionIndex])
				continue
			}

			var untrackedSourceIndex: Int? = 0
			let targetElements = contiguousTargetSections[targetSectionIndex]

			let sectionDeleteOffset = sectionResult.sourceTraces[sourceSectionIndex].deleteOffset

			let thirdStageSection = secondStageSections[sourceSectionIndex - sectionDeleteOffset]
			thirdStageSections.append(thirdStageSection)

			var fourthStageElements = ContiguousArray<Element>()
			fourthStageElements.reserveCapacity(targetElements.count)

			for targetElementIndex in targetElements.indices {
				untrackedSourceIndex = untrackedSourceIndex.flatMap { index in
					sourceElementTraces[sourceSectionIndex].suffix(from: index).firstIndex { !$0.isTracked }
				}

				let targetElementPath = ElementPath(element: targetElementIndex, section: targetSectionIndex)
				let targetElement = contiguousTargetSections[targetElementPath]

				// Track element inserts if source section is tracked as deletes.
				guard let sourceElementPath = targetElementReferences[targetElementPath],
					  let movedSourceSectionIndex = sectionResult.sourceTraces[sourceElementPath.section].reference
				else {
					fourthStageElements.append(targetElement)
					elementInserted.append(targetElementPath)
					continue
				}

				sourceElementTraces[sourceElementPath].isTracked = true

				let sourceElement = contiguousSourceSections[sourceElementPath]
				fourthStageElements.append(targetElement)

				if !targetElement.isContentEqual(to: sourceElement) {
					elementUpdated.append(sourceElementPath)
				}

				if sourceElementPath.section != sourceSectionIndex || sourceElementPath.element != untrackedSourceIndex {
					let deleteOffset = sourceElementTraces[sourceElementPath].deleteOffset
					let moveSourceElementPath = ElementPath(
						element: sourceElementPath.element - deleteOffset,
						section: movedSourceSectionIndex
					)
					elementMoved.append((source: moveSourceElementPath, target: targetElementPath))
				}
			}

			let fourthStageSection = Section(source: thirdStageSection, elements: fourthStageElements)
			fourthStageSections.append(fourthStageSection)
		}

		var changesets = ContiguousArray<Changeset<Collection>>()

		// The 1st stage changeset.
		// - Includes:
		//   - element updates
		if !elementUpdated.isEmpty {
			changesets.append(
				Changeset(
					data: Collection(firstStageSections),
					elementUpdated: elementUpdated
				)
			)
		}

		// The 2nd stage changeset.
		// - Includes:
		//   - section deletes
		//   - element deletes
		if !sectionResult.deleted.isEmpty || !elementDeleted.isEmpty {
			changesets.append(
				Changeset(
					data: Collection(secondStageSections),
					sectionDeleted: sectionResult.deleted,
					elementDeleted: elementDeleted
				)
			)
		}

		// The 3rd stage changeset.
		// - Includes:
		//   - section inserts
		//   - section moves
		if !sectionResult.inserted.isEmpty || !sectionResult.moved.isEmpty {
			changesets.append(
				Changeset(
					data: Collection(thirdStageSections),
					sectionInserted: sectionResult.inserted,
					sectionMoved: sectionResult.moved
				)
			)
		}

		// The 4th stage changeset.
		// - Includes:
		//   - element inserts
		//   - element moves
		if !elementInserted.isEmpty || !elementMoved.isEmpty {
			changesets.append(
				Changeset(
					data: Collection(fourthStageSections),
					elementInserted: elementInserted,
					elementMoved: elementMoved
				)
			)
		}

		// The 5th stage changeset.
		// - Includes:
		//   - section updates
		if !sectionResult.updated.isEmpty {
			changesets.append(
				Changeset(
					data: target,
					sectionUpdated: sectionResult.updated
				)
			)
		}

		// Set the target to `data` of the last stage.
		if !changesets.isEmpty {
			let index = changesets.index(before: changesets.endIndex)
			changesets[index].data = target
		}

		self.init(changesets)
	}
}
@discardableResult
@inlinable internal func diff<E, I>(source: Swift.ContiguousArray<E>, target: Swift.ContiguousArray<E>, useTargetIndexForUpdated: Swift.Bool, mapIndex: (Swift.Int) -> I, updatedElementsPointer: Swift.UnsafeMutablePointer<Swift.ContiguousArray<E>>? = nil, notDeletedElementsPointer: Swift.UnsafeMutablePointer<Swift.ContiguousArray<E>>? = nil) -> DevicesCore.DiffResult<I> where E : DevicesCore.ContentEquatable, E : DevicesCore.ContentIdentifiable {
	var deleted = [I]()
	var inserted = [I]()
	var updated = [I]()
	var moved = [(source: I, target: I)]()

	var sourceTraces = ContiguousArray<Trace<Int>>()
	var sourceIdentifiers = ContiguousArray<E.DifferenceIdentifier>()
	var targetReferences = ContiguousArray<Int?>(repeating: nil, count: target.count)

	sourceTraces.reserveCapacity(source.count)
	sourceIdentifiers.reserveCapacity(source.count)

	for sourceElement in source {
		sourceTraces.append(Trace())
		sourceIdentifiers.append(sourceElement.differenceIdentifier)
	}

	sourceIdentifiers.withUnsafeBufferPointer { bufferPointer in
		// The pointer and the table key are for optimization.
		var sourceOccurrencesTable = [TableKey<E.DifferenceIdentifier>: Occurrence](minimumCapacity: source.count)

		// Track indices of elements found in source collection into occurrences table.
		for sourceIndex in sourceIdentifiers.indices {
			let pointer = bufferPointer.baseAddress!.advanced(by: sourceIndex)
			let key = TableKey(pointer: pointer)

			switch sourceOccurrencesTable[key] {
			case .none:
				sourceOccurrencesTable[key] = .unique(index: sourceIndex)

			case let .unique(otherIndex)?:
				let reference = IndicesReference([otherIndex, sourceIndex])
				sourceOccurrencesTable[key] = .duplicate(reference: reference)

			case let .duplicate(reference)?:
				reference.push(sourceIndex)
			}
		}

		// Track target and source indices of the elements having same identifier.
		for targetIndex in target.indices {
			var targetIdentifier = target[targetIndex].differenceIdentifier
			let key = TableKey(pointer: &targetIdentifier)

			switch sourceOccurrencesTable[key] {
			case .none:
				break

			case let .unique(sourceIndex)?:
				if case .none = sourceTraces[sourceIndex].reference {
					targetReferences[targetIndex] = sourceIndex
					sourceTraces[sourceIndex].reference = targetIndex
				}

			case let .duplicate(reference)?:
				if let sourceIndex = reference.next() {
					targetReferences[targetIndex] = sourceIndex
					sourceTraces[sourceIndex].reference = targetIndex
				}
			}
		}
	}

	var offsetByDelete = 0
	var untrackedSourceIndex: Int? = 0

	// Track deletes.
	for sourceIndex in source.indices {
		sourceTraces[sourceIndex].deleteOffset = offsetByDelete

		if let targetIndex = sourceTraces[sourceIndex].reference {
			let targetElement = target[targetIndex]
			updatedElementsPointer?.pointee.append(targetElement)
			notDeletedElementsPointer?.pointee.append(targetElement)
		} else {
			let sourceElement = source[sourceIndex]
			deleted.append(mapIndex(sourceIndex))
			sourceTraces[sourceIndex].isTracked = true
			offsetByDelete += 1
			updatedElementsPointer?.pointee.append(sourceElement)
		}
	}

	// Track updates / moves / inserts.
	for targetIndex in target.indices {
		untrackedSourceIndex = untrackedSourceIndex.flatMap { index in
			sourceTraces.suffix(from: index).firstIndex { !$0.isTracked }
		}

		if let sourceIndex = targetReferences[targetIndex] {
			sourceTraces[sourceIndex].isTracked = true

			let sourceElement = source[sourceIndex]
			let targetElement = target[targetIndex]

			if !targetElement.isContentEqual(to: sourceElement) {
				updated.append(mapIndex(useTargetIndexForUpdated ? targetIndex : sourceIndex))
			}

			if sourceIndex != untrackedSourceIndex {
				let deleteOffset = sourceTraces[sourceIndex].deleteOffset
				moved.append((source: mapIndex(sourceIndex - deleteOffset), target: mapIndex(targetIndex)))
			}
		} else {
			inserted.append(mapIndex(targetIndex))
		}
	}

	return DiffResult(
		deleted: deleted,
		inserted: inserted,
		updated: updated,
		moved: moved,
		sourceTraces: sourceTraces,
		targetReferences: targetReferences
	)
}
@usableFromInline
internal struct DiffResult<Index> {
  @usableFromInline
  internal let deleted: [Index]
  @usableFromInline
  internal let inserted: [Index]
  @usableFromInline
  internal let updated: [Index]
  @usableFromInline
  internal let moved: [(source: Index, target: Index)]
  @usableFromInline
  internal let sourceTraces: Swift.ContiguousArray<DevicesCore.Trace<Swift.Int>>
  @usableFromInline
  internal let targetReferences: Swift.ContiguousArray<Swift.Int?>
  @usableFromInline
  internal init(deleted: [Index] = [], inserted: [Index] = [], updated: [Index] = [], moved: [(source: Index, target: Index)] = [], sourceTraces: Swift.ContiguousArray<DevicesCore.Trace<Swift.Int>>, targetReferences: Swift.ContiguousArray<Swift.Int?>)
}
@usableFromInline
internal struct Trace<Index> {
  @usableFromInline
  internal var reference: Index?
  @usableFromInline
  internal var deleteOffset: Swift.Int
  @usableFromInline
  internal var isTracked: Swift.Bool
  @usableFromInline
  internal init()
}
@usableFromInline
internal enum Occurrence {
  case unique(index: Swift.Int)
  case duplicate(reference: DevicesCore.IndicesReference)
}
@usableFromInline
final internal class IndicesReference {
  @usableFromInline
  final internal var indices: Swift.ContiguousArray<Swift.Int>
  @usableFromInline
  final internal var position: Swift.Int
  @usableFromInline
  internal init(_ indices: Swift.ContiguousArray<Swift.Int>)
  @inlinable final internal func push(_ index: Swift.Int) {
		indices.append(index)
	}
  @inlinable final internal func next() -> Swift.Int? {
		guard position < indices.endIndex else {
			return nil
		}
		defer { position += 1 }
		return indices[position]
	}
  @objc @usableFromInline
  deinit
}
@usableFromInline
internal struct TableKey<T> : Swift.Hashable where T : Swift.Hashable {
  @usableFromInline
  internal let pointeeHashValue: Swift.Int
  @usableFromInline
  internal let pointer: Swift.UnsafePointer<T>
  @usableFromInline
  internal init(pointer: Swift.UnsafePointer<T>)
  @inlinable internal static func == (lhs: DevicesCore.TableKey<T>, rhs: DevicesCore.TableKey<T>) -> Swift.Bool {
		lhs.pointeeHashValue == rhs.pointeeHashValue
			&& (lhs.pointer.distance(to: rhs.pointer) == 0 || lhs.pointer.pointee == rhs.pointer.pointee)
	}
  @inlinable internal func hash(into hasher: inout Swift.Hasher) {
		hasher.combine(pointeeHashValue)
	}
  @usableFromInline
  internal var hashValue: Swift.Int {
    @usableFromInline
    get
  }
}
extension Swift.MutableCollection where Self.Element : Swift.MutableCollection, Self.Index == Swift.Int, Self.Element.Index == Swift.Int {
  @inlinable internal subscript(path: DevicesCore.ElementPath) -> Self.Element.Element {
    get { self[path.section][path.element] }
    set { self[path.section][path.element] = newValue }
  }
}
extension DevicesCore.AssertionCaller {
  public func analytics(_ analyticsService: DevicesCore.AnalyticsService) -> DevicesCore.AssertionCaller
}
public typealias AnalyticsConfigurationToken = DevicesCore.Tagged<DevicesCore.AnalyticsConfigurationTokenTag, Swift.Int>
public protocol AnalyticsConfigurator {
  func configure() -> DevicesCore.AnalyticsConfigurationToken
}
public enum AnalyticsConfigurationTokenTag {
}
public protocol AnalyticsError : Swift.Error {
  var analyticsInfo: [Swift.String : Any] { get }
}
public protocol AnalyticsEvent : DevicesCore.PrettyStringConvertible {
  var name: Swift.String { get }
  var parameters: [Swift.String : Any]? { get }
  func makePrettyDescription(additionalOffset: Swift.String?) -> Swift.String
}
extension DevicesCore.AnalyticsEvent {
  public func makePrettyDescription(additionalOffset: Swift.String?) -> Swift.String
}
public protocol AnalyticsKey : Swift.CaseIterable {
  var name: Swift.String { get }
}
extension DevicesCore.AnalyticsKey where Self : Swift.RawRepresentable, Self.RawValue == Swift.String {
  public var name: Swift.String {
    get
  }
}
public protocol AnalyticsService : AnyObject {
  func send(_ event: DevicesCore.AnalyticsEvent)
}
public class AnalyticsServiceDelayedProxy : DevicesCore.AnalyticsService {
  public init()
  public func setSubject(_ subject: DevicesCore.AnalyticsService)
  public func send(_ event: DevicesCore.AnalyticsEvent)
  @objc deinit
}
public protocol AnalyticsServicePolicy {
  func shouldSend(event: DevicesCore.AnalyticsEvent) -> Swift.Bool
}
final public class AnalyticsServiceWithPolicyDecorator : DevicesCore.AnalyticsService & DevicesCore.AnalyticsUserContainer {
  public init(analyticsService: DevicesCore.AnalyticsService & DevicesCore.AnalyticsUserContainer, policy: DevicesCore.AnalyticsServicePolicy)
  final public func send(_ event: DevicesCore.AnalyticsEvent)
  final public func set(_ value: Swift.String?, forKey key: DevicesCore.AnalyticsUserKey)
  @objc deinit
}
public protocol AnalyticsUserContainer {
  func set(_ value: Swift.String?, forKey key: DevicesCore.AnalyticsUserKey)
}
public typealias AnalyticsUserKey = DevicesCore.Tagged<DevicesCore.AnalyticsUserKeyTag, Swift.String>
public enum AnalyticsUserKeyTag {
}
public typealias AnimatedImageFactory = DevicesCore.Factory<DevicesCore.AnimatedImageFactoryArgs, Swift.Void>
extension DevicesCore.Factory where Arg == DevicesCore.AnimatedImageFactoryArgs, Item == () {
  public static func factory(assertionCaller: DevicesCore.AssertionCaller = assertionCallerShared) -> DevicesCore.Factory<Arg, Item>
}
public struct AnimatedImageFactoryArgs {
}
final public class AnimatedImageFactoryImpl {
  public init(assertionCaller: DevicesCore.AssertionCaller, downscaleFactor: CoreFoundation.CGFloat = 2, asyncPerformer: DevicesCore.AsyncPerformer = DispatchQueue(
			label: "ru.sberbank.sberdevices.AnimatedImageFactory",
			target: .global(qos: .utility)
		), mainThreadRunner: @escaping DevicesCore.MainThreadRunner = onMainThread)
  final public func makeAnimatedImage(with args: DevicesCore.AnimatedImageFactoryArgs)
  @objc deinit
}
public struct AnyAnalyticsEvent : DevicesCore.AnalyticsEvent {
  public var name: Swift.String
  public var parameters: [Swift.String : Any]?
  public init(name: Swift.String, parameters: [Swift.String : Any]?)
  public init(subject: DevicesCore.AnalyticsEvent)
  public mutating func addParameter(key: Swift.String, value: Any)
}
public typealias AnyCancellable = Combine.AnyCancellable
public struct AnyDifferentiable : DevicesCore.Differentiable {
  @inlinable public var base: Any {
    get {
		box.base
	}
  }
  @inlinable public var differenceIdentifier: Swift.AnyHashable {
    get {
		box.differenceIdentifier
	}
  }
  @usableFromInline
  internal let box: DevicesCore.AnyDifferentiableBox
  public init<D>(_ base: D) where D : DevicesCore.ContentEquatable, D : DevicesCore.ContentIdentifiable
  @inlinable public func isContentEqual(to source: DevicesCore.AnyDifferentiable) -> Swift.Bool {
		box.isContentEqual(to: source.box)
	}
  public typealias DifferenceIdentifier = Swift.AnyHashable
}
extension DevicesCore.AnyDifferentiable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@usableFromInline
internal protocol AnyDifferentiableBox {
  var base: Any { get }
  var differenceIdentifier: Swift.AnyHashable { get }
  func isContentEqual(to source: DevicesCore.AnyDifferentiableBox) -> Swift.Bool
}
@usableFromInline
internal struct DifferentiableBox<Base> : DevicesCore.AnyDifferentiableBox where Base : DevicesCore.ContentEquatable, Base : DevicesCore.ContentIdentifiable {
  @usableFromInline
  internal let baseComponent: Base
  @inlinable internal var base: Any {
    get {
		baseComponent
	}
  }
  @inlinable internal var differenceIdentifier: Swift.AnyHashable {
    get {
		baseComponent.differenceIdentifier
	}
  }
  @usableFromInline
  internal init(_ base: Base)
  @inlinable internal func isContentEqual(to source: DevicesCore.AnyDifferentiableBox) -> Swift.Bool {
		guard let sourceBase = source.base as? Base else {
			return false
		}
		return baseComponent.isContentEqual(to: sourceBase)
	}
}
public struct AnyScheduler<SchedulerTimeType, SchedulerOptions> : Combine.Scheduler, @unchecked Swift.Sendable where SchedulerTimeType : Swift.Strideable, SchedulerTimeType.Stride : Combine.SchedulerTimeIntervalConvertible {
  public var minimumTolerance: SchedulerTimeType.Stride {
    get
  }
  public var now: SchedulerTimeType {
    get
  }
  public init(minimumTolerance: @escaping () -> SchedulerTimeType.Stride, now: @escaping () -> SchedulerTimeType, scheduleImmediately: @escaping (SchedulerOptions?, @escaping () -> Swift.Void) -> Swift.Void, delayed: @escaping (SchedulerTimeType, SchedulerTimeType.Stride, SchedulerOptions?, @escaping () -> Swift.Void) -> Swift.Void, interval: @escaping (SchedulerTimeType, SchedulerTimeType.Stride, SchedulerTimeType.Stride, SchedulerOptions?, @escaping () -> Swift.Void) -> DevicesCore.Cancellable)
  public init<S>(_ scheduler: S) where SchedulerTimeType == S.SchedulerTimeType, SchedulerOptions == S.SchedulerOptions, S : Combine.Scheduler
  public func schedule(after date: SchedulerTimeType, tolerance: SchedulerTimeType.Stride, options: SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: SchedulerTimeType, interval: SchedulerTimeType.Stride, tolerance: SchedulerTimeType.Stride, options: SchedulerOptions?, _ action: @escaping () -> Swift.Void) -> DevicesCore.Cancellable
  public func schedule(options: SchedulerOptions?, _ action: @escaping () -> Swift.Void)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public typealias AnySchedulerOf<Scheduler> = DevicesCore.AnyScheduler<Scheduler.SchedulerTimeType, Scheduler.SchedulerOptions> where Scheduler : Combine.Scheduler
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Scheduler {
  public func eraseToAnyScheduler() -> DevicesCore.AnyScheduler<Self.SchedulerTimeType, Self.SchedulerOptions>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension DevicesCore.AnyScheduler where SchedulerTimeType == Dispatch.DispatchQueue.SchedulerTimeType, SchedulerOptions == Dispatch.DispatchQueue.SchedulerOptions {
  public static var main: DevicesCore.AnyScheduler<Dispatch.DispatchQueue.SchedulerTimeType, Dispatch.DispatchQueue.SchedulerOptions> {
    get
  }
  public static func global(qos: Dispatch.DispatchQoS.QoSClass = .default) -> DevicesCore.AnyScheduler<SchedulerTimeType, SchedulerOptions>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension DevicesCore.AnyScheduler where SchedulerTimeType == Foundation.OperationQueue.SchedulerTimeType, SchedulerOptions == Foundation.OperationQueue.SchedulerOptions {
  public static var main: DevicesCore.AnyScheduler<Foundation.OperationQueue.SchedulerTimeType, Foundation.OperationQueue.SchedulerOptions> {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension DevicesCore.AnyScheduler where SchedulerTimeType == Foundation.RunLoop.SchedulerTimeType, SchedulerOptions == Foundation.RunLoop.SchedulerOptions {
  public static var main: DevicesCore.AnyScheduler<Foundation.RunLoop.SchedulerTimeType, Foundation.RunLoop.SchedulerOptions> {
    get
  }
}
public struct AnyStackScreen : DevicesCore.StackScreen {
  public let subject: DevicesCore.StackScreen
  @inlinable public var viewController: UIKit.UIViewController {
    get {
		subject.viewController
	}
  }
  @inlinable public var flags: DevicesCore.Property<DevicesCore.StackScreenFlags> {
    get {
		subject.flags
	}
  }
  @inlinable public var presentationMode: DevicesCore.StackPresentationMode {
    get {
		subject.presentationMode
	}
  }
  @inlinable public func sizeThatFits(_ size: CoreFoundation.CGSize, safeAreaInsets: UIKit.UIEdgeInsets) -> CoreFoundation.CGSize {
		subject.sizeThatFits(size, safeAreaInsets: safeAreaInsets)
	}
  public var sizeRestriction: DevicesCore.StackScreenSizeRestriction {
    get
  }
  public init(_ subject: DevicesCore.StackScreen)
}
public struct AnyTrustVerifier : DevicesCore.TrustVerifier {
  public init(_ thunk: @escaping () -> DevicesCore.TrustVerifier)
  public func validate(_ trust: Security.SecTrust, domain: Swift.String?) throws
}
public typealias AppMetricaAPIKey = DevicesCore.Tagged<DevicesCore.AppMetricaTag, Swift.String>
public enum AppMetricaTag {
}
public enum PhoneSettingsType : Swift.Equatable {
  case wifi
  case bluetooth
  case application
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesCore.PhoneSettingsType, b: DevicesCore.PhoneSettingsType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol AppSettingsOpener {
  typealias PresentController = (UIKit.UIViewController) -> Swift.Void
  func showOpenSettingsAlert(present: (UIKit.UIViewController) -> Swift.Void, title: Swift.String, message: Swift.String, completion: @escaping () -> Swift.Void)
  func openPhoneSettings(_ type: DevicesCore.PhoneSettingsType, onReturn: @escaping () -> Swift.Void)
}
extension DevicesCore.AppSettingsOpener {
  public func openPhoneSettings(_ type: DevicesCore.PhoneSettingsType)
  public func openSettings()
}
final public class AppSettingsOpenerImpl : DevicesCore.AppSettingsOpener {
  public init(notificationCenter: Foundation.NotificationCenter, assertionCaller: DevicesCore.AssertionCaller, urlHandler: DevicesCore.URLHandler, cancelActionText: Swift.String = "Отмена", openSettingsActionText: Swift.String = "Перейти в настройки", mainThreadRunner: @escaping DevicesCore.MainThreadRunner = onMainThread)
  final public func showOpenSettingsAlert(present: (UIKit.UIViewController) -> Swift.Void, title: Swift.String, message: Swift.String, completion: @escaping () -> Swift.Void)
  final public func openPhoneSettings(_ type: DevicesCore.PhoneSettingsType, onReturn: @escaping () -> Swift.Void)
  @objc deinit
}
public protocol Application {
  var state: DevicesCore.ApplicationState { get }
  var isIdleTimerDisabled: Swift.Bool { get set }
}
extension UIKit.UIApplication : DevicesCore.Application {
  @_Concurrency.MainActor(unsafe) public var state: DevicesCore.ApplicationState {
    get
  }
}
public typealias ApplicationGroup = DevicesCore.Tagged<DevicesCore.ApplicationGroupTag, Swift.String>
public enum ApplicationGroupTag {
}
public enum ApplicationGroupError : Foundation.LocalizedError {
  case missingContainer(DevicesCore.ApplicationGroup)
  public var errorDescription: Swift.String? {
    get
  }
}
extension Foundation.FileManager {
  public func url(for path: Swift.String, in applicationGroup: DevicesCore.ApplicationGroup) throws -> Foundation.URL
}
extension DevicesCore.FileManagerTwin {
  public func url(for path: Swift.String, in applicationGroup: DevicesCore.ApplicationGroup) throws -> Foundation.URL
}
public protocol ApplicationIconBadgeNumberStore : ObjectiveC.NSObject {
  var applicationIconBadgeNumber: Swift.Int { get set }
}
extension UIKit.UIApplication : DevicesCore.ApplicationIconBadgeNumberStore {
}
public protocol ApplicationParameters {
  static var openSettingsURLString: Swift.String { get }
}
extension UIKit.UIApplication : DevicesCore.ApplicationParameters {
}
public enum ApplicationState {
  case active
  case inactive
  case background
  public static func == (a: DevicesCore.ApplicationState, b: DevicesCore.ApplicationState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesCore.ApplicationState {
  public var isActive: Swift.Bool {
    get
  }
}
extension DevicesCore.Application {
  public func makeApplicationState(notificationCenter: Foundation.NotificationCenter, logger: DevicesCore.Logger?) -> DevicesCore.Property<DevicesCore.ApplicationState>
}
extension DevicesCore.Archive {
  final public var data: Foundation.Data? {
    get
  }
}
extension DevicesCore.Archive {
  final public func extract(_ entry: DevicesCore.Entry, to url: Foundation.URL, bufferSize: Swift.UInt32 = defaultReadChunkSize, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil) throws -> DevicesCore.CRC32
  final public func extract(_ entry: DevicesCore.Entry, bufferSize: Swift.UInt32 = defaultReadChunkSize, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> DevicesCore.CRC32
}
extension DevicesCore.Archive {
  final public func addEntry(with path: Swift.String, relativeTo baseURL: Foundation.URL, compressionMethod: DevicesCore.CompressionMethod = .none, bufferSize: Swift.UInt32 = defaultWriteChunkSize, progress: Foundation.Progress? = nil) throws
  final public func addEntry(with path: Swift.String, type: DevicesCore.Entry.EntryType, uncompressedSize: Swift.UInt32, modificationDate: Foundation.Date = Date(), permissions: Swift.UInt16? = nil, compressionMethod: DevicesCore.CompressionMethod = .none, bufferSize: Swift.UInt32 = defaultWriteChunkSize, progress: Foundation.Progress? = nil, provider: (_ position: Swift.Int, _ size: Swift.Int) throws -> Foundation.Data) throws
  final public func remove(_ entry: DevicesCore.Entry, bufferSize: Swift.UInt32 = defaultReadChunkSize, progress: Foundation.Progress? = nil) throws
}
public let defaultReadChunkSize: Swift.UInt32
public let defaultWriteChunkSize: Swift.UInt32
public let defaultFilePermissions: Swift.UInt16
public let defaultDirectoryPermissions: Swift.UInt16
public enum CompressionMethod : Swift.UInt16 {
  case none
  case deflate
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
final public class Archive : Swift.Sequence {
  public enum ArchiveError : Swift.Error {
    case unreadableArchive
    case unwritableArchive
    case invalidEntryPath
    case invalidCompressionMethod
    case invalidStartOfCentralDirectoryOffset
    case missingEndOfCentralDirectoryRecord
    case cancelledOperation
    public static func == (a: DevicesCore.Archive.ArchiveError, b: DevicesCore.Archive.ArchiveError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum AccessMode : Swift.UInt {
    case create
    case read
    case update
    public init?(rawValue: Swift.UInt)
    public typealias RawValue = Swift.UInt
    public var rawValue: Swift.UInt {
      get
    }
  }
  final public let url: Foundation.URL
  final public let accessMode: DevicesCore.Archive.AccessMode
  public init?(url: Foundation.URL, accessMode mode: DevicesCore.Archive.AccessMode, preferredEncoding: Swift.String.Encoding? = nil)
  public init?(data: Foundation.Data = Data(), accessMode mode: DevicesCore.Archive.AccessMode, preferredEncoding: Swift.String.Encoding? = nil)
  @objc deinit
  final public func makeIterator() -> Swift.AnyIterator<DevicesCore.Entry>
  final public subscript(path: Swift.String) -> DevicesCore.Entry? {
    get
  }
  public typealias Element = DevicesCore.Entry
  public typealias Iterator = Swift.AnyIterator<DevicesCore.Entry>
}
extension DevicesCore.Archive {
  final public func totalUnitCountForRemoving(_ entry: DevicesCore.Entry) -> Swift.Int64
  final public func totalUnitCountForReading(_ entry: DevicesCore.Entry) -> Swift.Int64
  final public func totalUnitCountForAddingItem(at url: Foundation.URL) -> Swift.Int64
}
public struct ArgumentsStringID {
  public enum StringArgument {
    case cvar(Swift.CVarArg)
    case argumentsStringId(DevicesCore.ArgumentsStringID)
  }
  public let stringID: DevicesCore.StringID
  public let args: [DevicesCore.ArgumentsStringID.StringArgument]
  public init(stringID: DevicesCore.StringID, args: [Swift.CVarArg])
  public init(stringID: DevicesCore.StringID, args: [DevicesCore.ArgumentsStringID.StringArgument])
}
extension DevicesCore.StringID {
  public func argument(_ args: [Swift.CVarArg]) -> DevicesCore.ArgumentsStringID
  public func argument(_ args: [DevicesCore.ArgumentsStringID.StringArgument]) -> DevicesCore.ArgumentsStringID
}
extension Swift.Array {
  public func chunked(by chunkSize: Swift.Int) -> [Swift.ArraySlice<Element>]
}
extension Swift.Array where Element == Swift.Int {
  public func greatestCommonDivisor() -> Swift.Int?
}
extension Swift.Array {
  public func interleaved(by element: Element) -> [Element]
}
extension Swift.Array {
  @inlinable public func replacingFirst(with element: Element) -> Swift.Array<Element> {
		[element] + dropFirst(1)
	}
  @inlinable public func replacingLast(with element: Element) -> Swift.Array<Element> {
		droppingLast() + [element]
	}
  @inlinable public func appending(_ element: Element) -> Swift.Array<Element> {
		self + [element]
	}
  @inlinable public func droppingLast() -> Swift.Array<Element> {
		Array(prefix(count - 1))
	}
}
extension Swift.Array {
  public typealias Permutation = [Swift.Int]
  public func permuted(permutation: Swift.Array<Element>.Permutation) -> [Element]
}
extension Swift.Array {
  public mutating func safeRemoveFirst() -> Element?
}
extension Swift.Array {
  public func separated(by arrayCount: Swift.Int) -> [[Element]]
}
extension Swift.Array {
  public static func >> (left: Swift.Array<Element>, right: Swift.UInt) -> Swift.Array<Element>
  public static func << (left: Swift.Array<Element>, right: Swift.UInt) -> Swift.Array<Element>
}
extension Swift.Array {
  @inlinable internal static func _isWCSIABroken() -> Swift.Bool {
		guard _isBridgedVerbatimToObjectiveC(Element.self) else {
			// SR-14663 only triggers on array values that are verbatim bridged
			// from Objective-C, so it cannot ever trigger for element types
			// that aren't verbatim bridged.
			return false
		}

    // SR-14663 was introduced in Swift 5.1, and it was resolved in Swift 5.5.
    // Check if we have a broken stdlib.

		// The bug is caused by a bogus precondition inside a non-inlinable stdlib
		// method, so to determine if we're affected, we need to check the currently
		// running OS version.
		if #available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *) {
			// The OS is too new to be affected by this bug. (>= 5.5 stdlib)
			return false
		}
		//    guard #available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13, *) else {
		//      // The OS is too old to be affected by this bug. (< 5.1 stdlib)
		//      return false
		//    }
		return true

	}
}
extension Swift.Sequence {
  @inlinable @inline(__always) public func _withContiguousStorageIfAvailable_SR14663<R>(_ body: (Swift.UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R? {
		if Self.self == [Element].self, Array<Element>._isWCSIABroken() {
			return nil
		}

		return try self.withContiguousStorageIfAvailable(body)
	}
}
public struct ArraySection<Model, Element> : DevicesCore.DifferentiableSection where Model : DevicesCore.ContentEquatable, Model : DevicesCore.ContentIdentifiable, Element : DevicesCore.ContentEquatable, Element : DevicesCore.ContentIdentifiable {
  public var model: Model
  public var elements: [Element]
  @inlinable public var differenceIdentifier: Model.DifferenceIdentifier {
    get {
		model.differenceIdentifier
	}
  }
  public init<C>(model: Model, elements: C) where Element == C.Element, C : Swift.Collection
  @inlinable public init<C>(source: DevicesCore.ArraySection<Model, Element>, elements: C) where Element == C.Element, C : Swift.Collection {
		self.init(model: source.model, elements: elements)
	}
  @inlinable public func isContentEqual(to source: DevicesCore.ArraySection<Model, Element>) -> Swift.Bool {
		model.isContentEqual(to: source.model)
	}
  public typealias Collection = [Element]
  public typealias DifferenceIdentifier = Model.DifferenceIdentifier
}
extension DevicesCore.ArraySection : Swift.Equatable where Model : Swift.Equatable, Element : Swift.Equatable {
  public static func == (lhs: DevicesCore.ArraySection<Model, Element>, rhs: DevicesCore.ArraySection<Model, Element>) -> Swift.Bool
}
extension DevicesCore.ArraySection : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension DevicesCore.AssertionCaller {
  public func assertIsMain(file: Swift.StaticString = #file, line: Swift.UInt = #line)
  public func assertIsCurrent(thread: Foundation.Thread, file: Swift.StaticString = #file, line: Swift.UInt = #line)
  public func assertIsNotMain(file: Swift.StaticString = #file, line: Swift.UInt = #line)
}
public protocol AssertionCaller {
  func debug(_ message: @autoclosure () -> Swift.String, prefix: @autoclosure () -> Swift.String, suffix: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt)
  func fatal(_ message: @autoclosure () -> Swift.String, prefix: @autoclosure () -> Swift.String, suffix: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt)
  func conditional(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String, prefix: @autoclosure () -> Swift.String, suffix: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt)
}
extension DevicesCore.AssertionCaller {
  public func debug(_ message: @autoclosure () -> Swift.String, prefix: @autoclosure () -> Swift.String = "", suffix: @autoclosure () -> Swift.String = "", file: Swift.StaticString = #file, line: Swift.UInt = #line)
  public func fatal(_ message: @autoclosure () -> Swift.String, prefix: @autoclosure () -> Swift.String = "", suffix: @autoclosure () -> Swift.String = "", file: Swift.StaticString = #file, line: Swift.UInt = #line)
  public func conditional(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = "", prefix: @autoclosure () -> Swift.String = "", suffix: @autoclosure () -> Swift.String = "", file: Swift.StaticString = #file, line: Swift.UInt = #line)
}
@available(*, deprecated, message: "Use assertion caller injection")
public var assertionCallerShared: DevicesCore.AssertionCaller {
  get
}
public func setSharedAssertionCaller(_ assertionCaller: DevicesCore.AssertionCaller)
public func assertDebugFailure(_: @autoclosure () -> Swift.String, prefix _: @autoclosure () -> Swift.String = "", suffix _: @autoclosure () -> Swift.String = "", file _: Swift.StaticString = #file, line _: Swift.UInt = #line)
public func assertDebugFailure(_ error: @autoclosure () -> Swift.Error, prefix: @autoclosure () -> Swift.String = "", suffix: @autoclosure () -> Swift.String = "", file: Swift.StaticString = #file, line: Swift.UInt = #line)
public func assertFatalFailure(_ message: @autoclosure () -> Swift.String, prefix: @autoclosure () -> Swift.String = "", suffix: @autoclosure () -> Swift.String = "", file: Swift.StaticString = #file, line: Swift.UInt = #line) -> Swift.Never
public func assertDebug(_: @autoclosure () -> Swift.Bool, _: @autoclosure () -> Swift.String = "", prefix _: @autoclosure () -> Swift.String = "", suffix _: @autoclosure () -> Swift.String = "", file _: Swift.StaticString = #file, line _: Swift.UInt = #line)
public struct AssertionFailureHandler : DevicesCore.DeserializationFailureHandler {
  public init(assertionCaller: DevicesCore.AssertionCaller)
  public func handle(_ error: Swift.Error)
}
final public class AssertionLogger : DevicesCore.AssertionCaller {
  final public var isDebugFailureEnabled: DevicesCore.Property<Swift.Bool>
  public init(logger: DevicesCore.Logger, isDebugFailureEnabled: DevicesCore.Property<Swift.Bool> = Property(true))
  final public func debug(_ message: @autoclosure () -> Swift.String, prefix: @autoclosure () -> Swift.String, suffix: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt)
  final public func fatal(_ message: @autoclosure () -> Swift.String, prefix: @autoclosure () -> Swift.String, suffix: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt)
  final public func conditional(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String, prefix: @autoclosure () -> Swift.String, suffix: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt)
  @objc deinit
}
final public class AsyncGroupPerformer<T, R> {
  public typealias ResultFactory = () -> R
  public typealias OperationResultAppend = (inout R, T) -> Swift.Void
  public typealias Operation = (@escaping (T) -> Swift.Void) -> Swift.Void
  public typealias GroupCompletion = (R) -> Swift.Void
  public init(waitAsyncPerformer: DevicesCore.AsyncPerformer & Swift.AnyObject, workAsyncPerformer: DevicesCore.AsyncPerformer & Swift.AnyObject, resultFactory: @escaping DevicesCore.AsyncGroupPerformer<T, R>.ResultFactory, resultAsyncPerformer: DevicesCore.AsyncPerformer = DispatchQueue.main, groupSchedulerFactory: DevicesCore.Factory<Swift.Void, DevicesCore.GroupScheduler> = Factory { DispatchGroup() })
  final public func appendTask(operation: @escaping DevicesCore.AsyncGroupPerformer<T, R>.Operation, resultAppend: @escaping DevicesCore.AsyncGroupPerformer<T, R>.OperationResultAppend)
  final public func execute(completion: @escaping DevicesCore.AsyncGroupPerformer<T, R>.GroupCompletion)
  @objc deinit
}
extension DevicesCore.AsyncGroupPerformer where R == [T] {
  convenience public init(waitAsyncPerformer: DevicesCore.AsyncPerformer & Swift.AnyObject, workAsyncPerformer: DevicesCore.AsyncPerformer & Swift.AnyObject, resultAsyncPerformer: DevicesCore.AsyncPerformer = DispatchQueue.main, groupSchedulerFactory: DevicesCore.Factory<Swift.Void, DevicesCore.GroupScheduler> = Factory { DispatchGroup() })
  final public func appendTask(operation: @escaping DevicesCore.AsyncGroupPerformer<T, R>.Operation)
}
public protocol AsyncPerformer {
  func execute(_ operation: @escaping () -> Swift.Void)
  func execute(after deadline: Dispatch.DispatchTime, work: @escaping () -> Swift.Void)
}
extension Dispatch.DispatchQueue : DevicesCore.AsyncPerformer {
  public func execute(_ work: @escaping () -> Swift.Void)
  public func execute(after deadline: Dispatch.DispatchTime, work: @escaping () -> Swift.Void)
}
@propertyWrapper final public class Atomic<Value> {
  @inlinable final public var value: Value {
    get {
		wrappedValue
	}
  }
  final public var wrappedValue: Value {
    get
    set
  }
  public init(_ value: Value, queue: Dispatch.DispatchQueue)
  convenience public init(_ value: Value, qos: Dispatch.DispatchQoS.QoSClass = .default)
  convenience public init(wrappedValue: Value)
  final public func mutate(_ transform: @escaping (inout Value) -> Swift.Void)
  final public func wait<T>(_ transform: (inout Value) -> T) -> T
  @objc deinit
}
public protocol StorageItemAttributes {
}
open class AttributedStorage<Attributes> where Attributes : DevicesCore.StorageItemAttributes {
  public init()
  open func getItem(with _: Attributes) throws -> Foundation.Data?
  open func setItem(_: Foundation.Data, with _: Attributes) throws
  open func removeItem(with _: Attributes) throws
  open func popItem(with attributes: Attributes) throws -> Foundation.Data?
  @objc deinit
}
public struct AudioBundleProvider : DevicesCore.AudioProvider {
  public init(bundle: Foundation.Bundle, soundPlayerFactory: DevicesCore.SoundPlayerFactory)
  public func makeSoundPlayer(for id: DevicesCore.AudioID) -> DevicesCore.SoundPlayer?
}
public struct AudioConverterIOFormat {
  public let from: AVFAudio.AVAudioFormat
  public let to: AVFAudio.AVAudioFormat
  public init(from: AVFAudio.AVAudioFormat, to target: AVFAudio.AVAudioFormat)
}
extension DevicesCore.AudioDecoder {
  public func repairedWavHeaderDecoder() -> DevicesCore.AudioDecoder
}
public protocol AudioDecoder {
  func decode(audioData: Foundation.Data) throws -> DevicesCore.AudioPayload
  func reset()
}
public typealias AudioDecoderFactory = DevicesCore.Factory<Swift.Void, DevicesCore.AudioDecoder>
public protocol AudioEngine {
  var mainMixerNode: AVFAudio.AVAudioMixerNode { get }
  var isRunning: Swift.Bool { get }
  func prepare()
  func start() throws
  func stop()
  func pause()
  func reset()
  func attach(_ node: AVFAudio.AVAudioNode)
  func detach(_ node: AVFAudio.AVAudioNode)
  func connect(_ node1: AVFAudio.AVAudioNode, to node2: AVFAudio.AVAudioNode, format: AVFAudio.AVAudioFormat?)
}
extension AVFAudio.AVAudioEngine : DevicesCore.AudioEngine {
}
public struct AudioFile {
  public let url: Foundation.URL
  public var duration: Foundation.TimeInterval
  public init(url: Foundation.URL, duration: Foundation.TimeInterval)
}
public enum AudioFileFormat : Swift.String {
  case wav
  case aac
  case mp3
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension DevicesCore.AudioFormat {
  public static var opusAsr: DevicesCore.AudioFormat {
    get
  }
}
extension DevicesCore.AudioFormat {
  public static var pcmAsr: DevicesCore.AudioFormat {
    get
  }
}
public enum SampleRateTag {
}
public typealias SampleRate = DevicesCore.Tagged<DevicesCore.SampleRateTag, Swift.Double>
public enum ChannelsCountTag {
}
public typealias ChannelsCount = DevicesCore.Tagged<DevicesCore.ChannelsCountTag, Swift.Int>
public enum BitsPerChannelTag {
}
public typealias BitsPerChannel = DevicesCore.Tagged<DevicesCore.BitsPerChannelTag, Swift.Int>
public struct AudioFormat : Swift.Equatable {
  public let streamFormat: CoreAudioTypes.AudioStreamBasicDescription
  public var sampleRate: DevicesCore.SampleRate {
    get
  }
  public var channelsCount: DevicesCore.ChannelsCount {
    get
  }
  public var bitsPerSample: DevicesCore.BitsPerChannel {
    get
  }
  public let fileExtension: Swift.String?
  public init(sampleRate: DevicesCore.SampleRate, channelsCount: DevicesCore.ChannelsCount, bitsPerChannel: DevicesCore.BitsPerChannel, fileExtension: Swift.String? = nil)
  public init(avAudioFormat: AVFAudio.AVAudioFormat)
  public var avAudioFormat: AVFAudio.AVAudioFormat? {
    get
  }
  public static func == (a: DevicesCore.AudioFormat, b: DevicesCore.AudioFormat) -> Swift.Bool
}
public protocol AudioFormatConverter {
  var format: DevicesCore.AudioConverterIOFormat { get }
  func convert(_ buffer: AVFAudio.AVAudioPCMBuffer) throws -> AVFAudio.AVAudioPCMBuffer
}
public enum AudioFormatConverterError : Foundation.LocalizedError, Swift.Equatable {
  case converterUninitialized(fromFormat: AVFAudio.AVAudioFormat, toFormat: AVFAudio.AVAudioFormat)
  case outputBufferCreationError
  case conversionError(underlineError: Foundation.NSError)
  case unexpectedInputBufferFormat
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: DevicesCore.AudioFormatConverterError, b: DevicesCore.AudioFormatConverterError) -> Swift.Bool
}
public typealias AudioFormatConverterFactory = (AVFAudio.AVAudioFormat) throws -> DevicesCore.AudioFormatConverter
extension DevicesCore.AudioFormatConverterImpl {
  public static func factory(outputFormat: AVFAudio.AVAudioFormat) -> DevicesCore.AudioFormatConverterFactory
}
final public class AudioFormatConverterImpl {
  final public let format: DevicesCore.AudioConverterIOFormat
  public init(format: DevicesCore.AudioConverterIOFormat) throws
  @objc deinit
}
extension DevicesCore.AudioFormatConverterImpl : DevicesCore.AudioFormatConverter {
  final public func convert(_ buffer: AVFAudio.AVAudioPCMBuffer) throws -> AVFAudio.AVAudioPCMBuffer
}
public protocol AudioID {
  var name: Swift.String { get }
  var format: DevicesCore.AudioFileFormat { get }
}
public struct AudioPayload : Swift.Equatable {
  public let format: DevicesCore.AudioFormat
  public var data: Foundation.Data
  public let duration: Foundation.TimeInterval
  public init(format: DevicesCore.AudioFormat, data: Foundation.Data, duration: Foundation.TimeInterval)
  public static func == (a: DevicesCore.AudioPayload, b: DevicesCore.AudioPayload) -> Swift.Bool
}
public protocol AudioPlaybackPlayer : AnyObject {
  var payload: DevicesCore.AudioPayload { get }
  var state: DevicesCore.Property<DevicesCore.AudioPlaybackPlayerState> { get }
  func play(atTime time: Foundation.TimeInterval)
  func pause()
  func stop()
}
public typealias AudioPlaybackPlayerFactory = DevicesCore.Factory<DevicesCore.AudioPayload, DevicesCore.AudioPlaybackPlayer>
extension DevicesCore.Factory where Arg == DevicesCore.AudioPayload, Item == DevicesCore.AudioPlaybackPlayer {
  public static func factory(playerFactory: DevicesCore.AudioPlayerFactory, playbackObserverFactory: DevicesCore.PlaybackObserverFactory, applicationState: DevicesCore.Property<DevicesCore.ApplicationState>, assertionCaller: DevicesCore.AssertionCaller) -> DevicesCore.AudioPlaybackPlayerFactory
}
extension DevicesCore.AudioPlaybackPlayerImpl {
  public enum Error : Swift.Error {
    case applicationStateIsNotActive
    case audioPlayerAlreadyPlaying
    case audioDecodingError
    public static func == (a: DevicesCore.AudioPlaybackPlayerImpl.Error, b: DevicesCore.AudioPlaybackPlayerImpl.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@objc final public class AudioPlaybackPlayerImpl : ObjectiveC.NSObject, DevicesCore.AudioPlaybackPlayer {
  final public let payload: DevicesCore.AudioPayload
  final public var state: DevicesCore.Property<DevicesCore.AudioPlaybackPlayerState> {
    get
  }
  public init(payload: DevicesCore.AudioPayload, playerFactory: DevicesCore.AudioPlayerFactory, playbackObserverFactory: DevicesCore.PlaybackObserverFactory, applicationState: DevicesCore.Property<DevicesCore.ApplicationState>, assertionCaller: DevicesCore.AssertionCaller)
  final public func play(atTime time: Foundation.TimeInterval)
  final public func pause()
  final public func stop()
  @objc deinit
}
extension DevicesCore.AudioPlaybackPlayerImpl : AVFAudio.AVAudioPlayerDelegate {
  @objc final public func audioPlayerDidFinishPlaying(_: AVFAudio.AVAudioPlayer, successfully flag: Swift.Bool)
}
extension DevicesCore.AudioPlaybackPlayerState : Swift.Equatable {
  public static func == (lhs: DevicesCore.AudioPlaybackPlayerState, rhs: DevicesCore.AudioPlaybackPlayerState) -> Swift.Bool
}
extension DevicesCore.AudioPlaybackPlayerState {
  public struct Playing {
    public init(time: Foundation.TimeInterval, duration: Foundation.TimeInterval)
  }
}
public enum AudioPlaybackPlayerState {
  case idle
  case playing(DevicesCore.AudioPlaybackPlayerState.Playing)
  case paused
  case stopped(finished: Swift.Bool)
  case failed(Swift.Error)
}
public typealias AudioPlayerStartCompletion = (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void
public protocol AudioPlayer : AnyObject {
  var currentTime: Foundation.TimeInterval { get }
  var duration: Foundation.TimeInterval { get }
  var delegate: AVFAudio.AVAudioPlayerDelegate? { get set }
  func play(atTime time: Foundation.TimeInterval, completion: @escaping DevicesCore.AudioPlayerStartCompletion)
  func pause()
  func stop()
}
public typealias AudioPlayerFactory = DevicesCore.Factory<DevicesCore.AudioPayload, Swift.Result<DevicesCore.AudioPlayer, Swift.Error>>
extension DevicesCore.Factory where Arg == DevicesCore.AudioPayload, Item == Swift.Result<DevicesCore.AudioPlayer, Swift.Error> {
  public static func factory(audioSessionConfigurator: DevicesCore.AudioSessionConfigurator) -> DevicesCore.AudioPlayerFactory
}
public protocol AudioPlayerNode {
  var isPlaying: Swift.Bool { get }
  func scheduleBuffer(_ buffer: AVFAudio.AVAudioPCMBuffer, at when: AVFAudio.AVAudioTime?, options: AVFAudio.AVAudioPlayerNodeBufferOptions, completionCallbackType callbackType: AVFAudio.AVAudioPlayerNodeCompletionCallbackType, completionHandler: AVFAudio.AVAudioPlayerNodeCompletionHandler?)
  func play()
  func pause()
  func stop()
}
extension AVFAudio.AVAudioPlayerNode : DevicesCore.AudioPlayerNode {
}
public protocol AudioProvider {
  func makeSoundPlayer(for id: DevicesCore.AudioID) -> DevicesCore.SoundPlayer?
}
extension DevicesCore.AudioProvider {
  public func player(for id: DevicesCore.AudioID) -> DevicesCore.SoundPlayer
}
extension DevicesCore.AudioRecorder {
  public func encoded(audioFormat: DevicesCore.AudioFormat, streamEncoderFactory: DevicesCore.AudioStreamEncoderFactory) -> DevicesCore.AudioRecorder
}
extension DevicesCore.AudioRecorder {
  public func formatted(outputFormat: AVFAudio.AVAudioFormat) throws -> DevicesCore.AudioRecorder
}
public typealias AudioRecorderPrepareCompletion = (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void
public typealias AudioRecorderStartCompletion = (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void
public protocol AudioRecorder {
  var audioFormat: DevicesCore.AudioFormat { get }
  var onEvent: DevicesCore.Property<DevicesCore.AudioRecorderEvent> { get }
  func prepare(completion: @escaping DevicesCore.AudioRecorderPrepareCompletion)
  func start(completion: @escaping DevicesCore.AudioRecorderStartCompletion)
  func stop()
  func cancel()
}
public enum AudioRecorderEvent {
  case idle
  case didStartRecording
  case didStopRecording(reason: DevicesCore.AudioRecorderStopReason)
  case didReceivePayload(DevicesCore.AudioPayload)
  case didUpdatePower(Swift.Float)
  case didFailWithError(Swift.Error)
}
extension DevicesCore.AudioRecorderEvent : Swift.Equatable {
  public static func == (lhs: DevicesCore.AudioRecorderEvent, rhs: DevicesCore.AudioRecorderEvent) -> Swift.Bool
}
final public class AudioRecorderImpl : DevicesCore.AudioRecorder {
  public enum AudioRecorderError : Swift.Error {
    case applicationStateIsNotActive
    case audioRecorderAlreadyRecording
    case startCancelled
    public static func == (a: DevicesCore.AudioRecorderImpl.AudioRecorderError, b: DevicesCore.AudioRecorderImpl.AudioRecorderError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let audioFormat: DevicesCore.AudioFormat
  final public var onEvent: DevicesCore.Property<DevicesCore.AudioRecorderEvent> {
    get
  }
  public init(audioFormat: DevicesCore.AudioFormat, audioSourceFactory: DevicesCore.AudioSourceFactory, audioSessionConfigurator: DevicesCore.AudioSessionConfigurator, applicationState: DevicesCore.Property<DevicesCore.ApplicationState>, audioRecorderPolicy: DevicesCore.AudioRecorderPolicy, assertEventQueue: @escaping DevicesCore.DispatchQueueAssert = DispatchQueue.assertOnMain)
  final public func prepare(completion: @escaping DevicesCore.AudioRecorderPrepareCompletion)
  final public func start(completion: @escaping DevicesCore.AudioRecorderStartCompletion)
  final public func stop()
  final public func cancel()
  @objc deinit
}
extension DevicesCore.AudioRecorderImpl : DevicesCore.AudioSourceDelegate {
  final public func audioSourceDidStartListening(_: DevicesCore.AudioSource)
  final public func audioSourceDidStopListening(_: DevicesCore.AudioSource, reason: DevicesCore.AudioSourceStopReason)
  final public func audioSource(_: DevicesCore.AudioSource, didReceiveData data: AVFAudio.AVAudioPCMBuffer)
  final public func audioSource(_: DevicesCore.AudioSource, didUpdatePower power: Swift.Float)
  final public func audioSource(_: DevicesCore.AudioSource, didFailWithError error: Swift.Error)
}
public struct AudioRecorderPolicy : Swift.Equatable {
  public init(canAskForRecordPermission: Swift.Bool, shouldSuppressOtherAudio: Swift.Bool)
  public static func == (a: DevicesCore.AudioRecorderPolicy, b: DevicesCore.AudioRecorderPolicy) -> Swift.Bool
}
public enum AudioRecorderStopReason {
  case audioSourceConfigurationChanged
  case cancelled
  public static func == (a: DevicesCore.AudioRecorderStopReason, b: DevicesCore.AudioRecorderStopReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias AudioRingBuffer = DevicesCore.LimitedLinkedList<AVFAudio.AVAudioPCMBuffer>
extension DevicesCore.LimitedLinkedList where T == AVFAudio.AVAudioPCMBuffer {
  public enum AudioRingBufferError : Swift.Error {
    case emptyBuffers
    case invalidDuration
    public static func == (a: DevicesCore.LimitedLinkedList<T>.AudioRingBufferError, b: DevicesCore.LimitedLinkedList<T>.AudioRingBufferError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public func spotterData(duration: DevicesCore.Milliseconds, assertionCaller: DevicesCore.AssertionCaller) -> (data: Foundation.Data, actualDuration: DevicesCore.Milliseconds)
  public func convert(duration: DevicesCore.Milliseconds, converterFactory: DevicesCore.AudioFormatConverterFactory?, needClean: Swift.Bool) throws -> (data: Foundation.Data, actualDuration: DevicesCore.Milliseconds)
}
public typealias AudioPermissionBlock = (Swift.Bool) -> Swift.Void
public protocol AudioSession : AnyObject {
  var currentRoute: AVFAudio.AVAudioSessionRouteDescription { get }
  var category: AVFAudio.AVAudioSession.Category { get }
  var mode: AVFAudio.AVAudioSession.Mode { get }
  var categoryOptions: AVFAudio.AVAudioSession.CategoryOptions { get }
  var secondaryAudioShouldBeSilencedHint: Swift.Bool { get }
  func setCategory(_ category: AVFAudio.AVAudioSession.Category, mode: AVFAudio.AVAudioSession.Mode, options: AVFAudio.AVAudioSession.CategoryOptions) throws
  func setActive(_ active: Swift.Bool, options: AVFAudio.AVAudioSession.SetActiveOptions) throws
  var recordPermission: AVFAudio.AVAudioSession.RecordPermission { get }
  func requestRecordPermission(_ response: @escaping DevicesCore.AudioPermissionBlock)
  func setAllowHapticsAndSystemSoundsDuringRecording(_ inValue: Swift.Bool) throws
}
extension DevicesCore.AudioSession {
  public func setCategory(_ category: AVFAudio.AVAudioSession.Category) throws
  public func setActive(_ active: Swift.Bool) throws
}
extension AVFAudio.AVAudioSession : DevicesCore.AudioSession {
}
public protocol AudioSessionConfigurator : AnyObject {
  typealias Completion = (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void
  var moveToSettingsSignal: DevicesCore.Signal<Swift.Void> { get }
  func configureForPlayAudio(completion: @escaping Self.Completion)
  func configureForPlayAndRecord(audioRecorderPolicy: DevicesCore.AudioRecorderPolicy, completion: @escaping Self.Completion)
}
extension DevicesCore.AudioSessionConfigurator {
  public func configureForPlayAndRecord(completion: @escaping Self.Completion)
}
final public class AudioSessionConfiguratorImpl : DevicesCore.AudioSessionConfigurator {
  public enum Error : Swift.Error {
    case microphonePermissionDenied
    case anotherAppAudioAlreadyPlaying
    case setAllowHapticsAndSystemSoundsError
    public static func == (a: DevicesCore.AudioSessionConfiguratorImpl.Error, b: DevicesCore.AudioSessionConfiguratorImpl.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let logger: DevicesCore.Logger?
  final public var moveToSettingsSignal: DevicesCore.Signal<Swift.Void> {
    get
  }
  public init(controller: DevicesCore.AudioSessionController, assertionCaller: DevicesCore.AssertionCaller, mediaServicesSignal: DevicesCore.Signal<DevicesCore.AudioSessionMediaServicesEvent>, analyticsService: DevicesCore.AnalyticsService?, logger: DevicesCore.Logger?, osLogger: DevicesCore.OSLogger?, mainThreadRunner: @escaping DevicesCore.MainThreadRunner = onMainThread)
  final public func configureForPlayAudio(completion: @escaping DevicesCore.AudioSessionConfiguratorImpl.Completion)
  final public func configureForPlayAndRecord(audioRecorderPolicy: DevicesCore.AudioRecorderPolicy, completion: @escaping DevicesCore.AudioSessionConfiguratorImpl.Completion)
  @objc deinit
}
public protocol AudioSessionController : AnyObject, DevicesCore.AuthorizationProvider, DevicesCore.AuthorizationRequester {
  typealias Completion = (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void
  var category: AVFAudio.AVAudioSession.Category { get }
  var mode: AVFAudio.AVAudioSession.Mode { get }
  var categoryOptions: AVFAudio.AVAudioSession.CategoryOptions { get }
  var secondaryAudioShouldBeSilencedHint: Swift.Bool { get }
  func setCategory(_ category: AVFAudio.AVAudioSession.Category, mode: AVFAudio.AVAudioSession.Mode, options: AVFAudio.AVAudioSession.CategoryOptions, completion: @escaping Self.Completion)
  func setActive(_ active: Swift.Bool, options: AVFAudio.AVAudioSession.SetActiveOptions, completion: @escaping Self.Completion)
  var recordPermission: AVFAudio.AVAudioSession.RecordPermission { get }
  func requestRecordPermission(_ response: @escaping DevicesCore.AudioPermissionBlock)
  func setAllowHapticsAndSystemSoundsDuringRecording(inValue: Swift.Bool) throws
}
extension DevicesCore.AudioSessionController {
  public var authorizationStatus: DevicesCore.AuthorizationStatus {
    get
  }
  public func setCategory(_ category: AVFAudio.AVAudioSession.Category, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func setActive(_ active: Swift.Bool, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func requestAuthorization(completion: @escaping (DevicesCore.AuthorizationStatus) -> Swift.Void)
}
final public class AudioSessionControllerImpl : DevicesCore.AudioSessionController {
  final public var category: AVFAudio.AVAudioSession.Category {
    get
  }
  final public var mode: AVFAudio.AVAudioSession.Mode {
    get
  }
  final public var categoryOptions: AVFAudio.AVAudioSession.CategoryOptions {
    get
  }
  final public var recordPermission: AVFAudio.AVAudioSession.RecordPermission {
    get
  }
  final public var secondaryAudioShouldBeSilencedHint: Swift.Bool {
    get
  }
  public init(audioSession: DevicesCore.AudioSession = AVAudioSession.sharedInstance(), logger: DevicesCore.Logger?, osLogger: DevicesCore.OSLogger?, asyncPerformer: DevicesCore.AsyncPerformer = DispatchSerialQueue(
			label: "ru.sberbank.AudioSessionControllerQueue",
			qos: .userInitiated
		), mainThreadRunner: @escaping DevicesCore.MainThreadRunner = onMainThread)
  final public func setCategory(_ category: AVFAudio.AVAudioSession.Category, mode: AVFAudio.AVAudioSession.Mode, options: AVFAudio.AVAudioSession.CategoryOptions, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  final public func setActive(_ active: Swift.Bool, options: AVFAudio.AVAudioSession.SetActiveOptions, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  final public func setAllowHapticsAndSystemSoundsDuringRecording(inValue: Swift.Bool) throws
  final public func requestRecordPermission(_ response: @escaping (Swift.Bool) -> Swift.Void)
  @objc deinit
}
public enum AudioSessionInterruptionEvent {
  case didBeginInterruption
  case didEndInterruption(shouldResume: Swift.Bool)
}
extension Foundation.NotificationCenter {
  public func audioSessionInterruption(audioSession: DevicesCore.AudioSession, logger: DevicesCore.Logger?) -> DevicesCore.Signal<DevicesCore.AudioSessionInterruptionEvent>
}
public enum AudioSessionMediaServicesEvent {
  case servicesWereReset
  case servicesWereLost
  public static func == (a: DevicesCore.AudioSessionMediaServicesEvent, b: DevicesCore.AudioSessionMediaServicesEvent) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.NotificationCenter {
  public func mediaServices(audioSession: DevicesCore.AudioSession, logger: DevicesCore.Logger?) -> DevicesCore.Signal<DevicesCore.AudioSessionMediaServicesEvent>
}
public struct AudioSessionNotificationCenter {
  public let interuption: DevicesCore.Signal<DevicesCore.AudioSessionInterruptionEvent>
  public let mediaServices: DevicesCore.Signal<DevicesCore.AudioSessionMediaServicesEvent>
  public let lastOutputDevice: DevicesCore.Property<DevicesCore.AudioSessionOutputDevice?>
  public let onOutputDeviceChange: DevicesCore.Signal<Swift.Bool>
  public let categoryChanges: DevicesCore.Signal<Swift.Void>
  public let silenceSecondaryAudio: DevicesCore.Signal<DevicesCore.AudioSessionSilenceSecondaryEvent>
  public init(notificationCenter: Foundation.NotificationCenter, audioSession: DevicesCore.AudioSession, assertionCaller: DevicesCore.AssertionCaller, logger: DevicesCore.Logger?)
}
public struct AudioSessionOutputDevice : Swift.Equatable {
  public let deviceName: Swift.String?
  public let devicePort: DevicesCore.AudioSessionOutputDevicePortType?
  public init(deviceName: Swift.String?, devicePort: DevicesCore.AudioSessionOutputDevicePortType?)
  public static func == (a: DevicesCore.AudioSessionOutputDevice, b: DevicesCore.AudioSessionOutputDevice) -> Swift.Bool
}
public enum AudioSessionOutputDevicePortType : Swift.String {
  case bluetooth
  case wire
  case speaker
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct AudioSessionRouteChangeNotificationModel {
  public let reason: AVFAudio.AVAudioSession.RouteChangeReason
  public let portNames: [Swift.String]
  public var reasonName: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension Foundation.NotificationCenter {
  public func routeChange(audioSession: DevicesCore.AudioSession, logger: DevicesCore.Logger?, scheduler: DevicesCore.AnySchedulerOf<Dispatch.DispatchQueue> = AnyScheduler(DispatchQueue.main)) -> DevicesCore.Signal<DevicesCore.AudioSessionRouteChangeNotificationModel>
}
public protocol AudioSessionSilenceSecondaryAudioHintSource {
  func addListener(_ listener: DevicesCore.AudioSessionSilenceSecondaryEvent)
  func removeListener(_ listener: DevicesCore.AudioSessionSilenceSecondaryEvent)
}
public enum AudioSessionSilenceSecondaryEvent {
  case mute
  case resume
  public static func == (a: DevicesCore.AudioSessionSilenceSecondaryEvent, b: DevicesCore.AudioSessionSilenceSecondaryEvent) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.NotificationCenter {
  public func silenceSecondary(audioSession: DevicesCore.AudioSession, logger: DevicesCore.Logger?) -> DevicesCore.Signal<DevicesCore.AudioSessionSilenceSecondaryEvent>
}
extension DevicesCore.AudioSource {
  public func buffered(ringBuffer: DevicesCore.Property<DevicesCore.AudioRingBuffer>) -> DevicesCore.AudioSource
  public func convertible(outputFormat: AVFAudio.AVAudioFormat) throws -> DevicesCore.AudioSource
  public func receive(on asyncPerformer: DevicesCore.AsyncPerformer) -> DevicesCore.AudioSource
}
public protocol AudioSource : AnyObject {
  var delegate: DevicesCore.AudioSourceDelegate? { get set }
  var isRunning: Swift.Bool { get }
  var inputFormat: AVFAudio.AVAudioFormat { get }
  @discardableResult
  func start() -> Swift.Bool
  func stop()
  func cancel()
}
public protocol AudioSourceDelegate : AnyObject {
  func audioSourceDidStartListening(_ audioSource: DevicesCore.AudioSource)
  func audioSourceDidStopListening(_ audioSource: DevicesCore.AudioSource, reason: DevicesCore.AudioSourceStopReason)
  func audioSource(_ audioSource: DevicesCore.AudioSource, didReceiveData data: AVFAudio.AVAudioPCMBuffer)
  func audioSource(_ audioSource: DevicesCore.AudioSource, didUpdatePower power: Swift.Float)
  func audioSource(_ audioSource: DevicesCore.AudioSource, didFailWithError error: Swift.Error)
}
public typealias AudioSourceFactory = DevicesCore.Factory<Swift.Void, Swift.Result<DevicesCore.AudioSource, Swift.Error>>
extension DevicesCore.Factory where Arg == (), Item == Swift.Result<DevicesCore.AudioSource, Swift.Error> {
  public static func factory(callbackAsyncPerformer: DevicesCore.AsyncPerformer, outputFormat: AVFAudio.AVAudioFormat, osLogger: DevicesCore.OSLogger?) -> DevicesCore.AudioSourceFactory
}
public enum AudioSourceStopReason {
  case configurationChanged
  case deinited
  case failedToComputePower
  case cancelled
  public static func == (a: DevicesCore.AudioSourceStopReason, b: DevicesCore.AudioSourceStopReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension CoreAudioTypes.AudioStreamBasicDescription : Swift.Equatable {
  public static func == (lhs: CoreAudioTypes.AudioStreamBasicDescription, rhs: CoreAudioTypes.AudioStreamBasicDescription) -> Swift.Bool
}
public protocol AudioStreamEncoder {
  func start() throws
  func encode(payload: DevicesCore.AudioPayload) throws -> DevicesCore.AudioPayload
  func end() throws -> DevicesCore.AudioPayload
}
public typealias AudioStreamEncoderFactory = DevicesCore.Factory<Swift.Void, Swift.Result<DevicesCore.AudioStreamEncoder, Swift.Error>>
public protocol AuthorizationManager : DevicesCore.AuthorizationProvider, DevicesCore.AuthorizationRequester {
}
extension DevicesCore.AuthorizationManager {
  public func asAuthorizationStatusProperty() -> DevicesCore.Property<DevicesCore.AuthorizationStatus>
}
public protocol AuthorizationProvider {
  var authorizationStatus: DevicesCore.AuthorizationStatus { get }
}
public protocol AuthorizationRequester {
  func requestAuthorization(completion: @escaping (DevicesCore.AuthorizationStatus) -> Swift.Void)
}
extension DevicesCore.AuthorizationStatus {
  public func asPermissionStatus() -> DevicesCore.Permission.Status
  public func asPermission(type: DevicesCore.Permission.Kind) -> DevicesCore.Permission
}
public enum AuthorizationStatus : Swift.Equatable {
  case allowed
  case denied(DevicesCore.AuthorizationDenyReason)
  case notDetermined
  public var isDenied: Swift.Bool {
    get
  }
  public var value: Swift.String {
    get
  }
  public static func == (a: DevicesCore.AuthorizationStatus, b: DevicesCore.AuthorizationStatus) -> Swift.Bool
}
public enum AuthorizationDenyReason : Swift.Equatable {
  case user
  case disabled(DevicesCore.PhoneSettingsType)
  public static func == (a: DevicesCore.AuthorizationDenyReason, b: DevicesCore.AuthorizationDenyReason) -> Swift.Bool
}
extension DevicesCore.AuthorizationStatus : DevicesCore.PrettyStringConvertible {
  public func makePrettyDescription(additionalOffset: Swift.String?) -> Swift.String
}
@available(iOS, deprecated: 14)
public func warningOnceiOS13IsDropped(_: Swift.String)
public typealias BizoneData = DevicesCore.Tagged<DevicesCore.BizoneDataTag, Swift.String>
public enum BizoneDataTag {
}
extension Swift.Bool {
  @inlinable public var toggled: Swift.Bool {
    get { !self }
  }
}
extension Foundation.Bundle {
  public func tryChild(_ name: Swift.String) -> Foundation.Bundle?
  public func childBundle(_ name: Swift.String) -> Foundation.Bundle
}
public enum BundleIDTag {
}
public typealias BundleID = DevicesCore.Tagged<DevicesCore.BundleIDTag, Swift.String>
extension Foundation.Bundle {
  public var bundleID: DevicesCore.BundleID {
    get
  }
  public var shortVersion: Swift.String {
    get
  }
  public var version: Swift.String {
    get
  }
  public var marketingVersion: Swift.String {
    get
  }
  public var appName: Swift.String {
    get
  }
}
public protocol BundleTwin {
  var bundlePath: Swift.String { get }
}
extension Foundation.Bundle : DevicesCore.BundleTwin {
}
extension QuartzCore.CALayer {
  public func setNeedsUpdate()
  public func storeAnimations(toPause: Swift.Bool = true)
  public func restoreAnimations(toResume: Swift.Bool = true)
}
extension CoreGraphics.CGColor {
  public static func make(hex: Swift.Int64) -> CoreGraphics.CGColor
}
extension CoreFoundation.CGFloat : Swift.LosslessStringConvertible {
  public init?(_ description: Swift.String)
}
extension CoreFoundation.CGFloat {
  public func roundedUpToScreenScale(_ scale: CoreFoundation.CGFloat = UIScreen.main.scale) -> CoreFoundation.CGFloat
  public func roundedDownToScreenScale(_ scale: CoreFoundation.CGFloat = UIScreen.main.scale) -> CoreFoundation.CGFloat
  public func roundedUp(to step: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  public func roundedDown(to step: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
}
extension CoreFoundation.CGPoint {
  public static func + (left: CoreFoundation.CGPoint, right: CoreFoundation.CGPoint) -> CoreFoundation.CGPoint
}
extension CoreFoundation.CGRect {
  public var center: CoreFoundation.CGPoint {
    get
    set
  }
  public var isFinite: Swift.Bool {
    get
  }
  public init(x: CoreFoundation.CGFloat, y: CoreFoundation.CGFloat, size: CoreFoundation.CGSize)
  public init(origin: CoreFoundation.CGPoint, width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat)
  public init(center: CoreFoundation.CGPoint, size: CoreFoundation.CGSize)
  public init(minX: CoreFoundation.CGFloat, minY: CoreFoundation.CGFloat, maxX: CoreFoundation.CGFloat, maxY: CoreFoundation.CGFloat)
  public func relative(in bounds: CoreFoundation.CGRect) -> CoreFoundation.CGRect
  public func relative(in bounds: CoreFoundation.CGSize) -> CoreFoundation.CGRect
}
extension CoreFoundation.CGSize {
  public init(square: CoreFoundation.CGFloat)
  public static var infinity: CoreFoundation.CGSize {
    get
  }
  public var minDimension: CoreFoundation.CGFloat {
    get
  }
  @inlinable public var area: CoreFoundation.CGFloat {
    get {
		width * height
	}
  }
  public static func + (left: CoreFoundation.CGSize, right: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public static func ceil(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public var ceiled: CoreFoundation.CGSize {
    get
  }
  public static func + (left: CoreFoundation.CGSize, right: UIKit.UIEdgeInsets) -> CoreFoundation.CGSize
  public static func * (size: CoreFoundation.CGSize, scalar: CoreFoundation.CGFloat) -> CoreFoundation.CGSize
  public func inset(by insets: UIKit.UIEdgeInsets) -> CoreFoundation.CGSize
  public func centered(in rect: CoreFoundation.CGRect) -> CoreFoundation.CGRect
  public func aspectFit(in size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func aspectFill(size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func isAlmostGreater(_ size: CoreFoundation.CGSize) -> Swift.Bool
  public func isAlmostEqual(_ size: CoreFoundation.CGSize) -> Swift.Bool
  public func clamp(to size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
}
extension CoreFoundation.CGSize : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CXCallControllerTwin {
  func requestTransaction(with action: CallKit.CXAction, completion: @escaping (Swift.Error?) -> Swift.Void)
}
extension CallKit.CXCallController : DevicesCore.CXCallControllerTwin {
}
public protocol CXProviderTwin {
  func setDelegate(_ delegate: CallKit.CXProviderDelegate?, queue: Dispatch.DispatchQueue?)
  func reportNewIncomingCall(with UUID: Foundation.UUID, update: CallKit.CXCallUpdate, completion: @escaping (Swift.Error?) -> Swift.Void)
  func reportCall(with UUID: Foundation.UUID, updated update: CallKit.CXCallUpdate)
  func reportCall(with UUID: Foundation.UUID, endedAt dateEnded: Foundation.Date?, reason endedReason: CallKit.CXCallEndedReason)
  func reportOutgoingCall(with UUID: Foundation.UUID, startedConnectingAt dateStartedConnecting: Foundation.Date?)
  func reportOutgoingCall(with UUID: Foundation.UUID, connectedAt dateConnected: Foundation.Date?)
}
extension CallKit.CXProvider : DevicesCore.CXProviderTwin {
}
extension DevicesCore.RequestInterceptor {
  public func cachable(cache: DevicesCore.PersistentCache<Foundation.URL, DevicesCore.URLAnswer>) -> DevicesCore.RequestInterceptor<Request, Response>
}
extension DevicesCore.Cache {
  final public class Entry : Foundation.NSDiscardableContent {
    final public let key: Key
    final public let value: Value
    final public let creationDate: Foundation.Date
    public init(key: Key, value: Value, creationDate: Foundation.Date)
    @objc final public func beginContentAccess() -> Swift.Bool
    @objc final public func endContentAccess()
    @objc final public func discardContentIfPossible()
    @objc final public func isContentDiscarded() -> Swift.Bool
    @objc deinit
  }
}
extension DevicesCore.Cache.Entry : Swift.Codable where Key : Swift.Decodable, Key : Swift.Encodable, Value : Swift.Decodable, Value : Swift.Encodable {
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case key
    case value
    case creationDate
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  convenience public init(from decoder: Swift.Decoder) throws
  final public func encode(to encoder: Swift.Encoder) throws
}
public enum EntryLifetimeTag {
}
public typealias EntryLifetime = DevicesCore.Tagged<DevicesCore.EntryLifetimeTag, Foundation.TimeInterval>
extension DevicesCore.Tagged where Tag == DevicesCore.EntryLifetimeTag, T == Swift.Double {
  public static let hour: DevicesCore.EntryLifetime
  public static let day: DevicesCore.EntryLifetime
  public static let year: DevicesCore.EntryLifetime
  public static let forever: DevicesCore.EntryLifetime
}
extension DevicesCore.Cache {
  @_inheritsConvenienceInitializers final public class KeyTracker : ObjectiveC.NSObject, Foundation.NSCacheDelegate {
    @objc final public func cache(_: Foundation.NSCache<Swift.AnyObject, Swift.AnyObject>, willEvictObject obj: Any)
    @objc override dynamic public init()
    @objc deinit
  }
}
extension DevicesCore.Cache : Swift.Codable where Key : Swift.Decodable, Key : Swift.Encodable, Value : Swift.Decodable, Value : Swift.Encodable {
  convenience public init(from decoder: Swift.Decoder) throws
  final public func encode(to encoder: Swift.Encoder) throws
}
extension DevicesCore.Cache {
  @_hasMissingDesignatedInitializers final public class WrappedKey : ObjectiveC.NSObject {
    @objc override final public var hash: Swift.Int {
      @objc get
    }
    @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
    @objc deinit
  }
}
final public class Cache<Key, Value> where Key : Swift.Hashable {
  final public var name: Swift.String {
    get
    set
  }
  public init(cache: Foundation.NSCache<DevicesCore.Cache<Key, Value>.WrappedKey, DevicesCore.Cache<Key, Value>.Entry> = NSCache<WrappedKey, Entry>(), keyTracker: DevicesCore.Cache<Key, Value>.KeyTracker = KeyTracker(), dateProvider: @escaping () -> Foundation.Date = { Date() }, entryLifetime: DevicesCore.EntryLifetime = .day, maximumEntryCount: Swift.Int = 0, maximumTotalCost: Swift.Int = 0)
  final public func insert(_ value: Value, forKey key: Key, cost: Swift.Int = 0)
  final public func value(forKey key: Key) -> Value?
  final public func allObjects() -> [Value]
  final public func removeValue(forKey key: Key)
  final public func clean()
  @objc deinit
}
public struct CallConfiguration : Swift.Equatable {
  public enum Handle : Swift.Equatable {
    case phoneNumber(Swift.String)
    case email(Swift.String)
    case custom(Swift.String)
    public static func == (a: DevicesCore.CallConfiguration.Handle, b: DevicesCore.CallConfiguration.Handle) -> Swift.Bool
  }
  public let name: Swift.String?
  public let handle: DevicesCore.CallConfiguration.Handle
  public let isVideo: Swift.Bool
  public init(name: Swift.String?, handle: DevicesCore.CallConfiguration.Handle, isVideo: Swift.Bool)
  public static func == (a: DevicesCore.CallConfiguration, b: DevicesCore.CallConfiguration) -> Swift.Bool
}
public protocol CallDirector {
  typealias RequestCompletion = (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void
  func requestMute(_ muted: Swift.Bool, _ completion: @escaping Self.RequestCompletion)
  func requestEnd(_ completion: @escaping Self.RequestCompletion)
  func reportEnd(_ reason: DevicesCore.CallEndReason)
}
public protocol IncomingCallDirector : DevicesCore.CallDirector {
  func reportEnd(_ reason: DevicesCore.IncomingCallEndReason)
}
public protocol OutgoingCallDirector : DevicesCore.CallDirector {
  func reportConnected()
}
final public class CallDirectorImpl : DevicesCore.IncomingCallDirector, DevicesCore.OutgoingCallDirector {
  public init(callId: DevicesCore.CallId, provider: DevicesCore.CXProviderTwin, controller: DevicesCore.CXCallControllerTwin, eventHandlerManager: DevicesCore.CallEventHandlerManager, dateProvider: @escaping () -> Foundation.Date = Date.init)
  final public func requestMute(_ muted: Swift.Bool, _ completion: @escaping DevicesCore.CallDirectorImpl.RequestCompletion)
  final public func requestEnd(_ completion: @escaping DevicesCore.CallDirectorImpl.RequestCompletion)
  final public func reportConnected()
  final public func reportEnd(_ reason: DevicesCore.CallEndReason)
  final public func reportEnd(_ reason: DevicesCore.IncomingCallEndReason)
  @objc deinit
}
public enum CallEndReason {
  case failed
  case remoteEnded
  case unanswered
  public static func == (a: DevicesCore.CallEndReason, b: DevicesCore.CallEndReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum IncomingCallEndReason {
  case answeredElsewhere
  case declinedElsewhere
  public static func == (a: DevicesCore.IncomingCallEndReason, b: DevicesCore.IncomingCallEndReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CallEventHandler {
  typealias HandlingCompletion = (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void
  func terminateCall()
  func handleEndCall(_ completion: @escaping Self.HandlingCompletion)
  func handleMuteAction(isMuted: Swift.Bool, _ completion: @escaping Self.HandlingCompletion)
}
public protocol IncomingCallEventHandler : DevicesCore.CallEventHandler {
  func handleAnswerCall(_ completion: @escaping Self.HandlingCompletion)
}
public protocol OutgoingCallEventHandler : DevicesCore.CallEventHandler {
  func handleStartCall(_ completion: @escaping Self.HandlingCompletion)
}
public protocol CallEventHandlerManager : AnyObject {
  func store(_ handler: DevicesCore.IncomingCallEventHandler, for id: DevicesCore.CallId)
  func store(_ handler: DevicesCore.OutgoingCallEventHandler, for id: DevicesCore.CallId)
  func removeHandler(for id: DevicesCore.CallId)
  func clear()
  func fetchIncomingCallHandler(for id: DevicesCore.CallId) -> DevicesCore.IncomingCallEventHandler?
  func fetchOutgoingCallHandler(for id: DevicesCore.CallId) -> DevicesCore.OutgoingCallEventHandler?
  func fetchAnyHandler(for id: DevicesCore.CallId) -> DevicesCore.CallEventHandler?
  func fetchAllHandlers() -> [DevicesCore.CallEventHandler]
}
final public class CallEventHandlerManagerImpl : DevicesCore.CallEventHandlerManager {
  public init()
  final public func store(_ handler: DevicesCore.IncomingCallEventHandler, for id: DevicesCore.CallId)
  final public func store(_ handler: DevicesCore.OutgoingCallEventHandler, for id: DevicesCore.CallId)
  final public func removeHandler(for id: DevicesCore.CallId)
  final public func clear()
  final public func fetchIncomingCallHandler(for id: DevicesCore.CallId) -> DevicesCore.IncomingCallEventHandler?
  final public func fetchOutgoingCallHandler(for id: DevicesCore.CallId) -> DevicesCore.OutgoingCallEventHandler?
  final public func fetchAnyHandler(for id: DevicesCore.CallId) -> DevicesCore.CallEventHandler?
  final public func fetchAllHandlers() -> [DevicesCore.CallEventHandler]
  @objc deinit
}
public typealias CallId = DevicesCore.Tagged<DevicesCore.CallTag, Foundation.UUID>
public enum CallTag {
}
public protocol CallKitFacade {
  func reportIncomingCall(configuration: DevicesCore.CallConfiguration, eventHandler: DevicesCore.IncomingCallEventHandler, _ completion: @escaping (Swift.Result<DevicesCore.IncomingCallDirector, Swift.Error>) -> Swift.Void)
  func startOutgoingCall(configuration: DevicesCore.CallConfiguration, eventHandler: DevicesCore.OutgoingCallEventHandler, _ completion: @escaping (Swift.Result<DevicesCore.OutgoingCallDirector, Swift.Error>) -> Swift.Void)
}
final public class CallKitFacadeImpl {
  public init(provider: DevicesCore.CXProviderTwin, controller: DevicesCore.CXCallControllerTwin, eventHandlerManager: DevicesCore.CallEventHandlerManager, incomingCallDirectorFactory: DevicesCore.Factory<DevicesCore.CallId, DevicesCore.IncomingCallDirector>, outgoingCallDirectorFactory: DevicesCore.Factory<DevicesCore.CallId, DevicesCore.OutgoingCallDirector>, makeCallId: @escaping () -> DevicesCore.CallId = { CallId(value: UUID()) }, dateProvider: @escaping () -> Foundation.Date = Date.init)
  @objc deinit
}
extension DevicesCore.CallKitFacadeImpl : DevicesCore.CallKitFacade {
  final public func reportIncomingCall(configuration: DevicesCore.CallConfiguration, eventHandler: DevicesCore.IncomingCallEventHandler, _ completion: @escaping (Swift.Result<DevicesCore.IncomingCallDirector, Swift.Error>) -> Swift.Void)
  final public func startOutgoingCall(configuration: DevicesCore.CallConfiguration, eventHandler: DevicesCore.OutgoingCallEventHandler, _ completion: @escaping (Swift.Result<DevicesCore.OutgoingCallDirector, Swift.Error>) -> Swift.Void)
}
public enum CameraFlashState {
  case active
  case inactive
  case disabled
  public var isEnabled: Swift.Bool {
    get
  }
  public static func == (a: DevicesCore.CameraFlashState, b: DevicesCore.CameraFlashState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias CanAppOpenURL = (Foundation.URL) -> Swift.Bool
public let caniOSAppOpenURL: (Foundation.URL) -> Swift.Bool
public struct CancelError : Swift.Error, Swift.Equatable {
  public init()
  public static func == (a: DevicesCore.CancelError, b: DevicesCore.CancelError) -> Swift.Bool
}
extension Swift.Error {
  public var isCancel: Swift.Bool {
    get
  }
}
public typealias Cancellable = Combine.Cancellable
public typealias CancellableBag = Swift.Set<Combine.AnyCancellable>
extension Swift.Set where Element == Combine.AnyCancellable {
  @available(*, deprecated, message: "Для поддержки старой сигнатуры сигналов")
  public mutating func cancel()
}
final public class CancellableToken : DevicesCore.CancellationToken, DevicesCore.Cancellable {
  final public var isCancelled: Swift.Bool {
    get
  }
  public init(assertQueue: @escaping DevicesCore.DispatchQueueAssert = {})
  @discardableResult
  final public func register(_ action: @escaping () -> Swift.Void) -> Self
  final public func cancel()
  @objc deinit
}
public protocol CancellationToken {
  var isCancelled: Swift.Bool { get }
  @discardableResult
  func register(_ action: @escaping () -> Swift.Void) -> Self
}
extension Swift.Optional where Wrapped == DevicesCore.CancellationToken {
  public var isCancelled: Swift.Bool {
    get
  }
}
final public class CancellationTokenBag : DevicesCore.Cancellable {
  final public var tokens: [DevicesCore.Cancellable]
  public init()
  final public func add(_ token: DevicesCore.Cancellable)
  final public func cancel()
  @objc deinit
}
extension DevicesCore.CancellationTokenBag {
  final public func token() -> DevicesCore.CancellationToken
}
extension Combine.Cancellable {
  public func store(in bag: DevicesCore.CancellationTokenBag)
}
public protocol CaptureDevice {
  static func authorizationStatus(for mediaType: AVFoundation.AVMediaType) -> AVFoundation.AVAuthorizationStatus
  static func requestAccess(for mediaType: AVFoundation.AVMediaType, completionHandler handler: @escaping (Swift.Bool) -> Swift.Void)
}
extension AVFoundation.AVCaptureDevice : DevicesCore.CaptureDevice {
}
public protocol CaptureDeviceDiscoverySessionTwin {
  var devices: [DevicesCore.CaptureDeviceTwin] { get }
}
public protocol CaptureDeviceTwin {
  var position: AVFoundation.AVCaptureDevice.Position { get }
  var torchMode: AVFoundation.AVCaptureDevice.TorchMode { get set }
  var hasTorch: Swift.Bool { get }
  func lockForConfiguration() throws
  func unlockForConfiguration()
  func makeCaptureInput() throws -> DevicesCore.CaptureInputTwin
}
public protocol CaptureInputTwin {
}
public protocol CaptureOutputResolver {
  func getCaptureOutput() -> AVFoundation.AVCaptureOutput?
}
final public class CaptureOutputResolverImpl : DevicesCore.CaptureOutputResolver {
  public init(sampleBufferDelegate: AVFoundation.AVCaptureVideoDataOutputSampleBufferDelegate, queue: Dispatch.DispatchQueue)
  final public func getCaptureOutput() -> AVFoundation.AVCaptureOutput?
  @objc deinit
}
public protocol CaptureSessionTwin : AnyObject {
  var isRunning: Swift.Bool { get }
  var sessionPreset: AVFoundation.AVCaptureSession.Preset { get set }
  func beginConfiguration()
  func addInput(input: DevicesCore.CaptureInputTwin?)
  func addOutput(output: AVFoundation.AVCaptureOutput?)
  func removeAllInputs()
  func commitConfiguration()
  func makePreviewLayer(orientation: AVFoundation.AVCaptureVideoOrientation) -> AVFoundation.AVCaptureVideoPreviewLayer
  func startRunning()
  func stopRunning()
}
public struct Certificate : Swift.Equatable {
  public enum Extension : Swift.String {
    case cer
    case der
    case pem
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let raw: Security.SecCertificate
  public var data: Foundation.Data {
    get
  }
  public var summary: Swift.String {
    get
  }
  public init(raw: Security.SecCertificate)
  public init?(name: Swift.String, certificateType: DevicesCore.Certificate.Extension, bundle: Foundation.Bundle)
  public static func der(_ name: Swift.String, bundle: Foundation.Bundle) -> DevicesCore.Certificate
  public static func cer(_ name: Swift.String, bundle: Foundation.Bundle) -> DevicesCore.Certificate
  public static func == (a: DevicesCore.Certificate, b: DevicesCore.Certificate) -> Swift.Bool
}
@available(*, deprecated, message: "Используйте CertificateTrustVerifier")
public typealias CertificateDirective = DevicesCore.CertificateTrustVerifier
public struct CertificateTrustVerifier {
  public enum Error : Swift.String, Foundation.LocalizedError {
    case deny
    case recoverableTrustFailure
    case fatalTrustFailure
    case otherError
    public var errorDescription: Swift.String? {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Policy {
    case data
    case basic(anchorCertificatesOnly: Swift.Bool = true)
    case strong(anchorCertificatesOnly: Swift.Bool = true)
  }
  public let certificates: [DevicesCore.Certificate]
  public init(policy: DevicesCore.CertificateTrustVerifier.Policy, certificates: [DevicesCore.Certificate])
  public func validate(_ trust: Security.SecTrust, domain: Swift.String?) throws
  public func validate() throws
}
extension DevicesCore.CertificateTrustVerifier : DevicesCore.TrustVerifier {
}
final public class ChainingPushModifier : DevicesCore.PushModifier {
  public init(_ modifiers: DevicesCore.PushModifier...)
  final public func modify(_ request: UserNotifications.UNNotificationRequest, completion: @escaping (Swift.Result<UserNotifications.UNNotificationContent, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public struct Changeset<Collection> where Collection : Swift.Collection {
  public var data: Collection
  public var sectionDeleted: [Swift.Int]
  public var sectionInserted: [Swift.Int]
  public var sectionUpdated: [Swift.Int]
  public var sectionMoved: [(source: Swift.Int, target: Swift.Int)]
  public var elementDeleted: [DevicesCore.ElementPath]
  public var elementInserted: [DevicesCore.ElementPath]
  public var elementUpdated: [DevicesCore.ElementPath]
  public var elementMoved: [(source: DevicesCore.ElementPath, target: DevicesCore.ElementPath)]
  public init(data: Collection, sectionDeleted: [Swift.Int] = [], sectionInserted: [Swift.Int] = [], sectionUpdated: [Swift.Int] = [], sectionMoved: [(source: Swift.Int, target: Swift.Int)] = [], elementDeleted: [DevicesCore.ElementPath] = [], elementInserted: [DevicesCore.ElementPath] = [], elementUpdated: [DevicesCore.ElementPath] = [], elementMoved: [(source: DevicesCore.ElementPath, target: DevicesCore.ElementPath)] = [])
}
extension DevicesCore.Changeset {
  @inlinable public var sectionChangeCount: Swift.Int {
    get {
		sectionDeleted.count
			+ sectionInserted.count
			+ sectionUpdated.count
			+ sectionMoved.count
	}
  }
  @inlinable public var elementChangeCount: Swift.Int {
    get {
		elementDeleted.count
			+ elementInserted.count
			+ elementUpdated.count
			+ elementMoved.count
	}
  }
  @inlinable public var changeCount: Swift.Int {
    get {
		sectionChangeCount + elementChangeCount
	}
  }
  @inlinable public var hasSectionChanges: Swift.Bool {
    get {
		sectionChangeCount > 0
	}
  }
  @inlinable public var hasElementChanges: Swift.Bool {
    get {
		elementChangeCount > 0
	}
  }
  @inlinable public var hasChanges: Swift.Bool {
    get {
		changeCount > 0
	}
  }
}
extension DevicesCore.Changeset : Swift.Equatable where Collection : Swift.Equatable {
  public static func == (lhs: DevicesCore.Changeset<Collection>, rhs: DevicesCore.Changeset<Collection>) -> Swift.Bool
}
extension DevicesCore.Changeset : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol CleanableCache {
  func clean() throws
}
extension DevicesCore.WebSocket {
  public enum CloseCode : Swift.UInt16 {
    case normal
    case goingAway
    case protocolError
    case protocolUnhandledType
    case noStatusReceived
    case encoding
    case policyViolated
    case messageTooBig
    public init?(rawValue: Swift.UInt16)
    public typealias RawValue = Swift.UInt16
    public var rawValue: Swift.UInt16 {
      get
    }
  }
}
extension Swift.ClosedRange {
  public func clamp(_ value: Bound) -> Bound
}
extension Swift.ClosedRange where Bound : Swift.FloatingPoint {
  public var isFinite: Swift.Bool {
    get
  }
  public var center: Bound {
    get
  }
  public var length: Bound {
    get
  }
}
public struct CodeBlockBackgroundColorAttribute {
  public var color: UIKit.UIColor
  public var inset: CoreFoundation.CGFloat
}
extension Foundation.NSAttributedString.Key {
  public static let codeBlockBackgroundColor: Foundation.NSAttributedString.Key
}
public struct CodeInlineBackgroundColorAttribute {
  public var color: UIKit.UIColor
}
extension Foundation.NSAttributedString.Key {
  public static let codeInlineBackgroundColor: Foundation.NSAttributedString.Key
}
public struct CodeLocationModifier : DevicesCore.LogModifier {
  public init()
  public func modifyMessage(_ message: DevicesCore.LogMessage, with _: DevicesCore.LogLevel, file: Swift.String, line: Swift.Int) -> DevicesCore.LogMessage
}
public typealias CodingPath = [Swift.CodingKey]
extension Swift.Collection {
  public func prettyJson() -> Swift.String
  public func sortedJson() -> Swift.String
}
extension Swift.Dictionary : DevicesCore.PrettyStringConvertible {
  public func makePrettyDescription(additionalOffset: Swift.String?) -> Swift.String
}
extension Swift.Array : DevicesCore.PrettyStringConvertible {
  public func makePrettyDescription(additionalOffset: Swift.String?) -> Swift.String
}
extension Swift.Set : DevicesCore.PrettyStringConvertible {
  public func makePrettyDescription(additionalOffset: Swift.String?) -> Swift.String
}
extension Swift.Collection {
  public subscript(safe index: Self.Index) -> Self.Element? {
    get
  }
}
extension Swift.Collection {
  @inlinable public func nonEmpty() -> Self? {
		isEmpty ? nil : self
	}
}
extension Swift.Collection where Self.Element : UIKit.UIView {
  public func maxWidth() -> CoreFoundation.CGFloat?
  public func maxHeight() -> CoreFoundation.CGFloat?
}
public enum CompilationMode {
  case debug
  case adhoc
  case release
  public static func == (a: DevicesCore.CompilationMode, b: DevicesCore.CompilationMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CompilationModePerformer {
  var mode: DevicesCore.CompilationMode { get }
  @discardableResult
  func perform<T>(inDebug: () -> T, inAdhoc: () -> T, inRelease: () -> T) -> T
  func perform(inDebug: () -> Swift.Void, inAdhoc: () -> Swift.Void, inRelease: () -> Swift.Void)
}
extension DevicesCore.CompilationModePerformer {
  @discardableResult
  public func performInDebug<T>(_ action: () -> T) -> T where T : Swift.ExpressibleByNilLiteral
  @discardableResult
  public func performInAdhoc<T>(_ action: () -> T) -> T where T : Swift.ExpressibleByNilLiteral
  @discardableResult
  public func performInRelease<T>(_ action: () -> T) -> T where T : Swift.ExpressibleByNilLiteral
}
public let compilationModePerformerShared: DevicesCore.CompilationModePerformer
final public class CompositeAnalyticsService : DevicesCore.AnalyticsService {
  public init(services: [DevicesCore.AnalyticsService])
  final public func send(_ event: DevicesCore.AnalyticsEvent)
  @objc deinit
}
public protocol Configurable {
}
extension DevicesCore.Configurable {
  @discardableResult
  public func configure(_ block: (inout Self) throws -> Swift.Void) rethrows -> Self
}
extension DevicesCore.Reachability.Connection {
  public func isReachableViaWifi() -> Swift.Bool
}
public class ConsoleLogger : DevicesCore.Logger {
  public init(print: @escaping (Swift.String) -> Swift.Void = { Swift.print($0) })
  public func logMessage(_ message: @autoclosure () -> (DevicesCore.LogMessage), with _: DevicesCore.LogLevel, file _: Swift.StaticString, line _: Swift.Int)
  @objc deinit
}
public protocol ContentEquatable {
  func isContentEqual(to source: Self) -> Swift.Bool
}
extension DevicesCore.ContentEquatable where Self : Swift.Equatable {
  @inlinable public func isContentEqual(to source: Self) -> Swift.Bool {
		self == source
	}
}
extension Swift.Optional : DevicesCore.ContentEquatable where Wrapped : DevicesCore.ContentEquatable {
  @inlinable public func isContentEqual(to source: Wrapped?) -> Swift.Bool {
		switch (self, source) {
		case let (lhs?, rhs?):
			return lhs.isContentEqual(to: rhs)

		case (.none, .none):
			return true

		case (.none, .some),
			 (.some, .none):
			return false
		}
	}
}
extension Swift.Array : DevicesCore.ContentEquatable where Element : DevicesCore.ContentEquatable {
  @inlinable public func isContentEqual(to source: [Element]) -> Swift.Bool {
		count == source.count
			&& zip(self, source).allSatisfy { $0.isContentEqual(to: $1) }
	}
}
public protocol ContentIdentifiable {
  associatedtype DifferenceIdentifier : Swift.Hashable
  var differenceIdentifier: Self.DifferenceIdentifier { get }
}
extension DevicesCore.ContentIdentifiable where Self : Swift.Hashable {
  @inlinable public var differenceIdentifier: Self {
    get {
		self
	}
  }
}
extension CoreFoundation.CGPoint : DevicesCore.Configurable {
}
extension CoreFoundation.CGSize : DevicesCore.Configurable {
}
extension CoreFoundation.CGRect : DevicesCore.Configurable {
}
extension CoreFoundation.CGVector : DevicesCore.Configurable {
}
extension CoreFoundation.CGRectEdge : DevicesCore.Configurable {
}
public protocol CrashlyticsService {
  func record(_ error: Swift.Error)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.AnyPublisher {
  public init(_ factory: @escaping Combine.Publishers.Create<Output, Failure>.SubscriberHandler)
  public static func create(_ factory: @escaping Combine.Publishers.Create<Output, Failure>.SubscriberHandler) -> Combine.AnyPublisher<Output, Failure>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publishers {
  public struct Create<Output, Failure> : Combine.Publisher where Failure : Swift.Error {
    public typealias SubscriberHandler = (Combine.Publishers.Create<Output, Failure>.Subscriber) -> Combine.Cancellable
    public init(factory: @escaping Combine.Publishers.Create<Output, Failure>.SubscriberHandler)
    public func receive<S>(subscriber: S) where Output == S.Input, Failure == S.Failure, S : Combine.Subscriber
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publishers.Create {
  public struct Subscriber {
    public func send(_ input: Output)
    public func send(completion: Combine.Subscribers.Completion<Failure>)
  }
}
public protocol CryptoGenerator {
  func makeSHA256(_ data: Foundation.Data, encoding: DevicesCore.HashStringEncoding) -> Swift.String
  func makeMD5(_ data: Foundation.Data, encoding: DevicesCore.HashStringEncoding) -> Swift.String
}
public struct CryptoGeneratorImpl : DevicesCore.CryptoGenerator {
  public init()
  public func makeSHA256(_ data: Foundation.Data, encoding: DevicesCore.HashStringEncoding = .utf8) -> Swift.String
  public func makeMD5(_ data: Foundation.Data, encoding: DevicesCore.HashStringEncoding = .utf8) -> Swift.String
}
final public class CurrentValueRelay<Output> : DevicesCore.Relay {
  public typealias Failure = Swift.Never
  final public var value: Output {
    get
  }
  public init(_ value: Output)
  final public func send(_ value: Output)
  final public func subscribe<P>(_ publisher: P) -> DevicesCore.AnyCancellable where Output == P.Output, P : Combine.Publisher, P.Failure == Swift.Never
  final public func receive<S>(subscriber: S) where Output == S.Input, S : Combine.Subscriber, S.Failure == Swift.Never
  @objc deinit
}
public typealias CustomCharacterName = DevicesCore.Tagged<DevicesCore.CharacterNameTag, Swift.String>
public enum CharacterNameTag {
}
public struct DarwinNotification : Swift.Equatable {
  public typealias Name = DevicesCore.Tagged<DevicesCore.DarwinNotification, Swift.String>
  public let name: DevicesCore.DarwinNotification.Name
  public init(name: DevicesCore.DarwinNotification.Name)
  public static func == (a: DevicesCore.DarwinNotification, b: DevicesCore.DarwinNotification) -> Swift.Bool
}
public protocol DarwinNotificationCenter {
  func postNotification(_ notification: DevicesCore.DarwinNotification)
  func observe(_ notification: DevicesCore.DarwinNotification, block: @escaping () -> Swift.Void) -> DevicesCore.Cancellable
}
final public class DarwinNotificationCenterImpl : DevicesCore.DarwinNotificationCenter {
  public init()
  final public func postNotification(_ notification: DevicesCore.DarwinNotification)
  final public func observe(_ notification: DevicesCore.DarwinNotification, block: @escaping () -> Swift.Void) -> DevicesCore.Cancellable
  @objc deinit
}
extension Foundation.Data {
  public init(buffer: AVFAudio.AVAudioPCMBuffer)
}
extension Foundation.Data {
  public func toAudioPayload(audioFormat: DevicesCore.AudioFormat) -> DevicesCore.AudioPayload
}
extension Foundation.Data {
  public init?(base64urlEncoded: Swift.String)
}
extension Foundation.Data {
  public func chunked(size: Swift.Int) -> [Foundation.Data]
}
public typealias CRC32 = Swift.UInt32
public typealias Consumer = (_ data: Foundation.Data) throws -> Swift.Void
public typealias Provider = (_ position: Swift.Int, _ size: Swift.Int) throws -> Foundation.Data
public let crcTable: [Swift.UInt32]
extension Foundation.Data {
  public func crc32(checksum: DevicesCore.CRC32) -> DevicesCore.CRC32
  public static func compress(size: Swift.Int, bufferSize: Swift.Int, provider: (_ position: Swift.Int, _ size: Swift.Int) throws -> Foundation.Data, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> DevicesCore.CRC32
  public static func decompress(size: Swift.Int, bufferSize: Swift.Int, skipCRC32: Swift.Bool, provider: (_ position: Swift.Int, _ size: Swift.Int) throws -> Foundation.Data, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> DevicesCore.CRC32
}
extension Foundation.Data {
  public func pcmDataDuration(audioFormat: DevicesCore.AudioFormat) -> Foundation.TimeInterval
}
extension Foundation.Data {
  public var hexString: Swift.String {
    get
  }
}
extension Foundation.Data : DevicesCore.PrettyStringConvertible {
  public func makePrettyDescription(additionalOffset: Swift.String?) -> Swift.String
}
public enum HashSumTag {
}
public typealias HashSum = DevicesCore.Tagged<DevicesCore.HashSumTag, Foundation.Data>
public enum DataHashSumStrategy {
  case md5
  public static func == (a: DevicesCore.DataHashSumStrategy, b: DevicesCore.DataHashSumStrategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol DataHashSumService {
  func makeContext(for strategy: DevicesCore.DataHashSumStrategy) -> DevicesCore.DataHashSumContext
}
public protocol DataHashSumContext {
  func appendPart(data: Foundation.Data)
  func getCurrentHash() -> DevicesCore.HashSum
}
final public class DataHashSumServiceImpl : DevicesCore.DataHashSumService {
  public init()
  final public func makeContext(for strategy: DevicesCore.DataHashSumStrategy) -> DevicesCore.DataHashSumContext
  @objc deinit
}
final public class DataHashSumContextMD5 : DevicesCore.DataHashSumContext {
  public init()
  final public func appendPart(data: Foundation.Data)
  final public func getCurrentHash() -> DevicesCore.HashSum
  @objc deinit
}
public protocol DateFormatterTwin {
  func date(from: Swift.String) -> Foundation.Date?
  func string(from: Foundation.Date) -> Swift.String
}
extension Foundation.DateFormatter : DevicesCore.DateFormatterTwin {
}
public typealias DateProvider = () -> Foundation.Date
public let makeCurrentDate: () -> Foundation.Date
public protocol Debouncer {
  func closure<Args>(interval: Foundation.TimeInterval, subject: @escaping (Args) -> Swift.Void) -> (Args) -> Swift.Void
}
extension DevicesCore.Debouncer {
  public func voidClosure(interval: Foundation.TimeInterval, subject: @escaping () -> Swift.Void) -> () -> Swift.Void
}
final public class DebouncerImpl : DevicesCore.Debouncer {
  public init(logger: DevicesCore.Logger, dateProvider: @escaping DevicesCore.DateProvider = makeCurrentDate)
  final public func closure<Args>(interval: Foundation.TimeInterval, subject: @escaping (Args) -> Swift.Void) -> (Args) -> Swift.Void
  @objc deinit
}
public protocol DebugFeature : DevicesCore.Feature {
  var title: Swift.String { get }
  var replacement: Self.Value? { get }
  func replace(to value: Self.Value)
  func clear()
}
extension DevicesCore.DebugFeature {
  public var replacementProperty: DevicesCore.MutableProperty<Self.Value?> {
    get
  }
}
@inlinable @inline(__always) public var _isCollectionsInternalCheckingEnabled: Swift.Bool {
  get {
	return false
}
}
extension Swift.DecodingError : DevicesCore.PrettyStringConvertible {
  public func makePrettyDescription(additionalOffset: Swift.String?) -> Swift.String
}
public struct Deeplink {
  public let path: [Swift.String]
  public let query: [Swift.String : Swift.String]
  public init(path: [Swift.String], query: [Swift.String : Swift.String])
}
extension DevicesCore.Deeplink : Swift.Equatable, DevicesCore.PrettyStringConvertible {
  public static func == (a: DevicesCore.Deeplink, b: DevicesCore.Deeplink) -> Swift.Bool
}
extension DevicesCore.Deeplink {
  public init?(url: Foundation.URL)
  public func next() -> (component: Swift.String, deeplink: DevicesCore.Deeplink)?
  public func query<Key>(keyedBy _: Key.Type) -> [Key : Swift.String] where Key : Swift.Hashable, Key : Swift.RawRepresentable, Key.RawValue == Swift.String
}
extension DevicesCore.Tagged where T == DevicesCore.Deeplink {
  @inlinable public func next() -> (component: Swift.String, deeplink: DevicesCore.Deeplink)? {
		value.next()
	}
  @inlinable public func query<Key>(keyedBy key: Key.Type) -> [Key : Swift.String] where Key : Swift.Hashable, Key : Swift.RawRepresentable, Key.RawValue == Swift.String {
		value.query(keyedBy: key)
	}
}
extension DevicesCore.TaggedDeeplinkServicing {
  public func deeplinkService(loggingTo logger: DevicesCore.Logger) -> DevicesCore.URLHandler
}
@_hasMissingDesignatedInitializers final public class DefaultAlert : DevicesCore.AlertScreen {
  final public let viewController: UIKit.UIViewController
  convenience public init(acceptAction: DevicesCore.AlertAction, cancelAction: DevicesCore.AlertAction, title: Swift.String, message: Swift.String?)
  convenience public init(dismissAction: DevicesCore.AlertAction, title: Swift.String, message: Swift.String?)
  final public func onDidDismiss()
  @objc deinit
}
final public class DefaultCancellable : DevicesCore.Cancellable {
  public init(assertQueue: @escaping DevicesCore.DispatchQueueAssert = DispatchQueue.assertOnMain, cancel: @escaping () -> Swift.Void)
  @objc deinit
  final public func cancel()
}
final public class DefaultLinkHandlingPolicy : DevicesCore.LinkHandlingPolicy {
  public init(systemSchemes: Swift.Set<Swift.String> = Set(SystemDeeplinkSchemes.allCases.map(\.rawValue)), trustedDomains: Swift.Set<Swift.String> = [])
  final public func shouldShowExternalLinkAlert(for url: Foundation.URL) -> Swift.Bool
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @available(iOS 14.0, *)
final public class DefaultLocalNetworkPermissionProvider : ObjectiveC.NSObject, DevicesCore.LocalNetworkPermissionProvider {
  public enum BonjourTypeTag {
  }
  public typealias BonjourType = DevicesCore.Tagged<DevicesCore.DefaultLocalNetworkPermissionProvider.BonjourTypeTag, Swift.String>
  final public var authorizationStatus: DevicesCore.AuthorizationStatus {
    get
    set
  }
  @objc deinit
}
@available(iOS 14.0, *)
extension DevicesCore.DefaultLocalNetworkPermissionProvider : Foundation.NetServiceDelegate {
  @objc final public func netServiceDidPublish(_: Foundation.NetService)
}
@available(iOS 14.0, *)
extension DevicesCore.DefaultLocalNetworkPermissionProvider : DevicesCore.LocalNetworkPermissionRequester {
  final public func requestAuthorization(completion: @escaping (DevicesCore.AuthorizationStatus) -> Swift.Void)
}
@available(iOS 14.0, *)
extension DevicesCore.DefaultLocalNetworkPermissionProvider {
  convenience public init(checkBonjourType: DevicesCore.DefaultLocalNetworkPermissionProvider.BonjourType, queue: Dispatch.DispatchQueue = .main, mainThreadRunner: @escaping DevicesCore.MainThreadRunner = onMainThread)
}
@objc @_hasMissingDesignatedInitializers final public class DefaultNavigationStackScreen : ObjectiveC.NSObject, DevicesCore.NavigationStackScreen {
  final public var screens: [DevicesCore.StackScreen] {
    get
  }
  final public var flags: DevicesCore.Property<DevicesCore.StackScreenFlags> {
    get
  }
  final public let viewController: UIKit.UIViewController
  convenience public init(navigationControllerProvider: () -> UIKit.UINavigationController, adjustsContentForSafeAreaInsets: Swift.Bool = true, assertionCaller: DevicesCore.AssertionCaller)
  final public func push(_ screen: DevicesCore.StackScreen, animated: Swift.Bool)
  final public func pop(animated: Swift.Bool)
  final public func popToRoot(animated: Swift.Bool)
  final public func replaceFirst(with screen: DevicesCore.StackScreen, animated: Swift.Bool)
  final public func replaceLast(with screen: DevicesCore.StackScreen, animated: Swift.Bool)
  final public func dismiss(_ screen: DevicesCore.StackScreen, animated: Swift.Bool)
  final public func newStack(_ screens: [DevicesCore.StackScreen], animated: Swift.Bool)
  final public func sizeThatFits(_ size: CoreFoundation.CGSize, safeAreaInsets: UIKit.UIEdgeInsets) -> CoreFoundation.CGSize
  @objc deinit
}
extension DevicesCore.DefaultNavigationStackScreen : UIKit.UINavigationControllerDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func navigationController(_: UIKit.UINavigationController, animationControllerFor operation: UIKit.UINavigationController.Operation, from _: UIKit.UIViewController, to _: UIKit.UIViewController) -> UIKit.UIViewControllerAnimatedTransitioning?
}
@_hasMissingDesignatedInitializers final public class DefaultPushService : DevicesCore.PushService {
  convenience public init(applicationState: DevicesCore.Property<DevicesCore.ApplicationState>, userNotificationCenter: DevicesCore.UserNotificationCenter)
  final public var authorizationStatus: DevicesCore.AuthorizationStatus {
    get
  }
  final public func requestAuthorization(completion: @escaping (DevicesCore.AuthorizationStatus) -> Swift.Void)
  final public var onAuthorizationStatusChange: DevicesCore.Signal<DevicesCore.AuthorizationStatus> {
    get
  }
  @objc deinit
}
extension DevicesCore.RequestInterceptor {
  public static func `default`(parser: DevicesCore.RequestParser<Response>, builder: DevicesCore.RequestBuilder<Request>, urlRequestPerformer: DevicesCore.URLRequestPerformer) -> DevicesCore.RequestInterceptor<Request, Response>
}
public typealias DefaultSignal<Output> = Combine.PassthroughSubject<Output, Swift.Never>
extension Combine.PassthroughSubject where Output == () {
  final public func fire()
}
extension Combine.PassthroughSubject {
  final public func fire(_ data: Output)
}
final public class DefaultURLHandler : DevicesCore.URLHandler {
  public init(context: DevicesCore.URLContext, internalURLHandler: DevicesCore.URLHandler, externalURLHandler: DevicesCore.URLHandler, groupScheduler: DevicesCore.GroupScheduler = DispatchGroup())
  final public func openURL(_ url: Foundation.URL, context: DevicesCore.URLContext, completion: @escaping (DevicesCore.URLHandlerResult) -> Swift.Void)
  final public func canOpen(_ url: Foundation.URL) -> Swift.Bool
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
final public class DemandBuffer<S> where S : Combine.Subscriber {
  public init(subscriber: S)
  final public func buffer(value: S.Input) -> Combine.Subscribers.Demand
  final public func complete(completion: Combine.Subscribers.Completion<S.Failure>)
  final public func demand(_ demand: Combine.Subscribers.Demand) -> Combine.Subscribers.Demand
  @objc deinit
}
public func _addressString(for pointer: Swift.UnsafeRawPointer) -> Swift.String
public func _addressString(for object: Swift.AnyObject) -> Swift.String
@inlinable public func _addressString<T>(for object: Swift.Unmanaged<T>) -> Swift.String where T : AnyObject {
	_addressString(for: object.toOpaque())
}
@inlinable public func _arrayDescription<C>(for elements: C, debug: Swift.Bool = false, typeName: Swift.String? = nil) -> Swift.String where C : Swift.Collection {
	var result = ""
	if let typeName = typeName {
		result += "\(typeName)("
	}
	result += "["
	var first = true
	for item in elements {
		if first {
			first = false
		} else {
			result += ", "
		}
		if debug {
			debugPrint(item, terminator: "", to: &result)
		} else {
			print(item, terminator: "", to: &result)
		}
	}
	result += "]"
	if typeName != nil { result += ")" }
	return result
}
@inlinable public func _dictionaryDescription<Key, Value, C>(for elements: C, debug: Swift.Bool = false, typeName: Swift.String? = nil) -> Swift.String where C : Swift.Collection, C.Element == (key: Key, value: Value) {
	var result = ""
	if let typeName = typeName {
		result += "\(typeName)("
	}

	if elements.isEmpty {
		result += "[:]"
	} else {
		result += "["
		var first = true
		for (key, value) in elements {
			if first {
				first = false
			} else {
				result += ", "
			}
			if debug {
				debugPrint(key, terminator: "", to: &result)
				result += ": "
				debugPrint(value, terminator: "", to: &result)
			} else {
				result += "\(key): \(value)"
			}
		}
		result += "]"
	}

	if typeName != nil {
		result += ")"
	}
	return result
}
public protocol Deserializable {
  init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesCore.Deserializable {
  public init(dict: DevicesCore.DeserializationDictionary, context: DevicesCore.DeserializationContext = .default, codingPath: DevicesCore.CodingPath = []) throws
  public init(jsonData: Foundation.Data, context: DevicesCore.DeserializationContext, codingPath: DevicesCore.CodingPath) throws
  public init(jsonString: Swift.String, context: DevicesCore.DeserializationContext, codingPath: DevicesCore.CodingPath = []) throws
}
public struct DeserializableError : Foundation.LocalizedError, Swift.Equatable, DevicesCore.NamedType {
  public enum DeserializableErrorType : Swift.Equatable {
    case typeMismatch(key: Swift.String, expected: Swift.String, received: Swift.String)
    case keyNotFound(Swift.String)
    case containerTypeMismatch(key: Swift.String, expected: Swift.String, received: Swift.String)
    case invalidJSONObject
    case invalidJSONData
    case rawValueMismatch(key: Swift.String, type: Swift.String, value: Swift.String)
    case dataCorrupted(key: Swift.String, description: Swift.String)
    case other(Foundation.NSError)
    public static func == (a: DevicesCore.DeserializableError.DeserializableErrorType, b: DevicesCore.DeserializableError.DeserializableErrorType) -> Swift.Bool
  }
  public let type: DevicesCore.DeserializableError.DeserializableErrorType
  public let codingPath: DevicesCore.CodingPath
  public var userInfo: [Swift.String : Swift.String]
  public init(type: DevicesCore.DeserializableError.DeserializableErrorType, codingPath: DevicesCore.CodingPath, userInfo: [Swift.String : Swift.String] = [:])
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (lhs: DevicesCore.DeserializableError, rhs: DevicesCore.DeserializableError) -> Swift.Bool
}
extension DevicesCore.DeserializableError : DevicesCore.AnalyticsError {
  public var analyticsInfo: [Swift.String : Any] {
    get
  }
}
extension DevicesCore.DeserializationContainer {
  public func decodeArray<T>(key: Key) throws -> [T] where T : Swift.RawRepresentable
  public func decodeArray<T>(_: T.Type = T.self, key: Key, requireElements: Swift.Bool = false) throws -> [T] where T : DevicesCore.Deserializable
  public func decodeArrayIfPresent<T>(_: T.Type = T.self, key: Key) throws -> [T]? where T : DevicesCore.Deserializable
  public func decodeArrayIfPresent<T>(key: Key) throws -> [T]? where T : Swift.RawRepresentable
  public func decodePartialArray<T>(_: T.Type = T.self, key: Key, failureHandler: (Swift.Error) -> Swift.Void, requireKey: Swift.Bool = true) -> [T] where T : DevicesCore.Deserializable
  public func decodeArray<T>(_: T.Type = T.self, key: Key) throws -> [T] where T : DevicesCore.DirectSerializable
}
extension DevicesCore.DeserializationContainer {
  public func decodeFromString<T>(key: Key) throws -> T where T : DevicesCore.DirectDeserializable, T : Swift.LosslessStringConvertible
  public func decodeValueFromStringIfPresent<T>(key: Key) throws -> T? where T : DevicesCore.DirectDeserializable, T : Swift.LosslessStringConvertible
  public func decodeOptionalValueFromString<T>(key: Key, failureHandler: (Swift.Error) -> Swift.Void) -> T? where T : DevicesCore.DirectDeserializable, T : Swift.LosslessStringConvertible
}
extension DevicesCore.DeserializationContainer {
  public func decodeValue<T>(_: T.Type = T.self, key: Key, of _: T.Type = T.self) throws -> T where T : DevicesCore.Deserializable
  public func decodeValueIfPresent<T>(_: T.Type = T.self, key: Key, of _: T.Type = T.self) throws -> T? where T : DevicesCore.Deserializable
  public func decodeOptionalValue<T>(_: T.Type = T.self, key: Key, failureHandler: (Swift.Error) -> Swift.Void) -> T? where T : DevicesCore.Deserializable
  public func decodeOptionalValue<T>(_: T.Type = T.self, key: Key) -> T? where T : DevicesCore.Deserializable
}
extension DevicesCore.DeserializationContainer {
  public func decodeValue<T>(_: T.Type = T.self, key: Key) throws -> T where T : DevicesCore.DirectDeserializable
  public func decodeValueIfPresent<T>(_: T.Type = T.self, key: Key) throws -> T? where T : DevicesCore.DirectDeserializable
  public func decodeOptionalValue<T>(_: T.Type = T.self, key: Key, failureHandler: (Swift.Error) -> Swift.Void) -> T? where T : DevicesCore.DirectDeserializable
  public func decodeOptionalValue<T>(_: T.Type = T.self, key: Key) -> T? where T : DevicesCore.DirectDeserializable
}
extension DevicesCore.DeserializationContainer {
  public func nestedContainer<T>(keyedBy _: T.Type, forKey key: Key) throws -> DevicesCore.DeserializationContainer<T> where T : Swift.CodingKey, T : Swift.RawRepresentable
  @inlinable public func nestedContainer(forKey key: Key) throws -> DevicesCore.DeserializationContainer<Key> {
		try nestedContainer(keyedBy: Key.self, forKey: key)
	}
  public func nestedContainerFromJson<T>(keyedBy _: T.Type, forKey key: Key) throws -> DevicesCore.DeserializationContainer<T> where T : Swift.CodingKey, T : Swift.RawRepresentable
  @inlinable public func nestedContainerFromJson(forKey key: Key) throws -> DevicesCore.DeserializationContainer<Key> {
		try nestedContainerFromJson(keyedBy: Key.self, forKey: key)
	}
}
extension DevicesCore.DeserializationContainer {
  public func decodeValue<T>(_: T.Type = T.self, key: Key) throws -> T where T : Swift.RawRepresentable, T.RawValue : DevicesCore.DirectDeserializable
  public func decodeValueIfPresent<T>(_: T.Type = T.self, key: Key, skipping rawValues: [T.RawValue] = []) throws -> T? where T : Swift.RawRepresentable, T.RawValue : DevicesCore.DirectDeserializable, T.RawValue : Swift.Equatable
  public func decodeOptionalValue<T>(_: T.Type = T.self, key: Key, failureHandler: (Swift.Error) -> Swift.Void) -> T? where T : Swift.RawRepresentable, T.RawValue : DevicesCore.DirectDeserializable
  public func decodeOptionalValue<T>(_: T.Type = T.self, key: Key) -> T? where T : Swift.RawRepresentable, T.RawValue : DevicesCore.DirectDeserializable
}
extension DevicesCore.DeserializationContainer {
  public func decodeUrl(key: Key) throws -> Foundation.URL
  public func decodeUrlIfPresent(key: Key, skipping rawValues: [Swift.String] = []) throws -> Foundation.URL?
  public func decodeOptionalUrl(key: Key, failureHandler: (Swift.Error) -> Swift.Void) -> Foundation.URL?
  public func decodeOptionalUrl(key: Key) -> Foundation.URL?
}
public struct DeserializationContainer<Key> where Key : Swift.CodingKey, Key : Swift.RawRepresentable {
  public let body: DevicesCore.DeserializationDictionary
  public var deserializer: DevicesCore.Deserializer {
    get
  }
  public init(body: DevicesCore.DeserializationDictionary, context: DevicesCore.DeserializationContext, codingPath: DevicesCore.CodingPath)
  public init(body: [Swift.AnyHashable : Any], context: DevicesCore.DeserializationContext, codingPath: DevicesCore.CodingPath)
}
extension DevicesCore.DeserializationContainer {
  public func decodeValue(key: Key) throws -> Foundation.NSDictionary
  public func decodeArray(key: Key) throws -> [DevicesCore.Deserializer]
  public func makeJSONString(sortedKeys: Swift.Bool = false, inPrettyAndStableFormat: Swift.Bool = false) throws -> Swift.String
  public func serialize() throws -> DevicesCore.JSONDictionary
  @inlinable public func containsKey(_ key: Key) -> Swift.Bool {
		body[key.stringValue] != nil
	}
  public func makeError(for type: DevicesCore.DeserializableError.DeserializableErrorType) -> DevicesCore.DeserializableError
  public func decodeSingleValue<T>(_: T.Type = T.self) throws -> T where T : DevicesCore.Deserializable
  public func decodePartialArray<T>(_: T.Type = T.self, key: Key, requireKey: Swift.Bool = true) -> [T] where T : DevicesCore.Deserializable
}
extension DevicesCore.KeyValueContextKey where Tag == DevicesCore.DeserializationContextTag {
  public static var failureHandler: DevicesCore.DeserializationContextKey<DevicesCore.DeserializationFailureHandler> {
    get
  }
}
public enum DeserializationContextTag {
}
public typealias DeserializationContext = DevicesCore.KeyValueContext<DevicesCore.DeserializationContextTag>
public typealias DeserializationContextKey<Value> = DevicesCore.KeyValueContextKey<Value, DevicesCore.DeserializationContextTag>
extension DevicesCore.KeyValueContext where Tag == DevicesCore.DeserializationContextTag {
  public init(label: Swift.String = #fileID, logger: DevicesCore.Logger)
  public init(label: Swift.String = #fileID, failureHandler: DevicesCore.DeserializationFailureHandler)
}
extension DevicesCore.KeyValueContext where Tag == DevicesCore.DeserializationContextTag {
  @available(*, deprecated, message: "Use DeserializationContext.init() instead")
  public static let `default`: DevicesCore.DeserializationContext
}
public typealias DeserializationDictionary = [Swift.String : Any]
public typealias DeserializationArray = [DevicesCore.DeserializationDictionary]
public typealias ConvertableFromString = DevicesCore.DirectDeserializable & Swift.LosslessStringConvertible
extension Swift.Dictionary : DevicesCore.Deserializable where Key == Swift.String, Value == Any {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension Swift.Dictionary where Key == Swift.String, Value == Any {
  public init(jsonString: Swift.String, codingPath: DevicesCore.CodingPath) throws
  public init(jsonData data: Foundation.Data, codingPath: DevicesCore.CodingPath) throws
  public func makeJSONString(codingPath: DevicesCore.CodingPath, sortedKeys: Swift.Bool = false, inPrettyAndStableFormat: Swift.Bool = false) throws -> Swift.String
  public func serialize() throws -> DevicesCore.JSONDictionary
}
public protocol DeserializationFailureHandler {
  func handle(_ error: Swift.Error)
}
extension DevicesCore.Deserializer {
  public var failureHandler: DevicesCore.DeserializationFailureHandler {
    get
  }
}
public struct Deserializer {
  public let context: DevicesCore.DeserializationContext
  public init(body: DevicesCore.DeserializationDictionary, context: DevicesCore.DeserializationContext, codingPath: DevicesCore.CodingPath)
  public func container<Key>(keyedBy _: Key.Type) -> DevicesCore.DeserializationContainer<Key> where Key : Swift.CodingKey, Key : Swift.RawRepresentable
  public func buildError(for type: DevicesCore.DeserializableError.DeserializableErrorType) -> DevicesCore.DeserializableError
}
extension DevicesCore.Deserializer {
  public func makeJSONDictionary() throws -> DevicesCore.JSONDictionary
  public func makeJSONString() throws -> Swift.String
  public func isBodyEqual(to deserializer: DevicesCore.Deserializer) -> Swift.Bool
}
public struct DetectionStyle {
}
extension DevicesCore.DetectionStyle {
  public static func defaultStyle() -> DevicesCore.DetectionStyle
  public static func customStyle(withColor color: UIKit.UIColor) -> DevicesCore.DetectionStyle
}
extension Swift.Dictionary {
  public static func + (lhs: Swift.Dictionary<Key, Value>, rhs: Swift.Dictionary<Key, Value>) -> Swift.Dictionary<Key, Value>
  public static func += (lhs: inout Swift.Dictionary<Key, Value>, rhs: Swift.Dictionary<Key, Value>)
  public func mapKeys<T>(_ transform: (Key) throws -> T) rethrows -> [T : Value] where T : Swift.Hashable
  @inlinable public func nonnull<T>() -> [Key : T] where Value == T? {
		compactMapValues { $0 }
	}
  @inlinable public init<S>(uniquing values: S) where Key == Value.ID, Value : Swift.Identifiable, Value == S.Element, S : Swift.Sequence {
		self.init(values.map { ($0.id, $0) }, uniquingKeysWith: { _, rhs in rhs })
	}
}
public func mergingOptional<K, V>(_ lhs: [K : V]?, _ rhs: [K : V]?, uniquingKeysWith: (V, V) throws -> V) rethrows -> [K : V]? where K : Swift.Hashable
extension Swift.Dictionary where Value == Any {
  @inlinable public func nonnullAndFlat() -> [Key : Value] {
		reduce(into: [Key: Value]()) { result, item in
			switch item.value as Any {
			// swiftlint:disable syntactic_sugar
			// swiftformat:disable typeSugar
			case Optional<Any>.none:
				return
			case let wrapped as Any?:
				// swiftlint:enable syntactic_sugar
				if let value = wrapped.flatMap({ $0 }) {
					result[item.key] = value
				}
			default:
				result[item.key] = item.value
			}
		}
	}
}
public typealias Differentiable = DevicesCore.ContentEquatable & DevicesCore.ContentIdentifiable
public protocol DifferentiableSection : DevicesCore.ContentEquatable, DevicesCore.ContentIdentifiable {
  associatedtype Collection : Swift.Collection where Self.Collection.Element : DevicesCore.ContentEquatable, Self.Collection.Element : DevicesCore.ContentIdentifiable
  var elements: Self.Collection { get }
  init<C>(source: Self, elements: C) where C : Swift.Collection, C.Element == Self.Collection.Element
}
public protocol DirectDeserializable {
}
extension Swift.Bool : DevicesCore.DirectDeserializable {
}
extension Swift.String : DevicesCore.DirectDeserializable {
}
extension Swift.Double : DevicesCore.DirectDeserializable {
}
extension Swift.Float : DevicesCore.DirectDeserializable {
}
extension Swift.Int : DevicesCore.DirectDeserializable {
}
extension Swift.Int8 : DevicesCore.DirectDeserializable {
}
extension Swift.Int16 : DevicesCore.DirectDeserializable {
}
extension Swift.Int32 : DevicesCore.DirectDeserializable {
}
extension Swift.Int64 : DevicesCore.DirectDeserializable {
}
extension Swift.UInt : DevicesCore.DirectDeserializable {
}
extension Swift.UInt8 : DevicesCore.DirectDeserializable {
}
extension Swift.UInt16 : DevicesCore.DirectDeserializable {
}
extension Swift.UInt32 : DevicesCore.DirectDeserializable {
}
extension Swift.UInt64 : DevicesCore.DirectDeserializable {
}
extension CoreFoundation.CGFloat : DevicesCore.DirectDeserializable {
}
extension Foundation.Date : DevicesCore.DirectDeserializable {
}
extension Swift.Array : DevicesCore.DirectDeserializable where Element : DevicesCore.DirectDeserializable {
}
extension Swift.Dictionary : DevicesCore.DirectDeserializable where Key : Swift.StringProtocol, Value : DevicesCore.DirectDeserializable {
}
public protocol DirectSerializable {
}
extension Swift.Bool : DevicesCore.DirectSerializable {
}
extension Swift.String : DevicesCore.DirectSerializable {
}
extension Swift.Double : DevicesCore.DirectSerializable {
}
extension Swift.Float : DevicesCore.DirectSerializable {
}
extension Swift.Int : DevicesCore.DirectSerializable {
}
extension Swift.Int8 : DevicesCore.DirectSerializable {
}
extension Swift.Int16 : DevicesCore.DirectSerializable {
}
extension Swift.Int32 : DevicesCore.DirectSerializable {
}
extension Swift.Int64 : DevicesCore.DirectSerializable {
}
extension Swift.UInt : DevicesCore.DirectSerializable {
}
extension Swift.UInt8 : DevicesCore.DirectSerializable {
}
extension Swift.UInt16 : DevicesCore.DirectSerializable {
}
extension Swift.UInt32 : DevicesCore.DirectSerializable {
}
extension Swift.UInt64 : DevicesCore.DirectSerializable {
}
extension CoreFoundation.CGFloat : DevicesCore.DirectSerializable {
}
extension Foundation.NSNull : DevicesCore.DirectSerializable {
}
extension Foundation.Date : DevicesCore.DirectSerializable {
}
extension Swift.Array : DevicesCore.DirectSerializable where Element : DevicesCore.DirectSerializable {
}
extension Swift.Dictionary : DevicesCore.DirectSerializable where Key == Swift.String, Value == DevicesCore.DirectSerializable {
}
extension Foundation.NSDictionary : DevicesCore.DirectSerializable {
}
extension Foundation.NSString : DevicesCore.DirectSerializable {
}
extension Foundation.NSNumber : DevicesCore.DirectSerializable {
}
extension Foundation.NSArray : DevicesCore.DirectSerializable {
}
public protocol DirectStorable {
}
extension Swift.Bool : DevicesCore.DirectStorable {
}
extension Foundation.NSString : DevicesCore.DirectStorable {
}
extension Swift.String : DevicesCore.DirectStorable {
}
extension Foundation.NSNumber : DevicesCore.DirectStorable {
}
extension Swift.Double : DevicesCore.DirectStorable {
}
extension Swift.Float : DevicesCore.DirectStorable {
}
extension Swift.Int : DevicesCore.DirectStorable {
}
extension Swift.Int8 : DevicesCore.DirectStorable {
}
extension Swift.Int16 : DevicesCore.DirectStorable {
}
extension Swift.Int32 : DevicesCore.DirectStorable {
}
extension Swift.Int64 : DevicesCore.DirectStorable {
}
extension Swift.UInt : DevicesCore.DirectStorable {
}
extension Swift.UInt8 : DevicesCore.DirectStorable {
}
extension Swift.UInt16 : DevicesCore.DirectStorable {
}
extension Swift.UInt32 : DevicesCore.DirectStorable {
}
extension Swift.UInt64 : DevicesCore.DirectStorable {
}
extension CoreFoundation.CGFloat : DevicesCore.DirectStorable {
}
extension Foundation.NSData : DevicesCore.DirectStorable {
}
extension Foundation.Data : DevicesCore.DirectStorable {
}
extension Swift.Array : DevicesCore.DirectStorable where Element : DevicesCore.DirectStorable {
}
public typealias DispatchQueueAssert = () -> Swift.Void
extension Dispatch.DispatchQueue {
  @inlinable public static func assertOnMain() {
		// swiftlint:disable:next system_asserts
		assert(on: .main)
	}
  @inlinable public static func assert(on queue: Dispatch.DispatchQueue) {
		compilationModePerformerShared.perform(
			inDebug: { dispatchPrecondition(condition: .onQueue(queue)) },
			inAdhoc: {},
			inRelease: {}
		)
	}
  @inlinable public func assertOnMe() {
		// swiftlint:disable:next system_asserts
		DispatchQueue.assert(on: self)
	}
}
extension DevicesCore.DispatchSerialQueue : Combine.Scheduler {
  public typealias SchedulerTimeType = Dispatch.DispatchQueue.SchedulerTimeType
  public typealias SchedulerOptions = Dispatch.DispatchQueue.SchedulerOptions
  public var now: Dispatch.DispatchQueue.SchedulerTimeType {
    get
  }
  public var minimumTolerance: Dispatch.DispatchQueue.SchedulerTimeType.Stride {
    get
  }
  public func schedule(options: Dispatch.DispatchQueue.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Dispatch.DispatchQueue.SchedulerTimeType, tolerance: Dispatch.DispatchQueue.SchedulerTimeType.Stride, options: Dispatch.DispatchQueue.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Dispatch.DispatchQueue.SchedulerTimeType, interval: Dispatch.DispatchQueue.SchedulerTimeType.Stride, tolerance: Dispatch.DispatchQueue.SchedulerTimeType.Stride, options: Dispatch.DispatchQueue.SchedulerOptions?, _ action: @escaping () -> Swift.Void) -> DevicesCore.Cancellable
}
final public class DisposableHandle {
  public init(closure: @escaping () -> Swift.Void)
  final public func invoke()
  @objc deinit
}
public struct DomainTrustVerifier : DevicesCore.TrustVerifier {
  public init(domains: [Swift.String : DevicesCore.TrustVerifier], global: DevicesCore.TrustVerifier, isPinningOn: Swift.Bool)
  public func validate(_ trust: Security.SecTrust, domain: Swift.String?) throws
}
public protocol DownloadController : AnyObject {
  func downloadResources(onlyStartupObjects: Swift.Bool)
}
public struct DownloadURLAnswer : Swift.Equatable, DevicesCore.PrettyStringConvertible {
  public let url: Foundation.URL?
  public let httpCode: Swift.Int?
  public let httpHeaders: [DevicesCore.HTTPHeaderName : Swift.String]?
  public init(url: Foundation.URL?, httpCode: Swift.Int?, httpHeaders: [DevicesCore.HTTPHeaderName : Swift.String]?)
  public static func == (a: DevicesCore.DownloadURLAnswer, b: DevicesCore.DownloadURLAnswer) -> Swift.Bool
}
extension DevicesCore.DownloadURLAnswer {
  public enum Error : Foundation.LocalizedError {
    case unknownError
    public var errorDescription: Swift.String? {
      get
    }
    public static func == (a: DevicesCore.DownloadURLAnswer.Error, b: DevicesCore.DownloadURLAnswer.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var httpError: DevicesCore.HTTPError? {
    get
  }
  public func validate() -> Swift.Result<DevicesCore.DownloadURLAnswer, Swift.Error>
}
extension Combine.Publisher where Self.Failure == Swift.Never {
  public func eraseToDrivePublisher(shareLastElement: Swift.Bool = false) -> DevicesCore.DriverPublisher<Self.Output>
}
extension Combine.Publisher {
  public func eraseToDrivePublisher(shareLastElement: Swift.Bool = false, replaceErrorOutput: Self.Output) -> DevicesCore.DriverPublisher<Self.Output>
}
public struct DriverPublisher<Output> : Combine.Publisher {
  public typealias Output = Output
  public typealias Failure = Swift.Never
  public init<P>(upstream: P, shareLastElement: Swift.Bool, replaceErrorOutput: Output) where Output == P.Output, P : Combine.Publisher
  public init<P>(upstream: P, shareLastElement: Swift.Bool) where Output == P.Output, P : Combine.Publisher, P.Failure == Swift.Never
  public func receive<S>(subscriber: S) where Output == S.Input, S : Combine.Subscriber, S.Failure == Swift.Never
}
public struct ElementPath : Swift.Hashable {
  public var element: Swift.Int
  public var section: Swift.Int
  public init(element: Swift.Int, section: Swift.Int)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesCore.ElementPath, b: DevicesCore.ElementPath) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesCore.ElementPath : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
final public class EmptyCancellable : DevicesCore.Cancellable {
  final public var isCancelled: Swift.Bool
  public init()
  final public func cancel()
  @objc deinit
}
public typealias EncodedAudioRecorderFactory = DevicesCore.Factory<Swift.Void, Swift.Result<DevicesCore.AudioRecorder, Swift.Error>>
public enum EncodedAudioRecorderFactoryError : Swift.Error {
  case wrongAudioFormat
  public static func == (a: DevicesCore.EncodedAudioRecorderFactoryError, b: DevicesCore.EncodedAudioRecorderFactoryError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesCore.Factory where Arg == (), Item == Swift.Result<DevicesCore.AudioRecorder, Swift.Error> {
  public init(audioFormat: DevicesCore.AudioFormat, audioSessionConfigurator: DevicesCore.AudioSessionConfigurator, applicationState: DevicesCore.Property<DevicesCore.ApplicationState>, osLogger: DevicesCore.OSLogger?, callbackAsyncPerformer: DevicesCore.AsyncPerformer, audioStreamEncoderFactory: DevicesCore.AudioStreamEncoderFactory, encodedAudioFormat: DevicesCore.AudioFormat)
}
public struct Entry : Swift.Equatable {
  public enum EntryType : Swift.Int {
    case file
    case directory
    case symlink
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public func path(using encoding: Swift.String.Encoding) -> Swift.String
  public var path: Swift.String {
    get
  }
  public var fileAttributes: [Foundation.FileAttributeKey : Any] {
    get
  }
  public var checksum: DevicesCore.CRC32 {
    get
  }
  public var type: DevicesCore.Entry.EntryType {
    get
  }
  public var compressedSize: Swift.Int {
    get
  }
  public var uncompressedSize: Swift.Int {
    get
  }
  public static func == (lhs: DevicesCore.Entry, rhs: DevicesCore.Entry) -> Swift.Bool
}
extension Swift.Equatable {
  public func overwrite(values: [Self], with replaceValue: Self?) -> Self?
}
extension Swift.Error {
  public var localizedErrorDescription: Swift.String {
    get
  }
  public var nsCode: Swift.Int {
    get
  }
  public var nsDomain: Swift.String {
    get
  }
}
extension DevicesCore.WebSocket {
  public enum ErrorType : Swift.Error {
    case outputStreamWriteError
    case compressionError
    case invalidSSLError
    case writeTimeoutError
    case protocolError
    case upgradeError
    case closeError
    case sessionError
    public static func == (a: DevicesCore.WebSocket.ErrorType, b: DevicesCore.WebSocket.ErrorType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public protocol ExpressibleByNoArguments {
  init()
}
public typealias ExternalLinkAlertFactory = DevicesCore.Factory<DevicesCore.ExternalLinkAlertParameters, DevicesCore.AlertScreen>
public struct ExternalLinkAlertParameters {
  public let acceptAction: () -> Swift.Void
  public let cancelAction: () -> Swift.Void
  public init(acceptAction: @escaping () -> Swift.Void, cancelAction: @escaping () -> Swift.Void)
}
final public class ExternalLinkHandlerImpl : DevicesCore.URLHandler {
  public init(alertPresenter: DevicesCore.AlertPresenter, alertFactory: DevicesCore.ExternalLinkAlertFactory, uiApplication: DevicesCore.UIApplicationTwin, linkHandlingPolicy: DevicesCore.LinkHandlingPolicy)
  final public func openURL(_ url: Foundation.URL, context _: DevicesCore.URLContext, completion: @escaping (DevicesCore.URLHandlerResult) -> Swift.Void)
  final public func canOpen(_ url: Foundation.URL) -> Swift.Bool
  @objc deinit
}
final public class FPSCounter {
  final public var fps: DevicesCore.Signal<Swift.Int> {
    get
  }
  public init(measureFrequency: Foundation.TimeInterval)
  @objc deinit
  final public func start()
  final public func stop()
}
public struct Factory<Arg, Item> {
  @usableFromInline
  internal let block: (Arg) -> Item
  public init(constant: Item)
  public init(block: @escaping (Arg) -> Item)
  @inlinable public func make(_ parameters: Arg) -> Item {
		block(parameters)
	}
  @inlinable public func callAsFunction(_ args: Arg) -> Item {
		make(args)
	}
}
extension DevicesCore.Factory where Arg == () {
  @inlinable public func make() -> Item {
		block(())
	}
  @inlinable public func callAsFunction() -> Item {
		make()
	}
}
final public class FailingAssertionCaller : DevicesCore.AssertionCaller {
  final public var isDebugFailureEnabled: DevicesCore.Property<Swift.Bool>
  final public var logger: DevicesCore.Logger?
  public init(compilationModePerformer: DevicesCore.CompilationModePerformer = compilationModePerformerShared, isDebugFailureEnabled: DevicesCore.Property<Swift.Bool> = Property(true))
  final public func debug(_ message: @autoclosure () -> Swift.String, prefix: @autoclosure () -> Swift.String, suffix: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt)
  final public func fatal(_ message: @autoclosure () -> Swift.String, prefix: @autoclosure () -> Swift.String, suffix: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt)
  final public func conditional(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String, prefix: @autoclosure () -> Swift.String, suffix: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt)
  @objc deinit
}
public protocol Feature {
  associatedtype Value
  var sources: [DevicesCore.Property<Self.Value?>] { get }
  var `default`: Self.Value { get }
}
extension DevicesCore.Feature {
  public var current: Self.Value {
    get
  }
  public var property: DevicesCore.Property<Self.Value> {
    get
  }
}
extension DevicesCore.Features {
  public static func remoteConfig<Item>(default: Item, local: DevicesCore.Property<Item?>? = nil, remote: DevicesCore.Property<Item?>? = nil) -> DevicesCore.Property<Item>
}
public enum Features {
}
public protocol FeedbackGeneratorTwin {
  func feedback(_ feedback: DevicesCore.TapticFeedback)
}
final public class FeedbackGeneratorTwinImpl : DevicesCore.FeedbackGeneratorTwin {
  public init()
  final public func feedback(_ feedback: DevicesCore.TapticFeedback)
  @objc deinit
}
public struct FileHandleAdapter : DevicesCore.FileHandleTwin {
  public init(forReadingFrom url: Foundation.URL) throws
  public init(forWritingTo url: Foundation.URL) throws
  public init(forUpdating url: Foundation.URL) throws
  public func readToEnd() throws -> Foundation.Data?
  public func read(upToCount count: Swift.Int) throws -> Foundation.Data?
  public func offset() throws -> Swift.UInt64
  public func seekToEnd() throws -> Swift.UInt64
  public func write(contentsOf data: Foundation.Data) throws
  public func close() throws
}
public protocol FileHandleTwin {
  func readToEnd() throws -> Foundation.Data?
  func read(upToCount count: Swift.Int) throws -> Foundation.Data?
  func offset() throws -> Swift.UInt64
  func seekToEnd() throws -> Swift.UInt64
  func write(contentsOf data: Foundation.Data) throws
  func close() throws
}
final public class FileLogger : DevicesCore.Logger {
  public init(stream: Swift.TextOutputStream)
  convenience public init(fileManager: Foundation.FileManager) throws
  final public func logMessage(_ message: @autoclosure () -> (DevicesCore.LogMessage), with _: DevicesCore.LogLevel, file _: Swift.StaticString, line _: Swift.Int)
  @objc deinit
}
extension Foundation.FileManager {
  public func zipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL, shouldKeepParent: Swift.Bool = true, compressionMethod: DevicesCore.CompressionMethod = .none, progress: Foundation.Progress? = nil) throws
  public func unzipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil, preferredEncoding: Swift.String.Encoding? = nil) throws
}
extension Foundation.URL {
  public func isContained(in parentDirectoryURL: Foundation.URL) -> Swift.Bool
}
public protocol FileManagerTwin {
  func contentsOfDirectory(atPath path: Swift.String) throws -> [Swift.String]
  func contentsOfDirectory(at url: Foundation.URL, includingPropertiesForKeys keys: [Foundation.URLResourceKey]?, options mask: Foundation.FileManager.DirectoryEnumerationOptions) throws -> [Foundation.URL]
  func fileExists(atPath path: Swift.String, isDirectory: Swift.UnsafeMutablePointer<ObjectiveC.ObjCBool>?) -> Swift.Bool
  func fileExists(atPath path: Swift.String) -> Swift.Bool
  func contents(atPath path: Swift.String) -> Foundation.Data?
  func createFile(atPath path: Swift.String, contents data: Foundation.Data?, attributes: [Foundation.FileAttributeKey : Any]?) -> Swift.Bool
  func createDirectory(at url: Foundation.URL, withIntermediateDirectories createIntermediates: Swift.Bool, attributes: [Foundation.FileAttributeKey : Any]?) throws
  func isDeletableFile(atPath path: Swift.String) -> Swift.Bool
  func isReadableFile(atPath path: Swift.String) -> Swift.Bool
  func removeItem(at URL: Foundation.URL) throws
  func moveItem(at srcURL: Foundation.URL, to dstURL: Foundation.URL) throws
  func zipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL, shouldKeepParent: Swift.Bool, compressionMethod: DevicesCore.CompressionMethod, progress: Foundation.Progress?) throws
  func unzipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL, skipCRC32: Swift.Bool, progress: Foundation.Progress?, preferredEncoding: Swift.String.Encoding?) throws
  func url(for directory: Foundation.FileManager.SearchPathDirectory, in domain: Foundation.FileManager.SearchPathDomainMask, appropriateFor url: Foundation.URL?, create shouldCreate: Swift.Bool) throws -> Foundation.URL
  func attributesOfItem(atPath path: Swift.String) throws -> [Foundation.FileAttributeKey : Any]
  func containerURL(forSecurityApplicationGroupIdentifier groupIdentifier: Swift.String) -> Foundation.URL?
  func subpaths(atPath path: Swift.String) -> [Swift.String]?
  func getTotalAllocatedSize(for url: Foundation.URL) throws -> Swift.Int
  func save(data: Foundation.Data, to location: Foundation.URL, options: Foundation.Data.WritingOptions) throws
  func data(at url: Foundation.URL) throws -> Foundation.Data
}
extension DevicesCore.FileManagerTwin {
  public func createDirectory(at url: Foundation.URL) throws
  public func contentsOfDirectory(at url: Foundation.URL) throws -> [Foundation.URL]
  public func contentsOfDirectory(at url: Foundation.URL, options mask: Foundation.FileManager.DirectoryEnumerationOptions) throws -> [Foundation.URL]
  public func createDirectory(at url: Foundation.URL, withIntermediateDirectories: Swift.Bool) throws
  public func zipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL) throws
  public func unzipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL, progress: Foundation.Progress?) throws
  public func getSize(for url: Foundation.URL) -> Swift.Int?
  public func getCreationDate(for url: Foundation.URL) -> Foundation.Date?
}
extension Foundation.FileManager : DevicesCore.FileManagerTwin {
  public func getTotalAllocatedSize(for url: Foundation.URL) throws -> Swift.Int
  public func save(data: Foundation.Data, to location: Foundation.URL, options: Foundation.Data.WritingOptions) throws
  public func data(at url: Foundation.URL) throws -> Foundation.Data
}
public protocol FileURLFactory {
  func makeURL(for resource: DevicesCore.ResourceTag) -> Foundation.URL
}
public protocol FileUnarchiver : AnyObject {
  func unarchive(object: DevicesCore.FileUnarchieverObject, cancelToken: DevicesCore.CancellationToken?, completion: @escaping (Swift.Result<Swift.Void, DevicesCore.FileUnarchiverError>) -> Swift.Void)
}
public enum FileUnarchiverError : Swift.Error {
  case extractionFailed(Swift.Error)
  public var isCancelled: Swift.Bool {
    get
  }
}
final public class FileUnarchiverImpl : DevicesCore.FileUnarchiver {
  public init(fileManager: DevicesCore.FileManagerTwin, logger: DevicesCore.Logger?, mainThreadRunner: @escaping DevicesCore.MainThreadRunner = onMainThread)
  final public func unarchive(object: DevicesCore.FileUnarchieverObject, cancelToken: DevicesCore.CancellationToken?, completion: @escaping (Swift.Result<Swift.Void, DevicesCore.FileUnarchiverError>) -> Swift.Void)
  @objc deinit
}
public struct FileUnarchieverObject {
  public let inputURL: Foundation.URL
  public let extractionURL: Foundation.URL
  public let outputURL: Foundation.URL
  public let unzipArtefacts: [Foundation.URL]
  public init(inputURL: Foundation.URL, extractionURL: Foundation.URL, outputURL: Foundation.URL, unzipArtefacts: [Foundation.URL])
}
public protocol FileUnarchiverObjectFactory {
  func makeUnarchiverObject() -> DevicesCore.FileUnarchieverObject
}
final public class FileUnarchiverObjectFactoryImpl : DevicesCore.FileUnarchiverObjectFactory {
  public init(id: DevicesCore.ResourceID, inputURL: Foundation.URL, hasRootFolder: Swift.Bool)
  final public func makeUnarchiverObject() -> DevicesCore.FileUnarchieverObject
  @objc deinit
}
extension Swift.FixedWidthInteger {
  @inlinable public func _roundUpToPowerOfTwo() -> Self {
		guard self > 0 else { return 0 }
		let l = Self.bitWidth - (self &- 1).leadingZeroBitCount
		return 1 << l
	}
}
public struct FlaggedStackScreen : DevicesCore.StackScreen {
  public var viewController: UIKit.UIViewController {
    get
  }
  public var flags: DevicesCore.Property<DevicesCore.StackScreenFlags>
  public init(subject: DevicesCore.StackScreen, flags: DevicesCore.Property<DevicesCore.StackScreenFlags>)
  public func sizeThatFits(_ size: CoreFoundation.CGSize, safeAreaInsets: UIKit.UIEdgeInsets) -> CoreFoundation.CGSize
}
extension DevicesCore.StackScreen {
  @inlinable public func flags(_ flags: DevicesCore.StackScreenFlags) -> DevicesCore.FlaggedStackScreen {
		FlaggedStackScreen(subject: self, flags: Property(flags))
	}
  @inlinable public func flags(_ flags: DevicesCore.Property<DevicesCore.StackScreenFlags>) -> DevicesCore.FlaggedStackScreen {
		FlaggedStackScreen(subject: self, flags: flags)
	}
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func flatMapFirst<P>(_ transform: @escaping (Self.Output) -> P) -> Combine.Publishers.FlatMap<Combine.Publishers.HandleEvents<P>, Combine.Publishers.Filter<Self>> where P : Combine.Publisher, Self.Failure == P.Failure
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func flatMapLatest<P>(_ transform: @escaping (Self.Output) -> P) -> Combine.Publishers.SwitchToLatest<P, Combine.Publishers.Map<Self, P>> where P : Combine.Publisher, Self.Failure == P.Failure
}
extension Swift.FloatingPoint where Self.Stride : Swift.ExpressibleByFloatLiteral {
  public static var accuracy: Self.Stride {
    get
  }
  public func isAlmostGreater(_ number: Self, accuracy: Self.Stride = Self.accuracy) -> Swift.Bool
  public func isAlmostGreaterOrEqual(_ number: Self, accuracy: Self.Stride = Self.accuracy) -> Swift.Bool
  public func isAlmostLess(_ number: Self, accuracy: Self.Stride = Self.accuracy) -> Swift.Bool
  public func isAlmostLessOrEqual(_ number: Self, accuracy: Self.Stride = Self.accuracy) -> Swift.Bool
  public func isAlmostEqual(_ number: Self, accuracy: Self.Stride = Self.accuracy) -> Swift.Bool
}
extension ObjectiveC.NSObject : DevicesCore.Configurable {
}
extension Foundation.URL : DevicesCore.Configurable {
}
public typealias MainThreadRunner = (@escaping () -> Swift.Void) -> Swift.Void
public typealias MainThreadAsyncRunner = (@escaping () -> Swift.Void) -> Swift.Void
public typealias DelayedMainThreadRunner = (Foundation.TimeInterval, @escaping () -> Swift.Void) -> Swift.Void
public typealias DelayedMainThreadRunnerCancellable = (Foundation.TimeInterval, @escaping () -> Swift.Void) -> DevicesCore.Cancellable
public func onMainThread(_ block: @escaping () -> Swift.Void)
public func onMainThreadAsync(_ block: @escaping () -> Swift.Void)
public func onMainThread<T>(_ closure: @escaping (T) -> Swift.Void) -> (T) -> Swift.Void
public func syncOnMainThread(_ block: @escaping () -> Swift.Void)
extension Foundation.Thread {
  @available(*, deprecated, message: "use AssertionCaller.assertIsMain")
  public static func assertIsMain()
  @available(*, deprecated, message: "use AssertionCaller.assertIsNotMain")
  public static func assertIsNotMain()
}
public func after(_ delay: Foundation.TimeInterval, execute block: @escaping () -> Swift.Void)
public func afterCancellable(_ delay: Foundation.TimeInterval, execute block: @escaping () -> Swift.Void) -> DevicesCore.Cancellable
public func afterCancellable(_ delay: Foundation.TimeInterval, qos: Dispatch.DispatchQoS, flags: Dispatch.DispatchWorkItemFlags, execute block: @escaping () -> Swift.Void) -> DevicesCore.Cancellable
extension Dispatch.DispatchWorkItem : DevicesCore.Cancellable {
}
extension DevicesCore.KeychainAttributes.ItemClass {
  public struct GenericPassword : Swift.Equatable, Swift.Hashable, DevicesCore.PrettyStringConvertible {
    public let accessGroup: DevicesCore.KeychainAttributes.AccessGroup?
    public let accessibility: DevicesCore.KeychainAttributes.Accessibility
    public let label: DevicesCore.KeychainAttributes.Label?
    public let isInvisible: Swift.Bool
    public let serviceName: DevicesCore.KeychainAttributes.Service
    public let account: DevicesCore.KeychainAttributes.Account
    public init(accessibility: DevicesCore.KeychainAttributes.Accessibility, label: DevicesCore.KeychainAttributes.Label?, isInvisible: Swift.Bool, serviceName: DevicesCore.KeychainAttributes.Service, account: DevicesCore.KeychainAttributes.Account, accessGroup: DevicesCore.KeychainAttributes.AccessGroup?)
    public static func == (a: DevicesCore.KeychainAttributes.ItemClass.GenericPassword, b: DevicesCore.KeychainAttributes.ItemClass.GenericPassword) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
final public class GestureActionAdapter<Gesture> where Gesture : UIKit.UIGestureRecognizer {
  public init(assertionCaller: DevicesCore.AssertionCaller, action: @escaping (Gesture) -> Swift.Void)
  @objc final public func handleGesture(_ sender: UIKit.UIGestureRecognizer)
  @objc deinit
}
public protocol GroupScheduler : AnyObject {
  func enter()
  func leave()
  func wait()
  func notifyOnMain(_ work: @escaping () -> Swift.Void)
  func notify(queue: DevicesCore.SerialQueue, work: @escaping () -> Swift.Void)
}
extension Dispatch.DispatchGroup : DevicesCore.GroupScheduler {
  public func notify(queue: DevicesCore.SerialQueue, work: @escaping () -> Swift.Void)
  public func notifyOnMain(_ work: @escaping () -> Swift.Void)
}
public struct HTTPError : Foundation.LocalizedError, Swift.Equatable {
  public let code: Swift.Int
  public let data: Foundation.Data?
  public var errorDescription: Swift.String? {
    get
  }
  public var isErrorCode: Swift.Bool {
    get
  }
  public init(code: Swift.Int, data: Foundation.Data? = nil)
  public init?(response: Foundation.HTTPURLResponse, receivedData: Foundation.Data?)
  public static func == (a: DevicesCore.HTTPError, b: DevicesCore.HTTPError) -> Swift.Bool
}
extension DevicesCore.HTTPError : DevicesCore.PrettyStringConvertible {
  public func makePrettyDescription(additionalOffset: Swift.String?) -> Swift.String
}
extension DevicesCore.HTTPError : DevicesCore.AnalyticsError {
  public var analyticsInfo: [Swift.String : Any] {
    get
  }
}
public typealias HTTPHeaderName = DevicesCore.Tagged<DevicesCore.HTTPHeaderTag, Swift.String>
public enum HTTPHeaderTag {
}
extension DevicesCore.Tagged where Tag == DevicesCore.HTTPHeaderTag, T == Swift.String {
  public static let contentType: DevicesCore.HTTPHeaderName
}
public enum HTTPMethod : Swift.String, Swift.Equatable {
  case get
  case post
  case update
  case delete
  case put
  case patch
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct HTTPResponse : Swift.Equatable {
  public let code: Swift.Int
  public let data: Foundation.Data?
  public let headers: [DevicesCore.HTTPHeaderName : Swift.String]?
  public var contentType: Swift.String? {
    get
  }
  public init?(code: Swift.Int, data: Foundation.Data?, headers: [DevicesCore.HTTPHeaderName : Swift.String]?)
  public static func == (a: DevicesCore.HTTPResponse, b: DevicesCore.HTTPResponse) -> Swift.Bool
}
extension DevicesCore.HTTPResponse : DevicesCore.PrettyStringConvertible {
}
public enum HashStringEncoding {
  case utf8
  case base64
  case base64URL
  public static func == (a: DevicesCore.HashStringEncoding, b: DevicesCore.HashStringEncoding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct HashTrustVerifier : DevicesCore.TrustVerifier {
  public func validate(_ trust: Security.SecTrust, domain _: Swift.String?) throws
}
extension DevicesCore.HashTrustVerifier {
  public init(pins: Swift.Set<Swift.String>)
}
public enum HashTrustVerifierError : Swift.Error, Swift.Equatable {
  case badChain
  case unknownPin
  case badHash
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesCore.HashTrustVerifierError, b: DevicesCore.HashTrustVerifierError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public typealias HashValidator = (Foundation.Data, _ hash: Swift.String) -> (Swift.Bool)
extension DevicesCore.CryptoGenerator {
  public func isMD5UTF8Valid(_ data: Foundation.Data, hash: Swift.String) -> Swift.Bool
}
extension DevicesCore.RequestInterceptor {
  public func hashable(hash: Swift.String, hashValidator: @escaping DevicesCore.HashValidator, analytics: DevicesCore.AnalyticsService, osLogger: DevicesCore.OSLogger?) -> DevicesCore.RequestInterceptor<Request, Response>
}
public protocol HeaderBuilder {
  func makeHeader() -> Swift.Result<DevicesCore.Headers, Swift.Error>
}
extension DevicesCore.HeaderBuilders {
  public enum ContentType : Swift.String {
    case json
    case xWwwFormUrlEncoded
    case zip
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public static func contentType(_ contentType: DevicesCore.HeaderBuilders.ContentType) -> DevicesCore.HeaderBuilder
}
extension DevicesCore.HeaderBuilders {
  public struct InfoType : Swift.OptionSet {
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public static let platform: DevicesCore.HeaderBuilders.InfoType
    public static let appVersion: DevicesCore.HeaderBuilders.InfoType
    public static let all: DevicesCore.HeaderBuilders.InfoType
    public typealias ArrayLiteralElement = DevicesCore.HeaderBuilders.InfoType
    public typealias Element = DevicesCore.HeaderBuilders.InfoType
    public typealias RawValue = Swift.Int
  }
  public static func info(_ infoType: DevicesCore.HeaderBuilders.InfoType) -> DevicesCore.HeaderBuilder
}
public enum HeaderBuilders {
  public static func sequence(_ builders: [DevicesCore.HeaderBuilder]) -> DevicesCore.HeaderBuilder
  public static func dictionary(_ dictionary: DevicesCore.Headers) -> DevicesCore.HeaderBuilder
  public static func closure(_ makeHeaders: @escaping () -> Swift.Result<DevicesCore.Headers, Swift.Error>) -> DevicesCore.HeaderBuilder
  public static func authorization(bearer: Swift.String) -> DevicesCore.HeaderBuilder
  public static func single(_ key: DevicesCore.HeadersKey, value: Swift.String) -> DevicesCore.HeaderBuilder
  public static func cookies() -> DevicesCore.HeaderBuilder
}
public struct HeaderSequenceBuilder : DevicesCore.HeaderBuilder, DevicesCore.Configurable {
  public var builders: [DevicesCore.HeaderBuilder]
  public mutating func append(_ builder: DevicesCore.HeaderBuilder)
  public func makeHeader() -> Swift.Result<DevicesCore.Headers, Swift.Error>
}
public typealias Headers = [DevicesCore.HeadersKey : Swift.String]
extension Swift.Dictionary where Key == DevicesCore.HeadersKey, Value == Swift.String {
  public mutating func setReplacingKey(_ key: DevicesCore.HeadersKey, value: Swift.String)
}
extension Foundation.URLRequest {
  public mutating func setHeader(_ fields: DevicesCore.Headers)
}
@propertyWrapper public struct HeadersKey {
  public var comparableValue: Swift.String {
    get
  }
  public var wrappedValue: Swift.String {
    get
    set
  }
  public var projectedValue: DevicesCore.HeadersKey {
    get
  }
}
extension DevicesCore.HeadersKey {
  public init(wrappedValue: Swift.String, isForceCapital: Swift.Bool = true)
  public static func capitalized(_ value: Swift.String) -> DevicesCore.HeadersKey
  public static func unmodified(_ value: Swift.String) -> DevicesCore.HeadersKey
}
extension DevicesCore.HeadersKey : Swift.Hashable {
  public static func == (lhs: DevicesCore.HeadersKey, rhs: DevicesCore.HeadersKey) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesCore.HeadersKey : Swift.ExpressibleByStringLiteral, Swift.ExpressibleByUnicodeScalarLiteral, Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String.ExtendedGraphemeClusterLiteralType
  public typealias UnicodeScalarLiteralType = Swift.String.UnicodeScalarLiteralType
  public init(stringLiteral value: Swift.String)
  public init(extendedGraphemeClusterLiteral value: Swift.String.ExtendedGraphemeClusterLiteralType)
  public init(unicodeScalarLiteral value: Swift.String.UnicodeScalarLiteralType)
  public typealias StringLiteralType = Swift.String
}
extension DevicesCore.Application {
  public func makeIdleTimerState() -> DevicesCore.MutableProperty<Swift.Bool>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func ignoreFailure(completeImmediately: Swift.Bool = true) -> Combine.AnyPublisher<Self.Output, Swift.Never>
  public func ignoreFailure<NewFailure>(setFailureType newFailureType: NewFailure.Type, completeImmediately: Swift.Bool = true) -> Combine.AnyPublisher<Self.Output, NewFailure> where NewFailure : Swift.Error
}
public protocol ImageID {
  var name: Swift.String { get }
}
extension DevicesCore.ImageID where Self : Swift.RawRepresentable, Self.RawValue == Swift.String {
  public var name: Swift.String {
    get
  }
}
extension DevicesCore.ImageID {
  public func isImageEqual(to imageID: DevicesCore.ImageID) -> Swift.Bool
}
extension DevicesCore.ImageID {
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension Swift.Optional where Wrapped == DevicesCore.ImageID {
  public func isImageEqual(to imageID: DevicesCore.ImageID?) -> Swift.Bool
}
extension DevicesCore.ImageProvider {
  public func prefixed(by prefix: Swift.String) -> DevicesCore.ImageProvider
}
public protocol ImageProvider {
  func getImage(for id: DevicesCore.ImageID) -> UIKit.UIImage?
}
extension DevicesCore.ImageProvider {
  public func image(for id: DevicesCore.ImageID, logger: DevicesCore.Logger? = nil) -> UIKit.UIImage
}
public enum ImageProviders {
  public static func closure(_ block: @escaping (DevicesCore.ImageID) -> UIKit.UIImage?) -> DevicesCore.ImageProvider
  public static func bundle(_ bundle: Foundation.Bundle) -> DevicesCore.ImageProvider
  public static func sequence(_ providers: [DevicesCore.ImageProvider]) -> DevicesCore.ImageProvider
}
extension Swift.FixedWidthInteger {
  @inlinable @inline(__always) internal var _nonzeroBitCount: Self {
    get {
		Self(truncatingIfNeeded: nonzeroBitCount)
	}
  }
  @inlinable @inline(__always) public func _rank(ofBit bit: Swift.UInt) -> Swift.Int {
		assert(bit < Self.bitWidth)
		let mask: Self = (1 &<< bit) &- 1
		return (self & mask).nonzeroBitCount
	}
}
extension Swift.UInt {
  @_effects(releasenone) public func _bit(ranked n: Swift.Int) -> Swift.UInt?
}
extension Swift.UInt32 {
  @_effects(releasenone) public func _bit(ranked n: Swift.Int) -> Swift.UInt?
}
extension Swift.UInt16 {
  @_effects(releasenone) public func _bit(ranked n: Swift.Int) -> Swift.UInt?
}
public struct JSAPI : Swift.Equatable {
  public typealias Source = DevicesCore.Tagged<DevicesCore.JSAPI, Swift.String>
  public let name: Swift.String
  public let source: DevicesCore.JSAPI.Source
  public let methods: [DevicesCore.JSFunction.Name : DevicesCore.JSFunction]
  public let globalVariables: [DevicesCore.JSVariable]
  public init(name: Swift.String, methods: [DevicesCore.JSFunction], globalVariables: [DevicesCore.JSVariable] = [])
  public static func == (a: DevicesCore.JSAPI, b: DevicesCore.JSAPI) -> Swift.Bool
}
public protocol JSExecutor {
  typealias Completion = (Swift.Result<Any?, Swift.Error>) -> Swift.Void
  func execute(_ script: Swift.String, completion: @escaping Self.Completion)
}
public struct JSFunction {
  public typealias Callback = (DevicesCore.DeserializationDictionary) -> Swift.Void
  public typealias Name = DevicesCore.Tagged<DevicesCore.JSFunction, Swift.String>
  public struct Argument : Swift.Equatable {
    public let name: Swift.String
    public init(name: Swift.String)
    public static func == (a: DevicesCore.JSFunction.Argument, b: DevicesCore.JSFunction.Argument) -> Swift.Bool
  }
  public let name: DevicesCore.JSFunction.Name
  public let args: [DevicesCore.JSFunction.Argument]
  public let callback: DevicesCore.JSFunction.Callback
  public init(name: DevicesCore.JSFunction.Name, args: [DevicesCore.JSFunction.Argument], callback: @escaping DevicesCore.JSFunction.Callback)
}
extension DevicesCore.JSFunction : Swift.Equatable {
  public static func == (lhs: DevicesCore.JSFunction, rhs: DevicesCore.JSFunction) -> Swift.Bool
}
public typealias JSONArray = [DevicesCore.JSONDictionary]
public typealias JSONDictionary = [Swift.String : DevicesCore.DirectSerializable]
extension Swift.Dictionary : DevicesCore.Serializable where Key == Swift.String, Value == DevicesCore.DirectSerializable {
  public func toJSONDictionary() -> DevicesCore.JSONDictionary
}
extension Foundation.JSONSerialization {
  public class func jsonString(withJSONObject object: DevicesCore.Serializable, sortedKeys: Swift.Bool = false, inPrettyAndStableFormat: Swift.Bool = false, errorHandler: DevicesCore.SerializationErrorHandler) -> DevicesCore.JSONString
  public class func jsonData(withJSONObject object: DevicesCore.Serializable, sortedKeys: Swift.Bool = false, inPrettyAndStableFormat: Swift.Bool = false, errorHandler: DevicesCore.SerializationErrorHandler) -> Foundation.Data
  public class func jsonData(with object: DevicesCore.Serializable, sortedKeys: Swift.Bool = false, inPrettyAndStableFormat: Swift.Bool = false) throws -> Foundation.Data
  public class func jsonString(withJSONObject object: Any, sortedKeys: Swift.Bool = false, inPrettyAndStableFormat: Swift.Bool = false) throws -> DevicesCore.JSONString
  public class func jsonData(withJSONObject object: Any, sortedKeys: Swift.Bool = false, inPrettyAndStableFormat: Swift.Bool = false) throws -> Foundation.Data
}
public struct JSVariable : Swift.Equatable {
  public let name: Swift.String
  public let body: Swift.String
  public init(name: Swift.String, body: Swift.String)
  public static func == (a: DevicesCore.JSVariable, b: DevicesCore.JSVariable) -> Swift.Bool
}
public func == <T, V>(lhs: Swift.KeyPath<T, V>, rhs: V) -> (T) -> Swift.Bool where V : Swift.Equatable
public func != <T, V>(lhs: Swift.KeyPath<T, V>, rhs: V) -> (T) -> Swift.Bool where V : Swift.Equatable
public protocol KeyValueCodable {
  associatedtype Encoder
  associatedtype Decoder
  func data(using encoder: Self.Encoder) throws -> Foundation.Data
  init(data: Foundation.Data, using decoder: Self.Decoder) throws
}
extension DevicesCore.KeyValueCodable where Self : Swift.Decodable, Self : Swift.Encodable {
  @inlinable public func data(using encoder: Foundation.JSONEncoder) throws -> Foundation.Data {
		try encoder.encode(self)
	}
  @inlinable public init(data: Foundation.Data, using decoder: Foundation.JSONDecoder) throws {
		self = try decoder.decode(Self.self, from: data)
	}
}
extension DevicesCore.KeyValueCodable where Self : DevicesCore.Deserializable, Self : DevicesCore.Serializable {
  @inlinable public func data(using _: Swift.Void) throws -> Foundation.Data {
		try self.toJSONData(inPrettyAndStableFormat: false)
	}
  @inlinable public init(data: Foundation.Data, using _: Swift.Void) throws {
		try self.init(
			jsonData: data,
			context: .default,
			codingPath: []
		)
	}
}
public struct KeyValueCoder<Key, Value> where Key : Swift.RawRepresentable, Key.RawValue == Swift.String {
  public init(decode: @escaping (DevicesCore.KeyValueContainer<Key>) -> Value?, encode: @escaping (Value?, DevicesCore.KeyValueContainer<Key>) -> Swift.Void)
  public func decode(_ container: DevicesCore.KeyValueContainer<Key>) -> Value?
  public func encode(_ value: Value?, to container: DevicesCore.KeyValueContainer<Key>)
}
extension DevicesCore.KeyValueCoder where Value : DevicesCore.Deserializable, Value : DevicesCore.Serializable {
  public init(_ key: Key, assertionCaller: DevicesCore.AssertionCaller = assertionCallerShared)
}
extension DevicesCore.KeyValueCoder where Value : DevicesCore.DirectStorable {
  public init(_ key: Key)
}
extension DevicesCore.KeyValueCoder where Value : Swift.RawRepresentable, Value.RawValue : DevicesCore.DirectStorable {
  public init(_ key: Key)
}
public struct KeyValueContainer<Key> where Key : Swift.RawRepresentable, Key.RawValue == Swift.String {
  public init(storage: DevicesCore.KeyValueStorage, assertionCaller: DevicesCore.AssertionCaller = assertionCallerShared)
  public func value(forKey key: Key) -> DevicesCore.DirectStorable?
  public func array(forKey key: Key) -> [DevicesCore.DirectStorable]?
  public func insert(_ object: DevicesCore.DirectStorable, forKey key: Key)
  public func set(_ object: DevicesCore.DirectStorable?, forKey key: Key)
  public func remove(forKey key: Key)
}
extension DevicesCore.KeyValueStorage {
  public func container<Key>(keyedBy _: Key.Type = Key.self) -> DevicesCore.KeyValueContainer<Key> where Key : Swift.RawRepresentable, Key.RawValue == Swift.String
}
extension DevicesCore.KeyValueContainer {
  public func mutableProperty<Value>(using coder: DevicesCore.KeyValueCoder<Key, Value>, assertQueue: @escaping DevicesCore.DispatchQueueAssert = DispatchQueue.assertOnMain) -> DevicesCore.MutableProperty<Value?>
  @inlinable public func asMutableProperty<Value>(_: Value.Type = Value.self, forKey key: Key, assertQueue: @escaping DevicesCore.DispatchQueueAssert = DispatchQueue.assertOnMain) -> DevicesCore.MutableProperty<Value?> where Value : DevicesCore.DirectStorable {
		mutableProperty(using: KeyValueCoder(key), assertQueue: assertQueue)
	}
  @inlinable public func asMutableProperty<Value>(_: Value.Type = Value.self, forKey key: Key, assertQueue: @escaping DevicesCore.DispatchQueueAssert = DispatchQueue.assertOnMain) -> DevicesCore.MutableProperty<Value?> where Value : Swift.RawRepresentable, Value.RawValue : DevicesCore.DirectStorable {
		mutableProperty(using: KeyValueCoder(key), assertQueue: assertQueue)
	}
  public func asMutableProperty<Value>(forKey key: Key, default: Value, assertQueue: @escaping DevicesCore.DispatchQueueAssert = DispatchQueue.assertOnMain) -> DevicesCore.MutableProperty<Value> where Value : Swift.RawRepresentable, Value.RawValue : DevicesCore.DirectStorable
  public func asMutableProperty<Value>(forKey key: Key, default: Value, assertQueue: @escaping DevicesCore.DispatchQueueAssert = DispatchQueue.assertOnMain) -> DevicesCore.MutableProperty<Value> where Value : DevicesCore.DirectStorable
}
public struct KeyValueContext<Tag> : DevicesCore.Configurable {
  public let label: Swift.String
  public var isEmpty: Swift.Bool {
    get
  }
  public func contains<Value>(_ key: DevicesCore.KeyValueContextKey<Value, Tag>) -> Swift.Bool
  public subscript<Value>(key: DevicesCore.KeyValueContextKey<Value, Tag>) -> Value {
    get
    set
  }
  public subscript<Wrapped>(required key: DevicesCore.KeyValueContextKey<Wrapped?, Tag>) -> Wrapped {
    get
  }
}
extension DevicesCore.KeyValueContext {
  public static func designatedInitForConcreteImplementations(label: Swift.String) -> DevicesCore.KeyValueContext<Tag>
}
public struct KeyValueContextKey<Value, Tag> {
  public enum RecoveryAction {
    case useDefault(@autoclosure () -> Value)
    case fatalError
  }
  public let id: Swift.String
  public let recoveryAction: DevicesCore.KeyValueContextKey<Value, Tag>.RecoveryAction
  public init(id: Swift.String, whenMissing: DevicesCore.KeyValueContextKey<Value, Tag>.RecoveryAction)
}
extension DevicesCore.KeyValueContextKey {
  public init(id: Swift.String) where Value : Swift.ExpressibleByNilLiteral
}
public protocol KeyValueStorage {
  func object(forKey key: Swift.String) -> DevicesCore.DirectStorable?
  func array(forKey key: Swift.String) -> [DevicesCore.DirectStorable]?
  func setObject(_ object: DevicesCore.DirectStorable, forKey key: Swift.String)
  func removeObject(forKey key: Swift.String)
}
public protocol KeyValueStorageCleaner {
  func clean()
}
extension DevicesCore.AttributedStorage where Attributes == DevicesCore.KeychainAttributes {
  public func mutableProperty<Value>(attributes: DevicesCore.KeychainAttributes, assertionCaller: DevicesCore.AssertionCaller, encoder: Value.Encoder, decoder: Value.Decoder) -> DevicesCore.MutableProperty<Value?> where Value : DevicesCore.KeyValueCodable
  public func mutableProperty(attributes: DevicesCore.KeychainAttributes, assertionCaller: DevicesCore.AssertionCaller) -> DevicesCore.MutableProperty<Swift.String?>
  public func mutableProperty(attributes: DevicesCore.KeychainAttributes, assertionCaller: DevicesCore.AssertionCaller) -> DevicesCore.MutableProperty<Swift.Bool?>
  public func mutableProperty<Value>(attributes: DevicesCore.KeychainAttributes, assertionCaller: DevicesCore.AssertionCaller, decode: @escaping (Foundation.Data) throws -> Value, encode: @escaping (Value) throws -> Foundation.Data) -> DevicesCore.MutableProperty<Value?>
}
public struct KeychainAttributes : DevicesCore.StorageItemAttributes, Swift.Equatable, Swift.Hashable {
  public enum ItemClass : Swift.Equatable, Swift.Hashable {
    case genericPassword(DevicesCore.KeychainAttributes.ItemClass.GenericPassword)
    public static func == (a: DevicesCore.KeychainAttributes.ItemClass, b: DevicesCore.KeychainAttributes.ItemClass) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let itemClass: DevicesCore.KeychainAttributes.ItemClass
  public init(itemClass: DevicesCore.KeychainAttributes.ItemClass)
  public static func == (a: DevicesCore.KeychainAttributes, b: DevicesCore.KeychainAttributes) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesCore.KeychainAttributes : DevicesCore.PrettyStringConvertible {
}
extension DevicesCore.KeychainAttributes {
  public static func genericPassword(accessibility: DevicesCore.KeychainAttributes.Accessibility, label: DevicesCore.KeychainAttributes.Label? = nil, isInvisible: Swift.Bool, serviceName: DevicesCore.KeychainAttributes.Service, account: DevicesCore.KeychainAttributes.Account, accessGroup: DevicesCore.KeychainAttributes.AccessGroup? = nil) -> DevicesCore.KeychainAttributes
}
public enum KeychainError : Foundation.LocalizedError {
  case unexpectedValueType(CoreFoundation.CFTypeRef)
  public var errorDescription: Swift.String? {
    get
  }
}
public enum KeychainOperationStatus : Foundation.LocalizedError {
  case success
  case unimplemented
  case diskFull
  case io
  case opWr
  case param
  case wrPerm
  case allocate
  case userCanceled
  case badReq
  case internalComponent
  case notAvailable
  case readOnly
  case authFailed
  case noSuchKeychain
  case invalidKeychain
  case duplicateKeychain
  case duplicateCallback
  case invalidCallback
  case duplicateItem
  case itemNotFound
  case bufferTooSmall
  case dataTooLarge
  case noSuchAttr
  case invalidItemRef
  case invalidSearchRef
  case noSuchClass
  case noDefaultKeychain
  case interactionNotAllowed
  case readOnlyAttr
  case wrongSecVersion
  case keySizeNotAllowed
  case noStorageModule
  case noCertificateModule
  case noPolicyModule
  case interactionRequired
  case dataNotAvailable
  case dataNotModifiable
  case createChainFailed
  case invalidPrefsDomain
  case inDarkWake
  case aclNotSimple
  case policyNotFound
  case invalidTrustSetting
  case noAccessForItem
  case invalidOwnerEdit
  case trustNotAvailable
  case unsupportedFormat
  case unknownFormat
  case keyIsSensitive
  case multiplePrivKeys
  case passphraseRequired
  case invalidPasswordRef
  case invalidTrustSettings
  case noTrustSettings
  case pkcs12VerifyFailure
  case invalidCertificate
  case notSigner
  case policyDenied
  case invalidKey
  case decode
  case `internal`
  case unsupportedAlgorithm
  case unsupportedOperation
  case unsupportedPadding
  case itemInvalidKey
  case itemInvalidKeyType
  case itemInvalidValue
  case itemClassMissing
  case itemMatchUnsupported
  case useItemListUnsupported
  case useKeychainUnsupported
  case useKeychainListUnsupported
  case returnDataUnsupported
  case returnAttributesUnsupported
  case returnRefUnsupported
  case returnPersitentRefUnsupported
  case valueRefUnsupported
  case valuePersistentRefUnsupported
  case returnMissingPointer
  case matchLimitUnsupported
  case itemIllegalQuery
  case waitForCallback
  case missingEntitlement
  case upgradePending
  case mpSignatureInvalid
  case otrTooOld
  case otrIDTooNew
  case serviceNotAvailable
  case insufficientClientID
  case deviceReset
  case deviceFailed
  case appleAddAppACLSubject
  case applePublicKeyIncomplete
  case appleSignatureMismatch
  case appleInvalidKeyStartDate
  case appleInvalidKeyEndDate
  case conversionError
  case appleSSLv2Rollback
  case quotaExceeded
  case fileTooBig
  case invalidDatabaseBlob
  case invalidKeyBlob
  case incompatibleDatabaseBlob
  case incompatibleKeyBlob
  case hostNameMismatch
  case unknownCriticalExtensionFlag
  case noBasicConstraints
  case noBasicConstraintsCA
  case invalidAuthorityKeyID
  case invalidSubjectKeyID
  case invalidKeyUsageForPolicy
  case invalidExtendedKeyUsage
  case invalidIDLinkage
  case pathLengthConstraintExceeded
  case invalidRoot
  case crlExpired
  case crlNotValidYet
  case crlNotFound
  case crlServerDown
  case crlBadURI
  case unknownCertExtension
  case unknownCRLExtension
  case crlNotTrusted
  case crlPolicyFailed
  case idpFailure
  case smimeEmailAddressesNotFound
  case smimeBadExtendedKeyUsage
  case smimeBadKeyUsage
  case smimeKeyUsageNotCritical
  case smimeNoEmailAddress
  case smimeSubjAltNameNotCritical
  case sslBadExtendedKeyUsage
  case ocspBadResponse
  case ocspBadRequest
  case ocspUnavailable
  case ocspStatusUnrecognized
  case endOfData
  case incompleteCertRevocationCheck
  case networkFailure
  case ocspNotTrustedToAnchor
  case recordModified
  case ocspSignatureError
  case ocspNoSigner
  case ocspResponderMalformedReq
  case ocspResponderInternalError
  case ocspResponderTryLater
  case ocspResponderSignatureRequired
  case ocspResponderUnauthorized
  case ocspResponseNonceMismatch
  case codeSigningBadCertChainLength
  case codeSigningNoBasicConstraints
  case codeSigningBadPathLengthConstraint
  case codeSigningNoExtendedKeyUsage
  case codeSigningDevelopment
  case resourceSignBadCertChainLength
  case resourceSignBadExtKeyUsage
  case trustSettingDeny
  case invalidSubjectName
  case unknownQualifiedCertStatement
  case mobileMeRequestQueued
  case mobileMeRequestRedirected
  case mobileMeServerError
  case mobileMeServerNotAvailable
  case mobileMeServerAlreadyExists
  case mobileMeServerServiceErr
  case mobileMeRequestAlreadyPending
  case mobileMeNoRequestPending
  case mobileMeCSRVerifyFailure
  case mobileMeFailedConsistencyCheck
  case notInitialized
  case invalidHandleUsage
  case pvcReferentNotFound
  case functionIntegrityFail
  case internalError
  case memoryError
  case invalidData
  case mdsError
  case invalidPointer
  case selfCheckFailed
  case functionFailed
  case moduleManifestVerifyFailed
  case invalidGUID
  case invalidHandle
  case invalidDBList
  case invalidPassthroughID
  case invalidNetworkAddress
  case crlAlreadySigned
  case invalidNumberOfFields
  case verificationFailure
  case unknownTag
  case invalidSignature
  case invalidName
  case invalidCertificateRef
  case invalidCertificateGroup
  case tagNotFound
  case invalidQuery
  case invalidValue
  case callbackFailed
  case aclDeleteFailed
  case aclReplaceFailed
  case aclAddFailed
  case aclChangeFailed
  case invalidAccessCredentials
  case invalidRecord
  case invalidACL
  case invalidSampleValue
  case incompatibleVersion
  case privilegeNotGranted
  case invalidScope
  case pvcAlreadyConfigured
  case invalidPVC
  case emmLoadFailed
  case emmUnloadFailed
  case addinLoadFailed
  case invalidKeyRef
  case invalidKeyHierarchy
  case addinUnloadFailed
  case libraryReferenceNotFound
  case invalidAddinFunctionTable
  case invalidServiceMask
  case moduleNotLoaded
  case invalidSubServiceID
  case attributeNotInContext
  case moduleManagerInitializeFailed
  case moduleManagerNotFound
  case eventNotificationCallbackNotFound
  case inputLengthError
  case outputLengthError
  case privilegeNotSupported
  case deviceError
  case attachHandleBusy
  case notLoggedIn
  case algorithmMismatch
  case keyUsageIncorrect
  case keyBlobTypeIncorrect
  case keyHeaderInconsistent
  case unsupportedKeyFormat
  case unsupportedKeySize
  case invalidKeyUsageMask
  case unsupportedKeyUsageMask
  case invalidKeyAttributeMask
  case unsupportedKeyAttributeMask
  case invalidKeyLabel
  case unsupportedKeyLabel
  case invalidKeyFormat
  case unsupportedVectorOfBuffers
  case invalidInputVector
  case invalidOutputVector
  case invalidContext
  case invalidAlgorithm
  case invalidAttributeKey
  case missingAttributeKey
  case invalidAttributeInitVector
  case missingAttributeInitVector
  case invalidAttributeSalt
  case missingAttributeSalt
  case invalidAttributePadding
  case missingAttributePadding
  case invalidAttributeRandom
  case missingAttributeRandom
  case invalidAttributeSeed
  case missingAttributeSeed
  case invalidAttributePassphrase
  case missingAttributePassphrase
  case invalidAttributeKeyLength
  case missingAttributeKeyLength
  case invalidAttributeBlockSize
  case missingAttributeBlockSize
  case invalidAttributeOutputSize
  case missingAttributeOutputSize
  case invalidAttributeRounds
  case missingAttributeRounds
  case invalidAlgorithmParms
  case missingAlgorithmParms
  case invalidAttributeLabel
  case missingAttributeLabel
  case invalidAttributeKeyType
  case missingAttributeKeyType
  case invalidAttributeMode
  case missingAttributeMode
  case invalidAttributeEffectiveBits
  case missingAttributeEffectiveBits
  case invalidAttributeStartDate
  case missingAttributeStartDate
  case invalidAttributeEndDate
  case missingAttributeEndDate
  case invalidAttributeVersion
  case missingAttributeVersion
  case invalidAttributePrime
  case missingAttributePrime
  case invalidAttributeBase
  case missingAttributeBase
  case invalidAttributeSubprime
  case missingAttributeSubprime
  case invalidAttributeIterationCount
  case missingAttributeIterationCount
  case invalidAttributeDLDBHandle
  case missingAttributeDLDBHandle
  case invalidAttributeAccessCredentials
  case missingAttributeAccessCredentials
  case invalidAttributePublicKeyFormat
  case missingAttributePublicKeyFormat
  case invalidAttributePrivateKeyFormat
  case missingAttributePrivateKeyFormat
  case invalidAttributeSymmetricKeyFormat
  case missingAttributeSymmetricKeyFormat
  case invalidAttributeWrappedKeyFormat
  case missingAttributeWrappedKeyFormat
  case stagedOperationInProgress
  case stagedOperationNotStarted
  case verifyFailed
  case querySizeUnknown
  case blockSizeMismatch
  case publicKeyInconsistent
  case deviceVerifyFailed
  case invalidLoginName
  case alreadyLoggedIn
  case invalidDigestAlgorithm
  case invalidCRLGroup
  case certificateCannotOperate
  case certificateExpired
  case certificateNotValidYet
  case certificateRevoked
  case certificateSuspended
  case insufficientCredentials
  case invalidAction
  case invalidAuthority
  case verifyActionFailed
  case invalidCertAuthority
  case invaldCRLAuthority
  case invalidCRLEncoding
  case invalidCRLType
  case invalidCRL
  case invalidFormType
  case invalidID
  case invalidIdentifier
  case invalidIndex
  case invalidPolicyIdentifiers
  case invalidTimeString
  case invalidReason
  case invalidRequestInputs
  case invalidResponseVector
  case invalidStopOnPolicy
  case invalidTuple
  case multipleValuesUnsupported
  case notTrusted
  case noDefaultAuthority
  case rejectedForm
  case requestLost
  case requestRejected
  case unsupportedAddressType
  case unsupportedService
  case invalidTupleGroup
  case invalidBaseACLs
  case invalidTupleCredendtials
  case invalidEncoding
  case invalidValidityPeriod
  case invalidRequestor
  case requestDescriptor
  case invalidBundleInfo
  case invalidCRLIndex
  case noFieldValues
  case unsupportedFieldFormat
  case unsupportedIndexInfo
  case unsupportedLocality
  case unsupportedNumAttributes
  case unsupportedNumIndexes
  case unsupportedNumRecordTypes
  case fieldSpecifiedMultiple
  case incompatibleFieldFormat
  case invalidParsingModule
  case databaseLocked
  case datastoreIsOpen
  case missingValue
  case unsupportedQueryLimits
  case unsupportedNumSelectionPreds
  case unsupportedOperator
  case invalidDBLocation
  case invalidAccessRequest
  case invalidIndexInfo
  case invalidNewOwner
  case invalidModifyMode
  case missingRequiredExtension
  case extendedKeyUsageNotCritical
  case timestampMissing
  case timestampInvalid
  case timestampNotTrusted
  case timestampServiceNotAvailable
  case timestampBadAlg
  case timestampBadRequest
  case timestampBadDataFormat
  case timestampTimeNotAvailable
  case timestampUnacceptedPolicy
  case timestampUnacceptedExtension
  case timestampAddInfoNotAvailable
  case timestampSystemFailure
  case signingTimeMissing
  case timestampRejection
  case timestampWaiting
  case timestampRevocationWarning
  case timestampRevocationNotification
  case unexpectedError
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: DevicesCore.KeychainOperationStatus, b: DevicesCore.KeychainOperationStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesCore.KeychainOperationStatus {
  public init(status: Darwin.OSStatus)
}
public typealias Keychain = DevicesCore.AttributedStorage<DevicesCore.KeychainAttributes>
@_inheritsConvenienceInitializers final public class KeychainStorage : DevicesCore.Keychain {
  override final public func getItem(with attributes: DevicesCore.KeychainAttributes) throws -> Foundation.Data?
  override final public func setItem(_ data: Foundation.Data, with attributes: DevicesCore.KeychainAttributes) throws
  override final public func removeItem(with attributes: DevicesCore.KeychainAttributes) throws
  override public init()
  @objc deinit
}
public struct KeychainValueContainer<Value> {
  public var value: Value? {
    get
    nonmutating set
  }
}
public struct KeyedStringProvider<Key> where Key : DevicesCore.StringID {
  public init(provider: DevicesCore.StringProvider)
  public func string(for id: Key) -> Swift.String
  public func string(for id: DevicesCore.PluralNounStringID, count: Swift.Int) -> Swift.String
}
extension DevicesCore.StringProvider {
  public func keyed<Key>() -> DevicesCore.KeyedStringProvider<Key> where Key : DevicesCore.StringID
  public func keyedBy<Key>(_: Key.Type) -> DevicesCore.KeyedStringProvider<Key> where Key : DevicesCore.StringID
}
extension QuartzCore.CACornerMask {
  public static let topLeftCorner: QuartzCore.CACornerMask
  public static let topRightCorner: QuartzCore.CACornerMask
  public static let bottomLeftCorner: QuartzCore.CACornerMask
  public static let bottomRightCorner: QuartzCore.CACornerMask
}
public class LimitedLinkedList<T> {
  public var isEmpty: Swift.Bool {
    get
  }
  public var size: Swift.Int {
    get
  }
  public var values: [T] {
    get
  }
  public init(capacity: Swift.Int)
  public func append(_ value: T)
  public func clean()
  public func flush() -> [T]
  @objc deinit
}
public protocol LinkHandlingPolicy {
  func shouldShowExternalLinkAlert(for url: Foundation.URL) -> Swift.Bool
}
extension DevicesCore.LinkedList : Swift.Collection {
  public typealias Index = DevicesCore.LinkedListIndex<ElementType>
  final public var startIndex: DevicesCore.LinkedList<ElementType>.Index {
    get
  }
  final public var endIndex: DevicesCore.LinkedList<ElementType>.Index {
    get
  }
  final public subscript(position: DevicesCore.LinkedList<ElementType>.Index) -> ElementType {
    get
  }
  final public func index(after idx: DevicesCore.LinkedList<ElementType>.Index) -> DevicesCore.LinkedList<ElementType>.Index
  public typealias Element = ElementType
  public typealias Indices = Swift.DefaultIndices<DevicesCore.LinkedList<ElementType>>
  public typealias Iterator = Swift.IndexingIterator<DevicesCore.LinkedList<ElementType>>
  public typealias SubSequence = Swift.Slice<DevicesCore.LinkedList<ElementType>>
}
public struct LinkedListIndex<T> : Swift.Comparable {
  public static func == <T>(lhs: DevicesCore.LinkedListIndex<T>, rhs: DevicesCore.LinkedListIndex<T>) -> Swift.Bool
  public static func < <T>(lhs: DevicesCore.LinkedListIndex<T>, rhs: DevicesCore.LinkedListIndex<T>) -> Swift.Bool
}
extension DevicesCore.LinkedList : Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
}
extension DevicesCore.LinkedList : Swift.ExpressibleByArrayLiteral {
  convenience public init(arrayLiteral elements: ElementType...)
  public typealias ArrayLiteralElement = ElementType
}
@_hasMissingDesignatedInitializers final public class LinkedList<ElementType> {
  @_hasMissingDesignatedInitializers public class LinkedListNode<ElementType> {
    public var value: ElementType
    public var next: DevicesCore.LinkedList<ElementType>.LinkedListNode<ElementType>? {
      get
    }
    weak public var previous: DevicesCore.LinkedList<ElementType>.LinkedListNode<ElementType>? {
      get
    }
    @objc deinit
  }
  public typealias Node = DevicesCore.LinkedList<ElementType>.LinkedListNode<ElementType>
  final public var head: DevicesCore.LinkedList<ElementType>.Node? {
    get
  }
  convenience public init(disposalQueue: Dispatch.DispatchQueue = DispatchQueue.global())
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var count: Swift.Int {
    get
  }
  final public subscript(index: Swift.Int) -> ElementType {
    get
  }
  final public func append(_ value: ElementType)
  final public func append(_ values: [ElementType])
  final public func append(_ list: DevicesCore.LinkedList<ElementType>)
  final public func insert(_ value: ElementType, at index: Swift.Int)
  final public func insert(_ list: DevicesCore.LinkedList<ElementType>, at index: Swift.Int)
  final public func removeAll()
  @discardableResult
  final public func removeLast() -> ElementType
  @discardableResult
  final public func removeFirst() -> ElementType?
  @discardableResult
  final public func remove(at index: Swift.Int) -> ElementType
  @objc deinit
}
final public class LiveTimeProvider {
  final public var time: DevicesCore.Signal<Foundation.Date> {
    get
  }
  public init()
  @objc deinit
  final public func start()
  final public func stop()
}
final public class LocalFilesCheckerImpl {
  public init(resourceDirectory: Foundation.URL, fileManager: DevicesCore.FileManagerTwin)
  @objc deinit
}
extension DevicesCore.LocalFilesCheckerImpl : DevicesCore.FileURLFactory {
  final public func makeURL(for resource: DevicesCore.ResourceTag) -> Foundation.URL
}
public protocol LocalNetworkPermissionProvider : DevicesCore.PermissionProvider {
}
extension DevicesCore.LocalNetworkPermissionProvider {
  public var permission: DevicesCore.Permission {
    get
  }
}
public protocol LocalNetworkPermissionRequester : DevicesCore.AuthorizationRequester {
}
public struct Location : DevicesCore.Serializable, DevicesCore.Deserializable, Swift.Equatable {
  public enum Coordinate {
  }
  public typealias Degrees = DevicesCore.Tagged<DevicesCore.Location.Coordinate, Swift.Double>
  public typealias Meters = Swift.Double
  public let latitude: DevicesCore.Location.Degrees
  public let longtitude: DevicesCore.Location.Degrees
  public let accuracy: DevicesCore.Location.Meters
  public let timestamp: DevicesCore.Milliseconds
  public init(latitude: DevicesCore.Location.Degrees, longtitude: DevicesCore.Location.Degrees, accuracy: DevicesCore.Location.Meters, timestamp: DevicesCore.Milliseconds)
  public init(systemLocation: CoreLocation.CLLocation)
  public func toJSONDictionary() -> DevicesCore.JSONDictionary
  public init(deserializer: DevicesCore.Deserializer) throws
  public static func == (a: DevicesCore.Location, b: DevicesCore.Location) -> Swift.Bool
}
public protocol LocationManager : AnyObject, DevicesCore.AuthorizationProvider {
  var delegate: DevicesCore.LocationManagerDelegate? { get set }
  var location: CoreLocation.CLLocation? { get }
  var desiredAccuracy: CoreLocation.CLLocationAccuracy { get set }
  func startUpdatingLocation()
  func requestWhenInUseAuthorization()
}
public protocol LocationManagerDelegate : AnyObject {
  func locationManager(_ manager: DevicesCore.LocationManager, didFailWithError error: Swift.Error)
  func locationManager(_ manager: DevicesCore.LocationManager, didChangeAuthorization status: CoreLocation.CLAuthorizationStatus)
}
@objc @_inheritsConvenienceInitializers final public class LocationManagerProxy : ObjectiveC.NSObject, DevicesCore.LocationManager {
  weak final public var delegate: DevicesCore.LocationManagerDelegate?
  final public var location: CoreLocation.CLLocation? {
    get
  }
  final public var desiredAccuracy: CoreLocation.CLLocationAccuracy {
    get
    set
  }
  final public var authorizationStatus: DevicesCore.AuthorizationStatus {
    get
  }
  @objc override dynamic public init()
  final public func startUpdatingLocation()
  final public func requestWhenInUseAuthorization()
  @objc deinit
}
extension DevicesCore.LocationManagerProxy : CoreLocation.CLLocationManagerDelegate {
  @objc final public func locationManager(_: CoreLocation.CLLocationManager, didFailWithError error: Swift.Error)
  @objc final public func locationManager(_: CoreLocation.CLLocationManager, didChangeAuthorization status: CoreLocation.CLAuthorizationStatus)
}
public protocol LocationPermissionRequester {
  var authorizationStatus: DevicesCore.AuthorizationStatus { get }
  func requestWhenInUseAuthorization(callback: @escaping (DevicesCore.AuthorizationStatus) -> Swift.Void)
}
public protocol LocationProvider : DevicesCore.AuthorizationProvider {
  var location: DevicesCore.Location? { get }
  func startUpdatingLocation()
}
final public class LocationProviderImpl : DevicesCore.LocationProvider, DevicesCore.LocationPermissionRequester {
  final public var location: DevicesCore.Location? {
    get
  }
  final public var authorizationStatus: DevicesCore.AuthorizationStatus {
    get
  }
  public init(desiredAccuracy: CoreLocation.CLLocationAccuracy = kCLLocationAccuracyHundredMeters, locationManager: DevicesCore.LocationManager = LocationManagerProxy(), logger: DevicesCore.Logger?)
  final public func startUpdatingLocation()
  final public func requestWhenInUseAuthorization(callback: @escaping (DevicesCore.AuthorizationStatus) -> Swift.Void)
  @objc deinit
}
extension DevicesCore.LocationProviderImpl : DevicesCore.LocationManagerDelegate {
  final public func locationManager(_: DevicesCore.LocationManager, didFailWithError error: Swift.Error)
  final public func locationManager(_: DevicesCore.LocationManager, didChangeAuthorization status: CoreLocation.CLAuthorizationStatus)
}
final public class LogAnalyticsService : DevicesCore.AnalyticsService {
  public init(logger: DevicesCore.Logger?)
  final public func send(_ event: DevicesCore.AnalyticsEvent)
  @objc deinit
}
public struct LogAttributesModifier : DevicesCore.LogModifier {
  public init()
  public func modifyMessage(_ message: DevicesCore.LogMessage, with _: DevicesCore.LogLevel, file _: Swift.String, line _: Swift.Int) -> DevicesCore.LogMessage
}
extension DevicesCore.Logger {
  public func labels(_ labels: DevicesCore.LogLabel...) -> DevicesCore.Logger
}
public struct LogEnrichmentModifier : DevicesCore.LogModifier {
  public init(labels: [DevicesCore.LogLabel]? = nil, attributes: [Swift.String : Any]? = nil)
  public func modifyMessage(_ message: DevicesCore.LogMessage, with _: DevicesCore.LogLevel, file _: Swift.String, line _: Swift.Int) -> DevicesCore.LogMessage
}
public struct LogEntry : Swift.Identifiable {
  public typealias ID = DevicesCore.Tagged<DevicesCore.LogEntry.IDTag, Swift.Int>
  public enum IDTag {
  }
  public let id: DevicesCore.LogEntry.ID
  public let message: Swift.String
  public let labels: [DevicesCore.LogLabel]
  public let logLevel: DevicesCore.LogLevel
  public let file: Swift.String
  public let line: Swift.Int
  public let timestamp: Foundation.Date
  public let attributes: [Swift.String : Any]?
  public init(id: DevicesCore.LogEntry.ID = 0, message: Swift.String, labels: [DevicesCore.LogLabel] = [], logLevel: DevicesCore.LogLevel, file: Swift.String, line: Swift.Int, timestamp: Foundation.Date, attributes: [Swift.String : Any]?)
}
extension DevicesCore.LogEntry {
  public var logMessage: DevicesCore.LogMessage {
    get
  }
  public func plainString(modifier: DevicesCore.LogModifier) -> Swift.String
}
public typealias LogLabel = DevicesCore.Tagged<DevicesCore.LogLabelTag, Swift.String>
public enum LogLabelTag {
}
extension Swift.Array where Element == DevicesCore.Tagged<DevicesCore.LogLabelTag, Swift.String> {
  public var string: Swift.String {
    get
  }
}
public struct LogLabelsModifier : DevicesCore.LogModifier {
  public init()
  public func modifyMessage(_ message: DevicesCore.LogMessage, with _: DevicesCore.LogLevel, file _: Swift.String, line _: Swift.Int) -> DevicesCore.LogMessage
}
public enum LogLevel : Swift.Int, Swift.Hashable, Swift.CaseIterable {
  case debug
  case info
  case warn
  case error
  public func isAllowed(_ logLevel: DevicesCore.LogLevel) -> Swift.Bool
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [DevicesCore.LogLevel]
  public typealias RawValue = Swift.Int
  public static var allCases: [DevicesCore.LogLevel] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
extension DevicesCore.LogLevel : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct LogLevelModifier : DevicesCore.LogModifier {
  public init()
  public func modifyMessage(_ message: DevicesCore.LogMessage, with logLevel: DevicesCore.LogLevel, file _: Swift.String, line _: Swift.Int) -> DevicesCore.LogMessage
}
public struct LogMarkModifier : DevicesCore.LogModifier {
  public init()
  public func modifyMessage(_ message: DevicesCore.LogMessage, with _: DevicesCore.LogLevel, file _: Swift.String, line _: Swift.Int) -> DevicesCore.LogMessage
}
public struct LogMessage : DevicesCore.Configurable {
  public var name: Swift.String
  public var labels: [DevicesCore.LogLabel]
  public var attributes: [Swift.String : Any]?
  public init(name: Swift.String, labels: [DevicesCore.LogLabel] = [], attributes: [Swift.String : Any]? = nil)
}
public protocol LogModifier {
  func modifyMessage(_ message: DevicesCore.LogMessage, with logLevel: DevicesCore.LogLevel, file: Swift.String, line: Swift.Int) -> DevicesCore.LogMessage
}
extension DevicesCore.LogModifiers {
  public static let plain: DevicesCore.LogModifier
}
extension DevicesCore.LogModifiers {
  public static func sequence(_ subjects: [DevicesCore.LogModifier]) -> DevicesCore.LogModifier
}
public enum LogModifiers {
}
public protocol LogStorage : AnyObject {
  func clearLogEntries()
  func logEntries() -> [DevicesCore.LogEntry]
}
extension DevicesCore.LogStorage {
  public func plainString(modifier: DevicesCore.LogModifier = LogModifiers.plain) -> Swift.String
}
extension DevicesCore.Logger {
  public func debug(_ message: @autoclosure () -> DevicesCore.LogMessage, file: Swift.StaticString = #fileID, line: Swift.Int = #line)
  public func info(_ message: @autoclosure () -> DevicesCore.LogMessage, file: Swift.StaticString = #fileID, line: Swift.Int = #line)
  public func warn(_ message: @autoclosure () -> DevicesCore.LogMessage, file: Swift.StaticString = #fileID, line: Swift.Int = #line)
  public func error(_ message: @autoclosure () -> DevicesCore.LogMessage, file: Swift.StaticString = #fileID, line: Swift.Int = #line)
}
extension DevicesCore.Logger {
  public func debug(_ message: @autoclosure () -> Swift.String, file: Swift.StaticString = #fileID, line: Swift.Int = #line)
  public func info(_ message: @autoclosure () -> Swift.String, file: Swift.StaticString = #fileID, line: Swift.Int = #line)
  public func warn(_ message: @autoclosure () -> Swift.String, file: Swift.StaticString = #fileID, line: Swift.Int = #line)
  public func error(_ message: @autoclosure () -> Swift.String, file: Swift.StaticString = #fileID, line: Swift.Int = #line)
}
extension DevicesCore.Logger {
  public func modify(_ modifier: DevicesCore.LogModifier) -> DevicesCore.Logger
}
extension DevicesCore.Loggers {
  public static func sequence(_ subjects: [DevicesCore.Logger]) -> DevicesCore.Logger
}
extension DevicesCore.Logger {
  public func timestamp(dateProvider: @autoclosure @escaping () -> Foundation.Date = Date(), dateFormat: Swift.String = "dd.MM.yyyy HH:mm:ss.SSS", timeZone: Foundation.TimeZone = .current) -> DevicesCore.Logger
}
public protocol Logger {
  func logMessage(_ message: @autoclosure () -> (DevicesCore.LogMessage), with logLevel: DevicesCore.LogLevel, file: Swift.StaticString, line: Swift.Int)
}
extension DevicesCore.Logger {
  @inlinable public func logMessage(_ message: @autoclosure () -> Swift.String, with logLevel: DevicesCore.LogLevel, file: Swift.StaticString = #fileID, line: Swift.Int = #line) {
		logMessage(
			LogMessage(name: message()),
			with: logLevel,
			file: file,
			line: line
		)
	}
}
public enum Loggers {
}
extension DevicesCore.AssertionCaller {
  public func logging(_ logger: DevicesCore.Logger?) -> DevicesCore.AssertionCaller
}
extension DevicesCore.SecurityChallengeReceiver {
  public func logging(to logger: DevicesCore.Logger) -> DevicesCore.SecurityChallengeReceiver
}
extension DevicesCore.RequestInterceptor {
  public func logging(to logger: DevicesCore.Logger, label: Swift.String) -> DevicesCore.RequestInterceptor<Request, Response>
}
public protocol MailComposeFactory {
  var canSendMail: Swift.Bool { get }
  func makeMailCompose(subjectText: Swift.String, messageBody: Swift.String, to recipients: [Swift.String], mailComposeVisibility: DevicesCore.MutableProperty<DevicesCore.MailComposeViewControllerVisibility>) -> UIKit.UIViewController
}
@objc @_inheritsConvenienceInitializers final public class MailComposeFactoryImpl : ObjectiveC.NSObject, DevicesCore.MailComposeFactory {
  final public var canSendMail: Swift.Bool {
    get
  }
  @objc override dynamic public init()
  final public func makeMailCompose(subjectText: Swift.String, messageBody: Swift.String, to recipients: [Swift.String], mailComposeVisibility: DevicesCore.MutableProperty<DevicesCore.MailComposeViewControllerVisibility>) -> UIKit.UIViewController
  @objc deinit
}
extension DevicesCore.MailComposeFactoryImpl : MessageUI.MFMailComposeViewControllerDelegate {
  @objc final public func mailComposeController(_ controller: MessageUI.MFMailComposeViewController, didFinishWith _: MessageUI.MFMailComposeResult, error _: Swift.Error?)
}
public enum MailComposeViewControllerVisibility : Swift.Equatable {
  case visible
  case hidden
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesCore.MailComposeViewControllerVisibility, b: DevicesCore.MailComposeViewControllerVisibility) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol MailHandler {
  var mailComposeViewControllerVisibility: DevicesCore.Property<DevicesCore.MailComposeViewControllerVisibility> { get }
  func sendEmailIfPossible(subjectText: Swift.String, messageBody: Swift.String, to recipients: [Swift.String], on viewController: UIKit.UIViewController)
}
final public class MailHandlerImpl : DevicesCore.MailHandler {
  final public var mailComposeViewControllerVisibility: DevicesCore.Property<DevicesCore.MailComposeViewControllerVisibility> {
    get
  }
  public init(mailComposeFactory: DevicesCore.MailComposeFactory, controllerVisibility: DevicesCore.MutableProperty<DevicesCore.MailComposeViewControllerVisibility> = .init(.hidden))
  final public func sendEmailIfPossible(subjectText: Swift.String, messageBody: Swift.String, to recipients: [Swift.String], on viewController: UIKit.UIViewController)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class ManualAudioSource {
  weak final public var delegate: DevicesCore.AudioSourceDelegate?
  final public var isRunning: Swift.Bool {
    get
  }
  final public var inputFormat: AVFAudio.AVAudioFormat {
    get
  }
  convenience public init(audioEngine: AVFAudio.AVAudioEngine = AVAudioEngine(), bufferDuration: Foundation.TimeInterval = 0.021, osLogger: DevicesCore.OSLogger? = nil)
  convenience public init(computePower: ((AVFAudio.AVAudioPCMBuffer) -> Swift.Float?)?, audioEngine: AVFAudio.AVAudioEngine = AVAudioEngine(), bufferDuration: Foundation.TimeInterval = 0.021, osLogger: DevicesCore.OSLogger? = nil)
  @objc deinit
}
extension DevicesCore.ManualAudioSource : DevicesCore.AudioSource {
  @discardableResult
  final public func start() -> Swift.Bool
  final public func stop()
  final public func cancel()
}
extension DevicesCore.RequestInterceptor {
  public func mapRequest<SubjectRequest>(_ transform: @escaping (SubjectRequest) throws -> Request) -> DevicesCore.RequestInterceptor<SubjectRequest, Response>
}
extension DevicesCore.RequestInterceptor {
  public func mapResponse<SubjectResponse>(_ transform: @escaping (Response) throws -> SubjectResponse) -> DevicesCore.RequestInterceptor<Request, SubjectResponse>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  @inlinable public func mapErasingToAnyPublisher<Value>(using transform: @escaping (Self.Output) -> Value) -> Combine.AnyPublisher<Value, Self.Failure> {
		map(transform).eraseToAnyPublisher()
	}
  @inlinable public func shareMapErasingToAnyPublisher<Value>(using transform: @escaping (Self.Output) -> Value) -> Combine.AnyPublisher<Value, Self.Failure> {
		map(transform).share().eraseToAnyPublisher()
	}
  @inlinable public func mapErasingToAnyPublisher<Value>(_ value: Value) -> Combine.AnyPublisher<Value, Self.Failure> {
		mapErasingToAnyPublisher { _ in value }
	}
  @inlinable public func discard() -> Combine.AnyPublisher<Swift.Void, Self.Failure> {
		mapErasingToAnyPublisher(())
	}
}
extension DevicesCore.RequestInterceptor {
  public func mapURLRequest(_ transform: @escaping (Request, inout Foundation.URLRequest) throws -> Swift.Void) -> DevicesCore.RequestInterceptor<Request, Response>
}
public protocol MarkdownAPI {
  func makeAttributedString(from markdownString: Swift.String) throws -> Foundation.NSAttributedString
  func makeAttributedString(from markdownString: Swift.String, styler: DevicesCore.MarkdownStyler) throws -> Foundation.NSAttributedString
}
final public class MarkdownAPIImpl : DevicesCore.MarkdownAPI {
  public init()
  final public func makeAttributedString(from markdownString: Swift.String) throws -> Foundation.NSAttributedString
  final public func makeAttributedString(from markdownString: Swift.String, styler: DevicesCore.MarkdownStyler) throws -> Foundation.NSAttributedString
  @objc deinit
}
public struct MarkdownStyler {
  public struct TextStyle {
    public init(font: UIKit.UIFont, color: UIKit.UIColor, paragraphStyle: UIKit.NSParagraphStyle, kern: CoreFoundation.CGFloat)
  }
  public init(heading1Style: DevicesCore.MarkdownStyler.TextStyle, heading2Style: DevicesCore.MarkdownStyler.TextStyle, heading3Style: DevicesCore.MarkdownStyler.TextStyle, bodyStyle: DevicesCore.MarkdownStyler.TextStyle, codeStyle: DevicesCore.MarkdownStyler.TextStyle, listItemPrefixFont: UIKit.UIFont, linkColor: UIKit.UIColor, quoteColor: UIKit.UIColor, quoteStripeColor: UIKit.UIColor, thematicBreakColor: UIKit.UIColor, listItemPrefixColor: UIKit.UIColor, codeBackgroundColor: UIKit.UIColor)
}
public typealias Milliseconds = DevicesCore.Tagged<Foundation.TimeInterval, Swift.Int>
extension Swift.Double {
  public var milliseconds: DevicesCore.Milliseconds {
    get
  }
}
extension DevicesCore.Tagged where Tag == Swift.Double, T == Swift.Int {
  public var seconds: Foundation.TimeInterval {
    get
  }
}
public protocol ModalScreen : DevicesCore.Screen {
  func onDidDismiss()
}
extension DevicesCore.ModalScreen {
  public func onDidDismiss()
}
public struct ModalScreenAdapter : DevicesCore.ModalScreen {
  public let viewController: UIKit.UIViewController
  public init(_ viewController: UIKit.UIViewController)
}
public struct ModalTaggedScreen<Tag> : DevicesCore.ModalScreen {
  public var viewController: UIKit.UIViewController {
    get
  }
  public init(_ wrapped: DevicesCore.ModalScreen)
  public func onDidDismiss()
}
extension DevicesCore.ModalScreen {
  public func tag<Tag>(by _: Tag.Type = Tag.self) -> DevicesCore.ModalTaggedScreen<Tag>
}
public enum MonorepoVersion {
  public static let value: Swift.String
}
final public class MultiDomainChallengeReceiver : DevicesCore.SecurityChallengeReceiver {
  public init(receivers: [Swift.String : DevicesCore.SecurityChallengeReceiver], defaultReceiver: DevicesCore.SecurityChallengeReceiver)
  final public func receiveChallenge(_ challenge: Foundation.URLAuthenticationChallenge, task: DevicesCore.NetworkTask?, completion: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc deinit
}
public protocol MultipartFormEncodable {
  func encodeMultipartForm(into encoder: DevicesCore.MultipartFormEncoder) throws
}
public protocol MultipartFormEncoder : AnyObject {
  func addText(name: Swift.String, value: Swift.String)
  func addData(name: Swift.String, data: Foundation.Data, fileName: Swift.String?, mimeType: Swift.String?)
}
extension DevicesCore.MultipartFormEncoder {
  public func addData(name: Swift.String, data: Foundation.Data, mimeType: Swift.String?)
}
extension DevicesCore.MutableProperty {
  @propertyWrapper public struct RemovedDuplicates {
    @usableFromInline
    internal let subject: DevicesCore.MutableProperty<Value>
    @inlinable public var wrappedValue: Value {
      get { subject.value }
      nonmutating set { subject.value = newValue }
    }
    @inlinable public var projectedValue: DevicesCore.MutableProperty<Value> {
      get { subject }
    }
    public init(wrappedValue: Value, predicate: @escaping (Value, Value) -> Swift.Bool, assertQueue: @escaping DevicesCore.DispatchQueueAssert = {})
  }
  @inlinable public func removeDuplicates(using predicate: @escaping (Value, Value) -> Swift.Bool) -> DevicesCore.MutableProperty<Value> {
		map(to: {
			$0
		}, from: { value in
			guard !predicate(self.value, value) else {
				return nil
			}

			return value
		})
	}
}
extension DevicesCore.MutableProperty where Value : Swift.Equatable {
  @inlinable public func removeDuplicates() -> DevicesCore.MutableProperty<Value> {
		removeDuplicates(using: ==)
	}
}
extension DevicesCore.MutableProperty.RemovedDuplicates where Value : Swift.Equatable {
  @inlinable public init(wrappedValue: Value, assertQueue: @escaping DevicesCore.DispatchQueueAssert = {}) {
		self.init(wrappedValue: wrappedValue, predicate: ==, assertQueue: assertQueue)
	}
}
extension DevicesCore.MutableProperty {
  public func sink(startWithCurrent: Swift.Bool, receiveValue: @escaping (Value) -> Swift.Void) -> DevicesCore.AnyCancellable
}
extension DevicesCore.MutableProperty {
  @inlinable public func map<U>(to transform: @escaping (Value) -> U, from reverseTransform: @escaping (U) -> Value?) -> DevicesCore.MutableProperty<U> {
		MutableProperty<U>(
			getter: {
				transform(self.value)
			},
			setter: {
				guard let newValue = reverseTransform($0) else {
					return
				}
				self.setter(newValue)
			},
			signal: signal
				.map(transform)
				.eraseToAnyPublisher()
		)
	}
  @inlinable internal func map<U>(_ keyPath: Swift.WritableKeyPath<Value, U>) -> DevicesCore.MutableProperty<U> {
		map(
			to: { value in
				value[keyPath: keyPath]
			},
			from: { part in
				var newValue = value
				newValue[keyPath: keyPath] = part
				return newValue
			}
		)
	}
  @inlinable public func nonnull<U>(default: U) -> DevicesCore.MutableProperty<U> where Value == U? {
		map(
			to: { value in
				value ?? `default`
			},
			from: { $0 }
		)
	}
}
@propertyWrapper public struct MutableProperty<Value> {
  @usableFromInline
  internal let getter: () -> Value
  @usableFromInline
  internal let setter: (Value) -> Swift.Void
  @inlinable public var value: Value {
    get { getter() }
    nonmutating set { setter(newValue) }
  }
  public let signal: DevicesCore.Signal<Value>
  @inlinable public var wrappedValue: Value {
    get { value }
    nonmutating set { value = newValue }
  }
  @inlinable public var projectedValue: DevicesCore.MutableProperty<Value> {
    get { self }
  }
  public init(getter: @escaping () -> Value, setter: @escaping (Value) -> Swift.Void, signal: DevicesCore.Signal<Value>)
}
extension DevicesCore.MutableProperty {
  @inlinable public init(getter: @escaping () -> Value, setter: @escaping (Value) -> Swift.Void, assertQueue: @escaping DevicesCore.DispatchQueueAssert = {}) {
		let signal = DefaultSignal<Value>()

		self.init(
			getter: {
				assertQueue()
				return getter()
			},
			setter: {
				assertQueue()
				setter($0)
				signal.fire($0)
			},
			signal: signal.eraseToAnyPublisher()
		)
	}
  @inlinable public func asProperty() -> DevicesCore.Property<Value> {
		Property(
			getter: getter,
			signal: signal
		)
	}
  @inlinable public init(wrappedValue: Value, assertQueue: @escaping DevicesCore.DispatchQueueAssert = {}) {
		var value = wrappedValue

		self.init(
			getter: { value },
			setter: { value = $0 },
			assertQueue: assertQueue
		)
	}
  @inlinable public init(_ wrappedValue: Value) {
		self.init(wrappedValue: wrappedValue)
	}
  @inlinable public func sink(receiveValue block: @escaping (Value) -> Swift.Void) -> DevicesCore.AnyCancellable {
		signal.sink(receiveValue: block)
	}
}
extension DevicesCore.MutableProperty : Swift.Equatable where Value : Swift.Equatable {
  @inlinable public static func == (lhs: DevicesCore.MutableProperty<Value>, rhs: DevicesCore.MutableProperty<Value>) -> Swift.Bool {
		lhs.value == rhs.value
	}
}
extension DevicesCore.MutableProperty where Value == Swift.Bool {
  @inlinable public func toggle() {
		value.toggle()
	}
}
extension Foundation.NSAttributedString {
  public typealias Attributes = [Foundation.NSAttributedString.Key : Any]
  public var wholeRange: Foundation.NSRange {
    get
  }
  public func ranges(of key: Foundation.NSAttributedString.Key) -> [Foundation.NSRange]
  public func ranges(of key: Foundation.NSAttributedString.Key, in range: Foundation.NSRange) -> [Foundation.NSRange]
  public func rangesMissingAttribute(for key: Foundation.NSAttributedString.Key) -> [Foundation.NSRange]
  public func rangesMissingAttribute(for key: Foundation.NSAttributedString.Key, in range: Foundation.NSRange) -> [Foundation.NSRange]
  public func paragraphRanges() -> [Foundation.NSRange]
  public func enumerateAttributes<A>(for key: Foundation.NSAttributedString.Key, block: (_ attr: A, _ range: Foundation.NSRange) -> Swift.Void)
  public func enumerateAttributes<A>(for key: Foundation.NSAttributedString.Key, in range: Foundation.NSRange, block: (_ attr: A, _ range: Foundation.NSRange) -> Swift.Void)
}
extension UIKit.NSLayoutConstraint {
  @_Concurrency.MainActor(unsafe) public static func anchor(view: UIKit.UIView, toBoundsOfSuperview superview: UIKit.UIView, insets: UIKit.UIEdgeInsets = .zero) -> [UIKit.NSLayoutConstraint]
}
extension Foundation.NSLocking {
  @discardableResult
  public func with<T>(_ block: () throws -> T) rethrows -> T
}
public protocol NamedType {
  static var typeName: Swift.String { get }
  var typeName: Swift.String { get }
}
extension DevicesCore.NamedType {
  public static var typeName: Swift.String {
    get
  }
  public var typeName: Swift.String {
    get
  }
}
public protocol NavigatableScreen : DevicesCore.StackScreen {
  var navigationBarAppearance: DevicesCore.NavigationBarAppearance { get }
}
public enum NavigationAction {
  case push(DevicesCore.NavigatableScreen, animated: Swift.Bool)
  case pop(animated: Swift.Bool)
}
extension DevicesCore.NavigationAction {
  public var isAnimated: Swift.Bool {
    get
  }
}
extension DevicesCore.NavigationBarAppearance.BarStyle {
  public func apply(to navigationBar: UIKit.UINavigationBar)
}
public struct NavigationBarAppearance {
  public enum BarStyle {
    case defaultSystem
    case black
    case transparent
    public static func == (a: DevicesCore.NavigationBarAppearance.BarStyle, b: DevicesCore.NavigationBarAppearance.BarStyle) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let shouldShowNavigationBar: Swift.Bool
  public let navigationBarStyle: DevicesCore.NavigationBarAppearance.BarStyle
  public init(shouldShowNavigationBar: Swift.Bool, navigationBarStyle: DevicesCore.NavigationBarAppearance.BarStyle)
}
public protocol NavigationControllerAdapter {
  var viewControllers: [UIKit.UIViewController] { get set }
  var delegate: UIKit.UINavigationControllerDelegate? { get set }
  func pushViewController(_ viewController: UIKit.UIViewController, animated: Swift.Bool, completion: @escaping () -> Swift.Void)
  func popViewController(animated: Swift.Bool, completion: @escaping () -> Swift.Void)
  func popToRootViewController(animated: Swift.Bool, completion: @escaping () -> Swift.Void)
  func setViewControllers(_ viewControllers: [UIKit.UIViewController], animated: Swift.Bool, completion: @escaping () -> Swift.Void)
}
final public class NavigationControllerAdapterImpl : DevicesCore.NavigationControllerAdapter {
  final public var viewControllers: [UIKit.UIViewController] {
    get
    set
  }
  final public var delegate: UIKit.UINavigationControllerDelegate? {
    get
    set
  }
  public init(_ subject: UIKit.UINavigationController, mainThreadRunner: @escaping DevicesCore.MainThreadAsyncRunner = onMainThreadAsync, delayedMainThreadRunner: @escaping DevicesCore.DelayedMainThreadRunner = after)
  final public func pushViewController(_ viewController: UIKit.UIViewController, animated: Swift.Bool, completion: @escaping () -> Swift.Void)
  final public func popViewController(animated: Swift.Bool, completion: @escaping () -> Swift.Void)
  final public func popToRootViewController(animated: Swift.Bool, completion: @escaping () -> Swift.Void)
  final public func setViewControllers(_ viewControllers: [UIKit.UIViewController], animated: Swift.Bool, completion: @escaping () -> Swift.Void)
  @objc deinit
}
public protocol NavigationHandler {
  func allowsOpen(for action: DevicesCore.WebNavigationAction) -> Swift.Bool
}
public protocol NavigationRouter : AnyObject {
  func performAction(_ action: DevicesCore.NavigationAction)
}
public protocol NavigationStackScreen : DevicesCore.StackScreen {
  var screens: [DevicesCore.StackScreen] { get }
  func push(_ screen: DevicesCore.StackScreen, animated: Swift.Bool)
  func pop(animated: Swift.Bool)
  func popToRoot(animated: Swift.Bool)
  func replaceFirst(with screen: DevicesCore.StackScreen, animated: Swift.Bool)
  func replaceLast(with screen: DevicesCore.StackScreen, animated: Swift.Bool)
  func dismiss(_ screen: DevicesCore.StackScreen, animated: Swift.Bool)
  func newStack(_ screens: [DevicesCore.StackScreen], animated: Swift.Bool)
}
final public class NavigationStackScreenProxy {
  final public var subject: DevicesCore.NavigationStackScreen?
  public init()
  @objc deinit
}
extension DevicesCore.NavigationStackScreenProxy : DevicesCore.NavigationStackScreen {
  final public var viewController: UIKit.UIViewController {
    get
  }
  final public func sizeThatFits(_ size: CoreFoundation.CGSize, safeAreaInsets: UIKit.UIEdgeInsets) -> CoreFoundation.CGSize
  final public var screens: [DevicesCore.StackScreen] {
    get
  }
  final public func push(_ screen: DevicesCore.StackScreen, animated: Swift.Bool)
  final public func pop(animated: Swift.Bool)
  final public func popToRoot(animated: Swift.Bool)
  final public func replaceFirst(with screen: DevicesCore.StackScreen, animated: Swift.Bool)
  final public func replaceLast(with screen: DevicesCore.StackScreen, animated: Swift.Bool)
  final public func dismiss(_ screen: DevicesCore.StackScreen, animated: Swift.Bool)
  final public func newStack(_ screens: [DevicesCore.StackScreen], animated: Swift.Bool)
}
public protocol NetworkSession : AnyObject {
  func dataTask(request: Foundation.URLRequest, completion: @escaping (Foundation.Data?, Foundation.URLResponse?, Swift.Error?) -> Swift.Void) -> DevicesCore.NetworkTask
  func downloadTask(request: Foundation.URLRequest, completion: @escaping (Foundation.URL?, Foundation.URLResponse?, Swift.Error?) -> Swift.Void) -> DevicesCore.NetworkTask
}
public protocol NetworkTask : Combine.Cancellable {
  var originalRequest: Foundation.URLRequest? { get }
  var currentRequest: Foundation.URLRequest? { get }
  func resume()
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  @inlinable public func nilOnError() -> Combine.Publishers.ReplaceError<Combine.Publishers.Map<Self, Self.Output?>> {
		map(Optional.init).replaceError(with: nil)
	}
}
public struct NullAssertionCaller : DevicesCore.AssertionCaller {
  public init()
  public func debug(_: @autoclosure () -> Swift.String, prefix _: @autoclosure () -> Swift.String, suffix _: @autoclosure () -> Swift.String, file _: Swift.StaticString, line _: Swift.UInt)
  public func fatal(_ message: @autoclosure () -> Swift.String, prefix: @autoclosure () -> Swift.String, suffix: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt)
  public func conditional(_: @autoclosure () -> Swift.Bool, _: @autoclosure () -> Swift.String, prefix _: @autoclosure () -> Swift.String, suffix _: @autoclosure () -> Swift.String, file _: Swift.StaticString, line _: Swift.UInt)
}
final public class NullLogger : DevicesCore.Logger, DevicesCore.LogStorage {
  public init()
  final public func clearLogEntries()
  final public func logEntries() -> [DevicesCore.LogEntry]
  final public func logMessage(_: @autoclosure () -> (DevicesCore.LogMessage), with _: DevicesCore.LogLevel, file _: Swift.StaticString, line _: Swift.Int)
  @objc deinit
}
public protocol OSLogInterval {
  func begin()
  func end()
}
public protocol OSLogIntervalToken {
  func end()
}
public protocol OSLogger {
  func beginInterval(name: Swift.StaticString, label: Swift.StaticString?) -> DevicesCore.OSLogIntervalToken
}
extension DevicesCore.OSLogger {
  @inlinable public func beginInterval(name: Swift.StaticString) -> DevicesCore.OSLogIntervalToken {
		beginInterval(name: name, label: nil)
	}
}
final public class OSLoggerAdapter : DevicesCore.OSLogger {
  public init(bundle: Foundation.Bundle, onBeginInterval: ((Swift.StaticString) -> Swift.Void)? = nil, onEndInterval: ((Swift.StaticString) -> Swift.Void)? = nil)
  final public func beginInterval(name: Swift.StaticString, label: Swift.StaticString?) -> DevicesCore.OSLogIntervalToken
  final public func makeInterval(name: Swift.StaticString, label: Swift.StaticString?) -> DevicesCore.OSLogInterval
  @objc deinit
}
public enum OSLoggerNames {
}
public protocol OnDemandTimerScheduler : AnyObject {
  var minInterval: Foundation.TimeInterval { get set }
  var tolerance: Foundation.TimeInterval { get set }
  var timerAction: DevicesCore.TimerAction? { get set }
  func scheduleIfNeeded()
}
final public class OnDemandTimerSchedulerImpl : DevicesCore.OnDemandTimerScheduler {
  final public var minInterval: Foundation.TimeInterval
  final public var tolerance: Foundation.TimeInterval
  final public var timerAction: DevicesCore.TimerAction?
  public init(timerScheduler: DevicesCore.TimerScheduler = SystemTimerScheduler(), mainThreadRunner: @escaping DevicesCore.MainThreadRunner = onMainThread, timestampProvider: @escaping DevicesCore.TimestampProvider = makeCurrentTimestamp, timerAction: DevicesCore.TimerAction?, minInterval: Foundation.TimeInterval, tolerance: Foundation.TimeInterval = 1, initialMoment: Foundation.TimeInterval? = nil, logger: DevicesCore.Logger? = nil)
  @objc deinit
  final public func scheduleIfNeeded()
}
extension Swift.Optional {
  public func asArray() -> [Wrapped]
}
public enum OptionalError : Foundation.LocalizedError, Swift.Equatable {
  case noValue(Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: DevicesCore.OptionalError, b: DevicesCore.OptionalError) -> Swift.Bool
}
extension Swift.Optional {
  @inlinable public var isSome: Swift.Bool {
    get { self != nil }
  }
  @inlinable public var isNone: Swift.Bool {
    get { self == nil }
  }
}
extension Swift.Optional where Wrapped == Swift.Bool {
  @inlinable prefix public static func ! (optional: Swift.Bool?) -> Swift.Bool? {
		optional?.toggled
	}
}
extension Swift.Optional where Wrapped : Swift.Collection {
  public var isNullOrEmpty: Swift.Bool {
    get
  }
}
extension Swift.Optional {
  @inlinable public func get(elseThrow error: @autoclosure () -> Swift.Error) throws -> Wrapped {
		guard let value = self else {
			throw error()
		}
		return value
	}
  @inlinable public func get(elseThrow key: @autoclosure () -> Swift.String) throws -> Wrapped {
		guard let value = self else {
			throw OptionalError.noValue(key())
		}
		return value
	}
  @inlinable public func asResult(throwing key: @autoclosure () -> Swift.String) -> Swift.Result<Wrapped, Swift.Error> {
		guard let value = self else {
			return .failure(OptionalError.noValue(key()))
		}
		return .success(value)
	}
  @inlinable public func get(file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line) throws -> Wrapped {
		let fileName = URL(fileURLWithPath: file).lastPathComponent
		return try get(elseThrow: OptionalError.noValue("\(fileName):\(line) \(function)"))
	}
}
extension Swift.Optional : DevicesCore.NamedType {
  public static var typeName: Swift.String {
    get
  }
  public var typeName: Swift.String {
    get
  }
}
extension Swift.Optional : DevicesCore.PrettyStringConvertible, Swift.CustomStringConvertible {
  public func makePrettyDescription(additionalOffset: Swift.String?) -> Swift.String
}
extension DevicesCore.OrderedDictionary : Swift.Encodable where Key : Swift.Encodable, Value : Swift.Encodable {
  @inlinable public func encode(to encoder: Swift.Encoder) throws {
		// Encode contents as an array of alternating key-value pairs.
		var container = encoder.unkeyedContainer()
		for (key, value) in self {
			try container.encode(key)
			try container.encode(value)
		}
	}
}
extension DevicesCore.OrderedDictionary : Swift.Decodable where Key : Swift.Decodable, Value : Swift.Decodable {
  @inlinable public init(from decoder: Swift.Decoder) throws {
		// We expect to be encoded as an array of alternating key-value pairs.
		var container = try decoder.unkeyedContainer()

		self.init()
		while !container.isAtEnd {
			let key = try container.decode(Key.self)
			let (index, bucket) = self._keys._find(key)
			guard index == nil else {
				let context = DecodingError.Context(
					codingPath: container.codingPath,
					debugDescription: "Duplicate key at offset \(container.currentIndex - 1)"
				)
				throw DecodingError.dataCorrupted(context)
			}

			guard !container.isAtEnd else {
				throw DecodingError.dataCorrupted(
					DecodingError.Context(
						codingPath: container.codingPath,
						debugDescription: "Unkeyed container reached end before value in key-value pair"
					)
				)
			}
			let value = try container.decode(Value.self)
			_keys._appendNew(key, in: bucket)
			_values.append(value)
		}
		_checkInvariants()
	}
}
extension DevicesCore.OrderedDictionary : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension DevicesCore.OrderedDictionary : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension DevicesCore.OrderedDictionary : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension DevicesCore.OrderedDictionary.Elements {
  @frozen public struct SubSequence {
    @usableFromInline
    internal var _base: DevicesCore.OrderedDictionary<Key, Value>
    @usableFromInline
    internal var _bounds: Swift.Range<Swift.Int>
    @inlinable @inline(__always) internal init(_base: DevicesCore.OrderedDictionary<Key, Value>, bounds: Swift.Range<Swift.Int>) {
			self._base = _base
			self._bounds = bounds
		}
  }
}
extension DevicesCore.OrderedDictionary.Elements.SubSequence : Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension DevicesCore.OrderedDictionary.Elements.SubSequence : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension DevicesCore.OrderedDictionary.Elements.SubSequence : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension DevicesCore.OrderedDictionary.Elements.SubSequence {
  @inlinable @inline(__always) public var keys: DevicesCore.OrderedSet<Key>.SubSequence {
    get {
		_base._keys[_bounds]
	}
  }
  @inlinable @inline(__always) public var values: DevicesCore.OrderedDictionary<Key, Value>.Values.SubSequence {
    get {
		_base.values[_bounds]
	}
  }
}
extension DevicesCore.OrderedDictionary.Elements.SubSequence {
  @inlinable public func index(forKey key: Key) -> Swift.Int? {
		guard let index = _base.index(forKey: key) else { return nil }
		guard _bounds.contains(index) else { return nil }
		return index
	}
}
extension DevicesCore.OrderedDictionary.Elements.SubSequence : Swift.Sequence {
  public typealias Element = DevicesCore.OrderedDictionary<Key, Value>.Element
  @frozen public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal var _base: DevicesCore.OrderedDictionary<Key, Value>
    @usableFromInline
    internal var _end: Swift.Int
    @usableFromInline
    internal var _index: Swift.Int
    @inlinable @inline(__always) internal init(_base: DevicesCore.OrderedDictionary<Key, Value>.Elements.SubSequence) {
			self._base = _base._base
			self._end = _base._bounds.upperBound
			self._index = _base._bounds.lowerBound
		}
    @inlinable public mutating func next() -> DevicesCore.OrderedDictionary<Key, Value>.Elements.SubSequence.Element? {
			guard _index < _end else { return nil }
			defer { _index += 1 }
			return (_base._keys[_index], _base._values[_index])
		}
    public typealias Element = DevicesCore.OrderedDictionary<Key, Value>.Elements.SubSequence.Element
  }
  @inlinable @inline(__always) public func makeIterator() -> DevicesCore.OrderedDictionary<Key, Value>.Elements.SubSequence.Iterator {
		Iterator(_base: self)
	}
}
extension DevicesCore.OrderedDictionary.Elements.SubSequence.Iterator : Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension DevicesCore.OrderedDictionary.Elements.SubSequence : Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias SubSequence = DevicesCore.OrderedDictionary<Key, Value>.Elements.SubSequence
  @inlinable @inline(__always) public var startIndex: Swift.Int {
    get { _bounds.lowerBound }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Int {
    get { _bounds.upperBound }
  }
  @inlinable @inline(__always) public var indices: Swift.Range<Swift.Int> {
    get { _bounds }
  }
  @inlinable @inline(__always) public func index(after i: Swift.Int) -> Swift.Int { i + 1 }
  @inlinable @inline(__always) public func index(before i: Swift.Int) -> Swift.Int { i - 1 }
  @inlinable @inline(__always) public func formIndex(after i: inout Swift.Int) { i += 1 }
  @inlinable @inline(__always) public func formIndex(before i: inout Swift.Int) { i -= 1 }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
		i + distance
	}
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
		_base._values.index(i, offsetBy: distance, limitedBy: limit)
	}
  @inlinable @inline(__always) public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
		end - start
	}
  @inlinable public subscript(position: Swift.Int) -> DevicesCore.OrderedDictionary<Key, Value>.Elements.SubSequence.Element {
    get {
		precondition(_bounds.contains(position), "Index out of range")
		return (_base._keys[position], _base._values[position])
	}
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> DevicesCore.OrderedDictionary<Key, Value>.Elements.SubSequence.SubSequence {
    get {
		precondition(
			bounds.lowerBound >= _bounds.lowerBound
				&& bounds.upperBound <= _bounds.upperBound,
			"Index out of range"
		)
		return Self(_base: _base, bounds: bounds)
	}
  }
  @inlinable @inline(__always) public var isEmpty: Swift.Bool {
    get { _bounds.isEmpty }
  }
  @inlinable @inline(__always) public var count: Swift.Int {
    get { _bounds.count }
  }
}
extension DevicesCore.OrderedDictionary {
  @frozen public struct Elements {
    @usableFromInline
    internal var _base: DevicesCore.OrderedDictionary<Key, Value>
    @inlinable @inline(__always) internal init(_base: DevicesCore.OrderedDictionary<Key, Value>) {
			self._base = _base
		}
  }
}
extension DevicesCore.OrderedDictionary.Elements : Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension DevicesCore.OrderedDictionary {
  @inlinable @inline(__always) public var elements: DevicesCore.OrderedDictionary<Key, Value>.Elements {
    get {
			Elements(_base: self)
		}
    @inline(__always) _modify {
			var elements = Elements(_base: self)
			self = Self()
			defer { self = elements._base }
			yield &elements
		}
  }
}
extension DevicesCore.OrderedDictionary.Elements {
  @inlinable @inline(__always) public var keys: DevicesCore.OrderedSet<Key> {
    get {
		_base._keys
	}
  }
  @inlinable @inline(__always) public var values: DevicesCore.OrderedDictionary<Key, Value>.Values {
    get {
			_base.values
		}
    @inline(__always) _modify {
			var values = OrderedDictionary.Values(_base: _base)
			self = Self(_base: .init())
			defer { self._base = values._base }
			yield &values
		}
  }
}
extension DevicesCore.OrderedDictionary.Elements {
  @inlinable public func index(forKey key: Key) -> Swift.Int? {
		_base.index(forKey: key)
	}
}
extension DevicesCore.OrderedDictionary.Elements : Swift.Sequence {
  public typealias Element = (key: Key, value: Value)
  @inlinable public var underestimatedCount: Swift.Int {
    get { _base.count }
  }
  @inlinable public func makeIterator() -> DevicesCore.OrderedDictionary<Key, Value>.Iterator {
		_base.makeIterator()
	}
  public typealias Iterator = DevicesCore.OrderedDictionary<Key, Value>.Iterator
}
extension DevicesCore.OrderedDictionary.Elements : Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable @inline(__always) public var startIndex: Swift.Int {
    get { 0 }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Int {
    get { _base.count }
  }
  @inlinable @inline(__always) public func index(after i: Swift.Int) -> Swift.Int { i + 1 }
  @inlinable @inline(__always) public func index(before i: Swift.Int) -> Swift.Int { i - 1 }
  @inlinable @inline(__always) public func formIndex(after i: inout Swift.Int) { i += 1 }
  @inlinable @inline(__always) public func formIndex(before i: inout Swift.Int) { i -= 1 }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
		i + distance
	}
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
		_base._values.index(i, offsetBy: distance, limitedBy: limit)
	}
  @inlinable @inline(__always) public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
		end - start
	}
  @inlinable @inline(__always) public subscript(position: Swift.Int) -> DevicesCore.OrderedDictionary<Key, Value>.Elements.Element {
    get {
		(_base._keys[position], _base._values[position])
	}
  }
  public subscript(bounds: Swift.Range<Swift.Int>) -> DevicesCore.OrderedDictionary<Key, Value>.Elements.SubSequence {
    get
  }
  @inlinable @inline(__always) public var isEmpty: Swift.Bool {
    get { _base.isEmpty }
  }
  @inlinable @inline(__always) public var count: Swift.Int {
    get { _base.count }
  }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
		_base._values._failEarlyRangeCheck(index, bounds: bounds)
	}
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.ClosedRange<Swift.Int>) {
		_base._values._failEarlyRangeCheck(index, bounds: bounds)
	}
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
		_base._values._failEarlyRangeCheck(range, bounds: bounds)
	}
}
extension DevicesCore.OrderedDictionary.Elements : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension DevicesCore.OrderedDictionary.Elements : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension DevicesCore.OrderedDictionary.Elements : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension DevicesCore.OrderedDictionary.Elements : Swift.Equatable where Value : Swift.Equatable {
  @inlinable public static func == (left: DevicesCore.OrderedDictionary<Key, Value>.Elements, right: DevicesCore.OrderedDictionary<Key, Value>.Elements) -> Swift.Bool {
		left._base == right._base
	}
}
extension DevicesCore.OrderedDictionary.Elements : Swift.Hashable where Value : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
		_base.hash(into: &hasher)
	}
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesCore.OrderedDictionary.Elements {
  @inlinable @inline(__always) public mutating func swapAt(_ i: Swift.Int, _ j: Swift.Int) {
		_base.swapAt(i, j)
	}
  @inlinable @inline(__always) public mutating func partition(by belongsInSecondPartition: (DevicesCore.OrderedDictionary<Key, Value>.Elements.Element) throws -> Swift.Bool) rethrows -> Swift.Int {
		try _base.partition(by: belongsInSecondPartition)
	}
}
extension DevicesCore.OrderedDictionary.Elements {
  @inlinable @inline(__always) public mutating func sort(by areInIncreasingOrder: (DevicesCore.OrderedDictionary<Key, Value>.Elements.Element, DevicesCore.OrderedDictionary<Key, Value>.Elements.Element) throws -> Swift.Bool) rethrows {
		try _base.sort(by: areInIncreasingOrder)
	}
}
extension DevicesCore.OrderedDictionary.Elements where Key : Swift.Comparable {
  @inlinable @inline(__always) public mutating func sort() {
		_base.sort()
	}
}
extension DevicesCore.OrderedDictionary.Elements {
  @inlinable public mutating func shuffle() {
		_base.shuffle()
	}
  @inlinable public mutating func shuffle<T>(using generator: inout T) where T : Swift.RandomNumberGenerator {
		_base.shuffle(using: &generator)
	}
}
extension DevicesCore.OrderedDictionary.Elements {
  @inlinable public mutating func reverse() {
		_base.reverse()
	}
}
extension DevicesCore.OrderedDictionary.Elements {
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
		_base.removeAll(keepingCapacity: keepCapacity)
	}
  @discardableResult
  @inlinable public mutating func remove(at index: Swift.Int) -> DevicesCore.OrderedDictionary<Key, Value>.Elements.Element {
		_base.remove(at: index)
	}
  @inlinable public mutating func removeSubrange(_ bounds: Swift.Range<Swift.Int>) {
		_base.removeSubrange(bounds)
	}
  @inlinable public mutating func removeSubrange<R>(_ bounds: R) where R : Swift.RangeExpression, R.Bound == Swift.Int {
		_base.removeSubrange(bounds)
	}
  @discardableResult
  @inlinable public mutating func removeLast() -> DevicesCore.OrderedDictionary<Key, Value>.Elements.Element {
		_base.removeLast()
	}
  @inlinable public mutating func removeLast(_ n: Swift.Int) {
		_base.removeLast(n)
	}
  @discardableResult
  @inlinable public mutating func removeFirst() -> DevicesCore.OrderedDictionary<Key, Value>.Elements.Element {
		_base.removeFirst()
	}
  @inlinable public mutating func removeFirst(_ n: Swift.Int) {
		_base.removeFirst(n)
	}
  @inlinable public mutating func removeAll(where shouldBeRemoved: (DevicesCore.OrderedDictionary<Key, Value>.Elements.Element) throws -> Swift.Bool) rethrows {
		try _base.removeAll(where: shouldBeRemoved)
	}
}
extension DevicesCore.OrderedDictionary : Swift.Equatable where Value : Swift.Equatable {
  @inlinable public static func == (left: DevicesCore.OrderedDictionary<Key, Value>, right: DevicesCore.OrderedDictionary<Key, Value>) -> Swift.Bool {
		left._keys == right._keys && left._values == right._values
	}
}
extension DevicesCore.OrderedDictionary : Swift.ExpressibleByDictionaryLiteral {
  @inlinable public init(dictionaryLiteral elements: (Key, Value)...) {
		self.init(uniqueKeysWithValues: elements)
	}
}
extension DevicesCore.OrderedDictionary : Swift.Hashable where Value : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
		hasher.combine(count) // Discriminator
		for (key, value) in self {
			hasher.combine(key)
			hasher.combine(value)
		}
	}
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesCore.OrderedDictionary {
  @inlinable @inline(__always) public init() {
		self._keys = OrderedSet()
		self._values = []
	}
  @inlinable @inline(__always) public init(minimumCapacity: Swift.Int, persistent: Swift.Bool = false) {
		self._keys = OrderedSet(minimumCapacity: minimumCapacity, persistent: persistent)
		self._values = []
		_values.reserveCapacity(minimumCapacity)
	}
}
extension DevicesCore.OrderedDictionary {
  @_disfavoredOverload @inlinable public init<S>(uniqueKeysWithValues keysAndValues: S) where S : Swift.Sequence, S.Element == (key: Key, value: Value) {
		if S.self == [Key: Value].self {
			self.init(_uncheckedUniqueKeysWithValues: keysAndValues)
			return
		}
		self.init()
		reserveCapacity(keysAndValues.underestimatedCount)
		for (key, value) in keysAndValues {
			guard _keys._append(key).inserted else {
				preconditionFailure("Duplicate key: '\(key)'")
			}
			_values.append(value)
		}
	}
  @inlinable public init<S>(uniqueKeysWithValues keysAndValues: S) where S : Swift.Sequence, S.Element == (Key, Value) {
		self.init()
		reserveCapacity(keysAndValues.underestimatedCount)
		for (key, value) in keysAndValues {
			guard _keys._append(key).inserted else {
				preconditionFailure("Duplicate key: '\(key)'")
			}
			_values.append(value)
		}
	}
}
extension DevicesCore.OrderedDictionary {
  @inlinable public init<Keys, Values>(uniqueKeys keys: Keys, values: Values) where Key == Keys.Element, Value == Values.Element, Keys : Swift.Sequence, Values : Swift.Sequence {
		let keys = ContiguousArray(keys)
		let values = ContiguousArray(values)
		precondition(
			keys.count == values.count,
			"Mismatching element counts between keys and values"
		)
		self._keys = .init(keys)
		self._values = values
		precondition(_keys.count == _values.count, "Duplicate keys")
		_checkInvariants()
	}
}
extension DevicesCore.OrderedDictionary {
  @_disfavoredOverload @inlinable @inline(__always) public init<S>(_ keysAndValues: S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (key: Key, value: Value) {
		self.init()
		try self.merge(keysAndValues, uniquingKeysWith: combine)
	}
  @inlinable @inline(__always) public init<S>(_ keysAndValues: S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (Key, Value) {
		self.init()
		try self.merge(keysAndValues, uniquingKeysWith: combine)
	}
}
extension DevicesCore.OrderedDictionary {
  @inlinable public init<S>(grouping values: S, by keyForValue: (S.Element) throws -> Key) rethrows where Value : Swift.RangeReplaceableCollection, S : Swift.Sequence, Value.Element == S.Element {
		try self.init(_grouping: values, by: keyForValue)
	}
  @inlinable public init<S>(grouping values: S, by keyForValue: (S.Element) throws -> Key) rethrows where Value == [S.Element], S : Swift.Sequence {
		// Note: this extra overload is necessary to make type inference work
		// for the `Value` type -- we want it to default to `[S.Element`].
		// (https://github.com/apple/swift-collections/issues/139)
		try self.init(_grouping: values, by: keyForValue)
	}
  @inlinable internal init<S>(_grouping values: S, by keyForValue: (S.Element) throws -> Key) rethrows where Value : Swift.RangeReplaceableCollection, S : Swift.Sequence, Value.Element == S.Element {
		self.init()
		for value in values {
			let key = try keyForValue(value)
			self.updateValue(forKey: key, default: Value()) { array in
				array.append(value)
			}
		}
	}
}
extension DevicesCore.OrderedDictionary {
  @inlinable internal init<S>(_uncheckedUniqueKeysWithValues keysAndValues: S) where S : Swift.Sequence, S.Element == (key: Key, value: Value) {
		self.init()
		reserveCapacity(keysAndValues.underestimatedCount)
		for (key, value) in keysAndValues {
			_keys._appendNew(key)
			_values.append(value)
		}
		_checkInvariants()
	}
  @_disfavoredOverload @inlinable public init<S>(uncheckedUniqueKeysWithValues keysAndValues: S) where S : Swift.Sequence, S.Element == (key: Key, value: Value) {
		self.init(_uncheckedUniqueKeysWithValues: keysAndValues)
	}
  @inlinable public init<S>(uncheckedUniqueKeysWithValues keysAndValues: S) where S : Swift.Sequence, S.Element == (Key, Value) {
		// Add tuple labels
		let keysAndValues = keysAndValues.lazy.map { (key: $0.0, value: $0.1) }
		self.init(uncheckedUniqueKeysWithValues: keysAndValues)
	}
}
extension DevicesCore.OrderedDictionary {
  @inlinable @inline(__always) public init<Keys, Values>(uncheckedUniqueKeys keys: Keys, values: Values) where Key == Keys.Element, Value == Values.Element, Keys : Swift.Sequence, Values : Swift.Sequence {
		self._keys = .init(uncheckedUniqueElements: keys)
		self._values = .init(values)
		precondition(_keys.count == _values.count)
		_checkInvariants()
	}
}
extension DevicesCore.OrderedDictionary {
  public static var _isConsistencyCheckingEnabled: Swift.Bool {
    get
  }
  @inline(__always) @inlinable public func _checkInvariants() {}
}
extension DevicesCore.OrderedDictionary {
  @inlinable public mutating func swapAt(_ i: Swift.Int, _ j: Swift.Int) {
		_keys.swapAt(i, j)
		_values.swapAt(i, j)
	}
  @inlinable public mutating func partition(by belongsInSecondPartition: (DevicesCore.OrderedDictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows -> Swift.Int {
		let pivot = try _values.withUnsafeMutableBufferPointer { values in
			try _keys._partition(values: values, by: belongsInSecondPartition)
		}
		_checkInvariants()
		return pivot
	}
}
extension DevicesCore.OrderedDictionary {
  @inlinable public mutating func sort(by areInIncreasingOrder: (DevicesCore.OrderedDictionary<Key, Value>.Element, DevicesCore.OrderedDictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows {
		// FIXME: Implement in-place sorting.
		let temp = try self.sorted(by: areInIncreasingOrder)
		precondition(temp.count == self.count)
		temp.withUnsafeBufferPointer { source in
			_keys = OrderedSet(uncheckedUniqueElements: source.lazy.map(\.key))
			_values = ContiguousArray(source.lazy.map(\.value))
		}
		_checkInvariants()
	}
}
extension DevicesCore.OrderedDictionary where Key : Swift.Comparable {
  @inlinable public mutating func sort() {
		sort { $0.key < $1.key }
	}
}
extension DevicesCore.OrderedDictionary {
  @inlinable public mutating func shuffle() {
		var generator = SystemRandomNumberGenerator()
		shuffle(using: &generator)
	}
  @inlinable public mutating func shuffle<T>(using generator: inout T) where T : Swift.RandomNumberGenerator {
		guard count > 1 else { return }
		var keys = self._keys.elements
		var values = self._values
		self = [:]
		var amount = keys.count
		var current = 0
		while amount > 1 {
			let random = Int.random(in: 0 ..< amount, using: &generator)
			amount -= 1
			keys.swapAt(current, current + random)
			values.swapAt(current, current + random)
			current += 1
		}
		self = OrderedDictionary(uncheckedUniqueKeys: keys, values: values)
	}
}
extension DevicesCore.OrderedDictionary {
  @inlinable public mutating func reverse() {
		_keys.reverse()
		_values.reverse()
	}
}
extension DevicesCore.OrderedDictionary {
  @inlinable public mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
		self._keys.reserveCapacity(minimumCapacity)
		self._values.reserveCapacity(minimumCapacity)
	}
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
		_keys.removeAll(keepingCapacity: keepCapacity)
		_values.removeAll(keepingCapacity: keepCapacity)
	}
  @discardableResult
  @inlinable public mutating func remove(at index: Swift.Int) -> DevicesCore.OrderedDictionary<Key, Value>.Element {
		let key = _keys.remove(at: index)
		let value = _values.remove(at: index)
		return (key, value)
	}
  @inlinable public mutating func removeSubrange(_ bounds: Swift.Range<Swift.Int>) {
		_keys.removeSubrange(bounds)
		_values.removeSubrange(bounds)
	}
  @inlinable public mutating func removeSubrange<R>(_ bounds: R) where R : Swift.RangeExpression, R.Bound == Swift.Int {
		removeSubrange(bounds.relative(to: elements))
	}
  @discardableResult
  @inlinable public mutating func removeLast() -> DevicesCore.OrderedDictionary<Key, Value>.Element {
		precondition(!isEmpty, "Cannot remove last element of an empty collection")
		return remove(at: count - 1)
	}
  @inlinable public mutating func removeLast(_ n: Swift.Int) {
		precondition(n >= 0, "Can't remove a negative number of elements")
		precondition(n <= count, "Can't remove more elements than there are in the collection")
		_keys.removeLast(n)
		_values.removeLast(n)
	}
  @discardableResult
  @inlinable public mutating func removeFirst() -> DevicesCore.OrderedDictionary<Key, Value>.Element {
		precondition(!isEmpty, "Cannot remove first element of an empty collection")
		return remove(at: 0)
	}
  @inlinable public mutating func removeFirst(_ n: Swift.Int) {
		precondition(n >= 0, "Can't remove a negative number of elements")
		precondition(n <= count, "Can't remove more elements than there are in the collection")
		_keys.removeFirst(n)
		_values.removeFirst(n)
	}
  @inlinable public mutating func removeAll(where shouldBeRemoved: (DevicesCore.OrderedDictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows {
		let pivot = try _values.withUnsafeMutableBufferPointer { values in
			try _keys._halfStablePartition(
				values: values,
				by: shouldBeRemoved
			)
		}
		removeSubrange(pivot...)
		_checkInvariants()
	}
}
extension DevicesCore.OrderedDictionary : @unchecked Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension DevicesCore.OrderedDictionary : Swift.Sequence {
  public typealias Element = (key: Key, value: Value)
  @frozen public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal let _base: DevicesCore.OrderedDictionary<Key, Value>
    @usableFromInline
    internal var _position: Swift.Int
    @inlinable @inline(__always) internal init(_base: DevicesCore.OrderedDictionary<Key, Value>) {
			self._base = _base
			self._position = 0
		}
    @inlinable public mutating func next() -> DevicesCore.OrderedDictionary<Key, Value>.Element? {
			guard _position < _base._values.count else { return nil }
			let result = (_base._keys[_position], _base._values[_position])
			_position += 1
			return result
		}
    public typealias Element = DevicesCore.OrderedDictionary<Key, Value>.Element
  }
  @inlinable @inline(__always) public var underestimatedCount: Swift.Int {
    get {
		count
	}
  }
  @inlinable @inline(__always) public func makeIterator() -> DevicesCore.OrderedDictionary<Key, Value>.Iterator {
		Iterator(_base: self)
	}
}
extension DevicesCore.OrderedDictionary.Iterator : Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension DevicesCore.OrderedDictionary {
  @frozen public struct Values {
    @usableFromInline
    internal var _base: DevicesCore.OrderedDictionary<Key, Value>
    @inlinable @inline(__always) internal init(_base: DevicesCore.OrderedDictionary<Key, Value>) {
			self._base = _base
		}
  }
}
extension DevicesCore.OrderedDictionary.Values : Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension DevicesCore.OrderedDictionary.Values : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension DevicesCore.OrderedDictionary.Values : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension DevicesCore.OrderedDictionary.Values {
  @inlinable @inline(__always) public var elements: [Value] {
    get {
		Array(_base._values)
	}
  }
}
extension DevicesCore.OrderedDictionary.Values {
  @inlinable @inline(__always) public func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<DevicesCore.OrderedDictionary<Key, Value>.Values.Element>) throws -> R) rethrows -> R {
		try _base._values.withUnsafeBufferPointer(body)
	}
  @inlinable @inline(__always) public mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<DevicesCore.OrderedDictionary<Key, Value>.Values.Element>) throws -> R) rethrows -> R {
		try _base._values.withUnsafeMutableBufferPointer(body)
	}
}
extension DevicesCore.OrderedDictionary.Values : Swift.Sequence {
  public typealias Element = Value
  public typealias Iterator = Swift.IndexingIterator<DevicesCore.OrderedDictionary<Key, Value>.Values>
}
extension DevicesCore.OrderedDictionary.Values : Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable @inline(__always) public var startIndex: Swift.Int {
    get { 0 }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Int {
    get { _base._values.count }
  }
  @inlinable @inline(__always) public func index(after i: Swift.Int) -> Swift.Int { i + 1 }
  @inlinable @inline(__always) public func index(before i: Swift.Int) -> Swift.Int { i - 1 }
  @inlinable @inline(__always) public func formIndex(after i: inout Swift.Int) { i += 1 }
  @inlinable @inline(__always) public func formIndex(before i: inout Swift.Int) { i -= 1 }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
		i + distance
	}
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
		_base._values.index(i, offsetBy: distance, limitedBy: limit)
	}
  @inlinable @inline(__always) public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
		end - start
	}
  @inlinable @inline(__always) public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Value>) throws -> R) rethrows -> R? {
		try _base._values.withUnsafeBufferPointer(body)
	}
}
extension DevicesCore.OrderedDictionary.Values : Swift.MutableCollection {
  @inlinable @inline(__always) public subscript(position: Swift.Int) -> Value {
    get {
			_base._values[position]
		}
    @inline(__always) _modify {
			yield &_base._values[position]
		}
  }
  @inlinable @inline(__always) public mutating func swapAt(_ i: Swift.Int, _ j: Swift.Int) {
		_base._values.swapAt(i, j)
	}
  @inlinable @inline(__always) public mutating func partition(by belongsInSecondPartition: (Value) throws -> Swift.Bool) rethrows -> Swift.Int {
		try _base._values.partition(by: belongsInSecondPartition)
	}
  @inlinable @inline(__always) public mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<DevicesCore.OrderedDictionary<Key, Value>.Values.Element>) throws -> R) rethrows -> R? {
		try _base._values.withUnsafeMutableBufferPointer(body)
	}
  public typealias SubSequence = Swift.Slice<DevicesCore.OrderedDictionary<Key, Value>.Values>
}
extension DevicesCore.OrderedDictionary.Values : Swift.Equatable where Value : Swift.Equatable {
  @inlinable public static func == (left: DevicesCore.OrderedDictionary<Key, Value>.Values, right: DevicesCore.OrderedDictionary<Key, Value>.Values) -> Swift.Bool {
		left.elementsEqual(right)
	}
}
extension DevicesCore.OrderedDictionary.Values : Swift.Hashable where Value : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
		hasher.combine(count) // Discriminator
		for item in self {
			hasher.combine(item)
		}
	}
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public struct OrderedDictionary<Key, Value> where Key : Swift.Hashable {
  @usableFromInline
  internal var _keys: DevicesCore.OrderedSet<Key>
  @usableFromInline
  internal var _values: Swift.ContiguousArray<Value>
  @inlinable @inline(__always) internal init(_uniqueKeys keys: DevicesCore.OrderedSet<Key>, values: Swift.ContiguousArray<Value>) {
		self._keys = keys
		self._values = values
	}
}
extension DevicesCore.OrderedDictionary {
  @inlinable @inline(__always) public var keys: DevicesCore.OrderedSet<Key> {
    get { _keys }
  }
  @inlinable @inline(__always) public var values: DevicesCore.OrderedDictionary<Key, Value>.Values {
    get { Values(_base: self) }
    @inline(__always) _modify {
			var values = Values(_base: self)
			self = [:]
			defer { self = values._base }
			yield &values
		}
  }
}
extension DevicesCore.OrderedDictionary {
  public typealias Index = Swift.Int
  @inlinable @inline(__always) public var isEmpty: Swift.Bool {
    get { _values.isEmpty }
  }
  @inlinable @inline(__always) public var count: Swift.Int {
    get { _values.count }
  }
  @inlinable @inline(__always) public func index(forKey key: Key) -> Swift.Int? {
		_keys.firstIndex(of: key)
	}
}
extension DevicesCore.OrderedDictionary {
  @inlinable public subscript(key: Key) -> Value? {
    get {
			guard let index = _keys.firstIndex(of: key) else { return nil }
			return _values[index]
		}
    set {
			// We have a separate `set` in addition to `_modify` in hopes of getting
			// rid of `_modify`'s swapAt dance in the usual case where the caller just
			// wants to assign a new value.
			let (index, bucket) = _keys._find(key)
			switch (index, newValue) {
			case let (index?, newValue?): // Assign
				_values[index] = newValue
			case let (index?, nil): // Remove
				_keys._removeExistingMember(at: index, in: bucket)
				_values.remove(at: index)
			case let (nil, newValue?): // Insert
				_keys._appendNew(key, in: bucket)
				_values.append(newValue)
			case (nil, nil): // Noop
				break
			}
			_checkInvariants()
		}
    @inline(__always) _modify {
			var value: Value?
			let (index, bucket) = _prepareForKeyingModify(key, &value)
			defer {
				_finalizeKeyingModify(key, index, bucket, &value)
			}
			yield &value
		}
  }
  @inlinable internal mutating func _prepareForKeyingModify(_ key: Key, _ value: inout Value?) -> (index: Swift.Int?, bucket: DevicesCore._HashTable.Bucket) {
		let (index, bucket) = _keys._find(key)

		// To support in-place mutations better, we swap the value to the end of
		// the array, pop it off, then put things back in place when we're done.
		if let index = index {
			_values.swapAt(index, _values.count - 1)
			value = _values.removeLast()
		}
		return (index, bucket)
	}
  @inlinable internal mutating func _finalizeKeyingModify(_ key: Key, _ index: Swift.Int?, _ bucket: DevicesCore._HashTable.Bucket, _ value: inout Value?) {
		switch (index, value) {
		case let (index?, value?): // Assign
			_values.append(value)
			_values.swapAt(index, _values.count - 1)
		case let (index?, nil): // Remove
			if index < _values.count {
				let standin = _values.remove(at: index)
				_values.append(standin)
			}
			_keys._removeExistingMember(at: index, in: bucket)
		case let (nil, value?): // Insert
			_keys._appendNew(key, in: bucket)
			_values.append(value)
		case (nil, nil): // Noop
			break
		}
		_checkInvariants()
	}
  @inlinable public subscript(key: Key, default defaultValue: @autoclosure () -> Value) -> Value {
    get {
			guard let offset = _keys.firstIndex(of: key) else { return defaultValue() }
			return _values[offset]
		}
    @inline(__always) _modify {
			var (index, value) = _prepareForDefaultedModify(key, defaultValue)
			defer {
				_finalizeDefaultedModify(index, &value)
			}
			yield &value
		}
  }
  @inlinable internal mutating func _prepareForDefaultedModify(_ key: Key, _ defaultValue: () -> Value) -> (index: Swift.Int, value: Value) {
		let (inserted, index) = _keys.append(key)
		if inserted {
			assert(index == _values.count)
			_values.append(defaultValue())
		}
		let value: Value = _values.withUnsafeMutableBufferPointer { buffer in
			assert(index < buffer.count)
			return (buffer.baseAddress! + index).move()
		}
		return (index, value)
	}
  @inlinable internal mutating func _finalizeDefaultedModify(_ index: Swift.Int, _ value: inout Value) {
		_values.withUnsafeMutableBufferPointer { buffer in
			assert(index < buffer.count)
			(buffer.baseAddress! + index).initialize(to: value)
		}
	}
}
extension DevicesCore.OrderedDictionary {
  @discardableResult
  @inlinable public mutating func updateValue(_ value: Value, forKey key: Key) -> Value? {
		let (index, bucket) = _keys._find(key)
		if let index = index {
			let old = _values[index]
			_values[index] = value
			return old
		}
		_keys._appendNew(key, in: bucket)
		_values.append(value)
		return nil
	}
  @discardableResult
  @inlinable public mutating func updateValue(_ value: Value, forKey key: Key, insertingAt index: Swift.Int) -> (originalMember: Value?, index: Swift.Int) {
		let (inserted, offset) = _keys.insert(key, at: index)
		if inserted {
			assert(offset == index)
			_values.insert(value, at: offset)
			return (nil, offset)
		}
		let old = _values[offset]
		_values[offset] = value
		return (old, offset)
	}
  @inlinable public mutating func updateValue<R>(forKey key: Key, default defaultValue: @autoclosure () -> Value, with body: (inout Value) throws -> R) rethrows -> R {
		let (index, bucket) = _keys._find(key)
		if let index = index {
			return try body(&_values[index])
		}
		_keys._appendNew(key, in: bucket)
		_values.append(defaultValue())
		let i = _values.index(before: _values.endIndex)
		return try body(&_values[i])
	}
  @inlinable public mutating func updateValue<R>(forKey key: Key, insertingDefault defaultValue: @autoclosure () -> Value, at index: Swift.Int, with body: (inout Value) throws -> R) rethrows -> R {
		let (existingIndex, bucket) = _keys._find(key)
		if let existingIndex = existingIndex {
			return try body(&_values[existingIndex])
		}
		_keys._insertNew(key, at: index, in: bucket)
		_values.insert(defaultValue(), at: index)
		return try body(&_values[index])
	}
}
extension DevicesCore.OrderedDictionary {
  @discardableResult
  @inlinable public mutating func removeValue(forKey key: Key) -> Value? {
		let (idx, bucket) = _keys._find(key)
		guard let index = idx else { return nil }
		_keys._removeExistingMember(at: index, in: bucket)
		return _values.remove(at: index)
	}
}
extension DevicesCore.OrderedDictionary {
  @_disfavoredOverload @inlinable public mutating func merge<S>(_ keysAndValues: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (key: Key, value: Value) {
		for (key, value) in keysAndValues {
			let (index, bucket) = _keys._find(key)
			if let index = index {
				try { $0 = try combine($0, value) }(&_values[index])
			} else {
				_keys._appendNew(key, in: bucket)
				_values.append(value)
			}
		}
	}
  @inlinable public mutating func merge<S>(_ keysAndValues: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (Key, Value) {
		let mapped: LazyMapSequence =
			keysAndValues.lazy.map { (key: $0.0, value: $0.1) }
		try merge(mapped, uniquingKeysWith: combine)
	}
  @_disfavoredOverload @inlinable public __consuming func merging<S>(_ other: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows -> DevicesCore.OrderedDictionary<Key, Value> where S : Swift.Sequence, S.Element == (key: Key, value: Value) {
		var copy = self
		try copy.merge(other, uniquingKeysWith: combine)
		return copy
	}
  @inlinable public __consuming func merging<S>(_ other: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows -> DevicesCore.OrderedDictionary<Key, Value> where S : Swift.Sequence, S.Element == (Key, Value) {
		var copy = self
		try copy.merge(other, uniquingKeysWith: combine)
		return copy
	}
}
extension DevicesCore.OrderedDictionary {
  @inlinable public func filter(_ isIncluded: (DevicesCore.OrderedDictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows -> DevicesCore.OrderedDictionary<Key, Value> {
		var result: OrderedDictionary = [:]
		for element in self where try isIncluded(element) {
			result._keys._appendNew(element.key)
			result._values.append(element.value)
		}
		return result
	}
}
extension DevicesCore.OrderedDictionary {
  @inlinable public func mapValues<T>(_ transform: (Value) throws -> T) rethrows -> DevicesCore.OrderedDictionary<Key, T> {
		OrderedDictionary<Key, T>(
			_uniqueKeys: _keys,
			values: ContiguousArray(try _values.map(transform))
		)
	}
  @inlinable public func compactMapValues<T>(_ transform: (Value) throws -> T?) rethrows -> DevicesCore.OrderedDictionary<Key, T> {
		var result: OrderedDictionary<Key, T> = [:]
		for (key, value) in self {
			if let value = try transform(value) {
				result._keys._appendNew(key)
				result._values.append(value)
			}
		}
		return result
	}
}
extension DevicesCore.OrderedSet : Swift.Encodable where Element : Swift.Encodable {
  @inlinable public func encode(to encoder: Swift.Encoder) throws {
		var container = encoder.singleValueContainer()
		try container.encode(_elements)
	}
}
extension DevicesCore.OrderedSet : Swift.Decodable where Element : Swift.Decodable {
  @inlinable public init(from decoder: Swift.Decoder) throws {
		let container = try decoder.singleValueContainer()
		let elements = try container.decode(ContiguousArray<Element>.self)

		let (table, end) = _HashTable.create(untilFirstDuplicateIn: elements)
		guard end == elements.endIndex else {
			let context = DecodingError.Context(
				codingPath: container.codingPath,
				debugDescription: "Decoded elements aren't unique (first duplicate at offset \(end))"
			)
			throw DecodingError.dataCorrupted(context)
		}
		self.init(
			_uniqueElements: elements,
			elements.count > _HashTable.maximumUnhashedCount ? table : nil
		)
	}
}
extension DevicesCore.OrderedSet : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension DevicesCore.OrderedSet : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension DevicesCore.OrderedSet : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension DevicesCore.OrderedSet {
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public func difference(from other: DevicesCore.OrderedSet<Element>) -> Swift.CollectionDifference<Element>
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public func applying(_ difference: Swift.CollectionDifference<Element>) -> DevicesCore.OrderedSet<Element>?
}
extension DevicesCore.OrderedSet : Swift.Equatable {
  @inlinable public static func == (left: DevicesCore.OrderedSet<Element>, right: DevicesCore.OrderedSet<Element>) -> Swift.Bool {
		left.elementsEqual(right)
	}
}
extension DevicesCore.OrderedSet : Swift.ExpressibleByArrayLiteral {
  @inlinable public init(arrayLiteral elements: Element...) {
		self.init(elements)
	}
  public typealias ArrayLiteralElement = Element
}
extension DevicesCore.OrderedSet : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
		hasher.combine(count) // Discriminator
		for item in _elements {
			hasher.combine(item)
		}
	}
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesCore.OrderedSet {
  @inlinable @inline(__always) public init<S>(uncheckedUniqueElements elements: S) where Element == S.Element, S : Swift.Sequence {
		let elements = ContiguousArray<Element>(elements)
		let table = _HashTable.create(uncheckedUniqueElements: elements)
		self.init(
			_uniqueElements: elements,
			elements.count > _HashTable.maximumUnhashedCount ? table : nil
		)
		_checkInvariants()
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public init<S>(_ elements: S) where Element == S.Element, S : Swift.Sequence {
		if S.self == Self.self {
			self = elements as! Self
			return
		}
		// Fast paths for when we know elements are all unique
		if elements is _UniqueCollection {
			self.init(uncheckedUniqueElements: elements)
			return
		}

		self.init(minimumCapacity: elements.underestimatedCount)
		append(contentsOf: elements)
	}
  @inlinable public init(_ elements: DevicesCore.OrderedSet<Element>) {
		self = elements
	}
  @inlinable public init(_ elements: DevicesCore.OrderedSet<Element>.SubSequence) {
		self.init(uncheckedUniqueElements: elements._slice)
	}
  @inlinable public init(_ elements: Swift.Set<Element>) {
		self.init(uncheckedUniqueElements: elements)
	}
  @inlinable public init<Value>(_ elements: Swift.Dictionary<Element, Value>.Keys) {
		self._elements = ContiguousArray(elements)
		_regenerateHashTable()
		_checkInvariants()
	}
  @inlinable public init<C>(_ elements: C) where Element == C.Element, C : Swift.RandomAccessCollection {
		// This code is careful not to copy storage if `C` is an Array
		// or ContiguousArray and the elements are already unique.
		let (table, firstDupe) = _HashTable.create(
			untilFirstDuplicateIn: elements)
		if firstDupe == elements.endIndex {
			// Fast path: `elements` consists of unique values.
			self.init(_uniqueElements: ContiguousArray(elements), table)
			return
		}

		// Otherwise keep the elements we've processed and add the rest one by one.
		self.init(_uniqueElements: ContiguousArray(elements[..<firstDupe]), table)
		self.append(contentsOf: elements[firstDupe...])
	}
}
extension DevicesCore.OrderedSet {
  @inlinable internal mutating func _appendNew(_ item: Element) {
		assert(!contains(item), "Duplicate item")
		_elements.append(item)
		guard _elements.count <= _capacity else {
			_regenerateHashTable()
			return
		}
		guard _table != nil else { return }
		_ensureUnique()
		_table!.update { hashTable in
			var it = hashTable.bucketIterator(for: item)
			it.advanceToNextUnoccupiedBucket()
			it.currentValue = _elements.count - 1
		}
	}
  @inlinable internal mutating func _appendNew(_ item: Element, in bucket: DevicesCore.OrderedSet<Element>._Bucket) {
		_elements.append(item)

		guard _elements.count <= _capacity else {
			_regenerateHashTable()
			return
		}
		guard _table != nil else { return }
		_ensureUnique()
		_table!.update { hashTable in
			assert(!hashTable.isOccupied(bucket))
			hashTable[bucket] = _elements.count - 1
		}
	}
  @discardableResult
  @inlinable internal mutating func _append(_ item: Element) -> (inserted: Swift.Bool, index: Swift.Int) {
		let (index, bucket) = _find(item)
		if let index = index { return (false, index) }
		_appendNew(item, in: bucket)
		return (true, _elements.index(before: _elements.endIndex))
	}
  @discardableResult
  @inlinable @inline(__always) public mutating func append(_ item: Element) -> (inserted: Swift.Bool, index: Swift.Int) {
		let result = _append(item)
		_checkInvariants()
		return result
	}
  @inlinable public mutating func append<S>(contentsOf elements: S) where Element == S.Element, S : Swift.Sequence {
		for item in elements {
			_append(item)
		}
		_checkInvariants()
	}
}
extension DevicesCore.OrderedSet {
  @inlinable internal mutating func _insertNew(_ item: Element, at index: Swift.Int, in bucket: DevicesCore.OrderedSet<Element>._Bucket) {
		guard _elements.count < _capacity else {
			_elements.insert(item, at: index)
			_regenerateHashTable()
			return
		}
		guard _table != nil else {
			_elements.insert(item, at: index)
			return
		}

		_ensureUnique()
		_table!.update { hashTable in
			assert(!hashTable.isOccupied(bucket))
			hashTable.adjustContents(preparingForInsertionOfElementAtOffset: index, in: _elements)
			hashTable[bucket] = index
		}
		_elements.insert(item, at: index)
		_checkInvariants()
	}
  @discardableResult
  @inlinable public mutating func insert(_ item: Element, at index: Swift.Int) -> (inserted: Swift.Bool, index: Swift.Int) {
		let (existing, bucket) = _find(item)
		if let existing = existing { return (false, existing) }
		_insertNew(item, at: index, in: bucket)
		return (true, index)
	}
}
extension DevicesCore.OrderedSet {
  @discardableResult
  @inlinable public mutating func update(_ item: Element, at index: Swift.Int) -> Element {
		let old = _elements[index]
		precondition(
			item == old,
			"The replacement item must compare equal to the original"
		)
		_elements[index] = item
		return old
	}
}
extension DevicesCore.OrderedSet {
  @discardableResult
  @inlinable public mutating func updateOrAppend(_ item: Element) -> Element? {
		let (inserted, index) = _append(item)
		if inserted { return nil }
		let old = _elements[index]
		_elements[index] = item
		_checkInvariants()
		return old
	}
  @discardableResult
  @inlinable public mutating func updateOrInsert(_ item: Element, at index: Swift.Int) -> (originalMember: Element?, index: Swift.Int) {
		let (existing, bucket) = _find(item)
		if let existing = existing {
			let old = _elements[existing]
			_elements[existing] = item
			return (old, existing)
		}
		_insertNew(item, at: index, in: bucket)
		return (nil, index)
	}
}
extension DevicesCore.OrderedSet {
  public static var _isConsistencyCheckingEnabled: Swift.Bool {
    get
  }
  @inline(__always) @inlinable public func _checkInvariants() {}
}
extension DevicesCore.OrderedSet {
  @inlinable public mutating func swapAt(_ i: Swift.Int, _ j: Swift.Int) {
		guard i != j else { return }
		_elements.swapAt(i, j)
		guard _table != nil else { return }
		_ensureUnique()
		_table!.update { hashTable in
			hashTable.swapBucketValues(
				for: _elements[i],
				withCurrentValue: j,
				and: _elements[j],
				withCurrentValue: i
			)
		}
		_checkInvariants()
	}
  @inlinable public mutating func partition(by belongsInSecondPartition: (Element) throws -> Swift.Bool) rethrows -> Swift.Int {
		try _partition(by: belongsInSecondPartition, callback: { _, _ in })
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public mutating func _partition(by belongsInSecondPartition: (Element) throws -> Swift.Bool, callback: (Swift.Int, Swift.Int) -> Swift.Void) rethrows -> Swift.Int {
		guard _table != nil else {
			return try _elements.partition(by: belongsInSecondPartition)
		}
		_ensureUnique()
		let result: Int = try _table!.update { hashTable in
			let maybeOffset: Int? = try _elements.withContiguousMutableStorageIfAvailable { buffer in
				let pivot = try buffer._partition(
					with: hashTable,
					by: belongsInSecondPartition,
					callback: callback
				)
				return pivot - buffer.startIndex
			}
			if let offset = maybeOffset {
				return _elements.index(startIndex, offsetBy: offset)
			}
			return try _elements._partition(
				with: hashTable,
				by: belongsInSecondPartition,
				callback: callback
			)
		}
		_checkInvariants()
		return result
	}
}
extension Swift.MutableCollection where Self : Swift.RandomAccessCollection, Self.Element : Swift.Hashable {
  @inlinable internal mutating func _partition(with hashTable: DevicesCore._UnsafeHashTable, by belongsInSecondPartition: (Self.Element) throws -> Swift.Bool, callback: (Swift.Int, Swift.Int) -> Swift.Void) rethrows -> Self.Index {
		var low = startIndex
		var high = endIndex

		while true {
			// Invariants at this point:
			// - low <= high
			// - all elements in `startIndex ..< low` belong in the first partition
			// - all elements in `high ..< endIndex` belong in the second partition

			// Find next element from `lo` that may not be in the right place.
			while true {
				if low == high { return low }
				if try belongsInSecondPartition(self[low]) { break }
				formIndex(after: &low)
			}

			// Find next element down from `hi` that we can swap `lo` with.
			while true {
				formIndex(before: &high)
				if low == high { return low }
				if try !belongsInSecondPartition(self[high]) { break }
			}

			// Swap the two elements as well as their associated hash table buckets.
			swapAt(low, high)
			let offsetLow = _offset(of: low)
			let offsetHigh = _offset(of: high)
			hashTable.swapBucketValues(
				for: self[low],
				withCurrentValue: offsetHigh,
				and: self[high],
				withCurrentValue: offsetLow
			)
			callback(offsetLow, offsetHigh)

			formIndex(after: &low)
		}
	}
}
extension DevicesCore._HashTable.UnsafeHandle {
  @inlinable @inline(__always) internal func swapBucketValues<Element>(for left: Element, withCurrentValue leftValue: Swift.Int, and right: Element, withCurrentValue rightValue: Swift.Int) where Element : Swift.Hashable {
		let left = idealBucket(for: left)
		let right = idealBucket(for: right)
		swapBucketValues(
			for: left,
			withCurrentValue: leftValue,
			and: right,
			withCurrentValue: rightValue
		)
	}
  @usableFromInline
  @_effects(releasenone) internal func swapBucketValues(for left: DevicesCore._HashTable.UnsafeHandle.Bucket, withCurrentValue leftValue: Swift.Int, and right: DevicesCore._HashTable.UnsafeHandle.Bucket, withCurrentValue rightValue: Swift.Int)
}
extension DevicesCore.OrderedSet {
  @inlinable public mutating func sort(by areInIncreasingOrder: (Element, Element) throws -> Swift.Bool) rethrows {
		defer {
			// Note: This assumes that `sort(by:)` won't leave duplicate/missing
			// elements in the table when the closure throws. This matches the
			// stdlib's behavior in Swift 5.3, and it seems like a reasonable
			// long-term assumption.
			_regenerateExistingHashTable()
			_checkInvariants()
		}
		try _elements.sort(by: areInIncreasingOrder)
	}
}
extension DevicesCore.OrderedSet where Element : Swift.Comparable {
  @inlinable public mutating func sort() {
		defer {
			// Note: This assumes that `sort(by:)` won't leave duplicate/missing
			// elements in the table when the closure throws. This matches the
			// stdlib's behavior in Swift 5.3, and it seems like a reasonable
			// long-term assumption.
			_regenerateExistingHashTable()
			_checkInvariants()
		}
		_elements.sort()
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public mutating func shuffle() {
		var generator = SystemRandomNumberGenerator()
		shuffle(using: &generator)
	}
  @inlinable public mutating func shuffle<T>(using generator: inout T) where T : Swift.RandomNumberGenerator {
		_elements.shuffle(using: &generator)
		_regenerateExistingHashTable()
		_checkInvariants()
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public mutating func reverse() {
		_elements.reverse()
		// FIXME: Update hash table contents in place.
		_regenerateHashTable()
		_checkInvariants()
	}
}
extension DevicesCore.OrderedSet {
  @inlinable internal mutating func _halfStablePartition<Value>(values: Swift.UnsafeMutableBufferPointer<Value>, by belongsInSecondPartition: ((key: Element, value: Value)) throws -> Swift.Bool) rethrows -> Swift.Int {
		precondition(self.count == values.count)
		var i = 0
		try _elements.withUnsafeMutableBufferPointer { keys in
			while i < keys.count, try !belongsInSecondPartition((keys[i], values[i])) {
				i += 1
			}
		}
		guard i < self.count else { return self.count }

		self._ensureUnique()
		let table = _table
		self._table = nil
		defer { self._table = table }

		return try _elements.withUnsafeMutableBufferPointer { keys in
			for j in i + 1 ..< keys.count {
				guard try !belongsInSecondPartition((keys[j], values[j])) else {
					continue
				}
				keys.swapAt(i, j)
				values.swapAt(i, j)
				table?.update { hashTable in
					hashTable.swapBucketValues(
						for: keys[i],
						withCurrentValue: j,
						and: keys[j],
						withCurrentValue: i
					)
				}
				i += 1
			}
			return i
		}
	}
  @inlinable internal mutating func _partition<Value>(values: Swift.UnsafeMutableBufferPointer<Value>, by belongsInSecondPartition: ((key: Element, value: Value)) throws -> Swift.Bool) rethrows -> Swift.Int {
		self._ensureUnique()
		let table = self._table
		self._table = nil
		defer { self._table = table }
		return try _elements.withUnsafeMutableBufferPointer { keys in
			assert(keys.count == values.count)
			var low = keys.startIndex
			var high = keys.endIndex

			while true {
				// Invariants at this point:
				// - low <= high
				// - all elements in `startIndex ..< low` belong in the first partition
				// - all elements in `high ..< endIndex` belong in the second partition

				// Find next element from `lo` that may not be in the right place.
				while true {
					if low == high { return low }
					if try belongsInSecondPartition((keys[low], values[low])) { break }
					low += 1
				}

				// Find next element down from `hi` that we can swap `lo` with.
				while true {
					high -= 1
					if low == high { return low }
					if try !belongsInSecondPartition((keys[high], values[high])) { break }
				}

				// Swap the two elements as well as their associated hash table buckets.
				keys.swapAt(low, high)
				values.swapAt(low, high)
				table?.update { hashTable in
					hashTable.swapBucketValues(
						for: keys[low],
						withCurrentValue: high,
						and: keys[high],
						withCurrentValue: low
					)
				}
				low += 1
			}
		}
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
		_elements.removeAll(keepingCapacity: keepCapacity)
		guard keepCapacity else {
			_table = nil
			return
		}
		guard _table != nil else { return }
		_ensureUnique()
		_table!.update { hashTable in
			hashTable.clear()
		}
	}
  @discardableResult
  @inlinable public mutating func remove(at index: Swift.Int) -> DevicesCore.OrderedSet<Element>.Element {
		_elements._failEarlyRangeCheck(index, bounds: startIndex ..< endIndex)
		let bucket = _bucket(for: index)
		return _removeExistingMember(at: index, in: bucket)
	}
  @inlinable public mutating func removeSubrange(_ bounds: Swift.Range<Swift.Int>) {
		_elements._failEarlyRangeCheck(
			bounds,
			bounds: _elements.startIndex ..< _elements.endIndex
		)
		guard _table != nil else {
			_elements.removeSubrange(bounds)
			_checkInvariants()
			return
		}
		let c = bounds.count
		guard c > 0 else { return }
		let remainingCount = _elements.count - c
		if remainingCount <= count / 2 || remainingCount < _minimumCapacity {
			// Just generate a new table from scratch.
			_elements.removeSubrange(bounds)
			_regenerateHashTable()
			_checkInvariants()
			return
		}

		_ensureUnique()
		_table!.update { hashTable in
			// Delete the hash table entries for all members we're removing.
			for item in _elements[bounds] {
				let (offset, bucket) = hashTable._find(item, in: _elements)
				precondition(offset != nil, "Corrupt hash table")
				hashTable.delete(
					bucket: bucket,
					hashValueGenerator: { offset, seed in
						_elements[offset]._rawHashValue(seed: seed)
					}
				)
			}
			hashTable.adjustContents(preparingForRemovalOf: bounds, in: _elements)
		}
		_elements.removeSubrange(bounds)
		_checkInvariants()
	}
  @inlinable public mutating func removeSubrange<R>(_ bounds: R) where R : Swift.RangeExpression, R.Bound == Swift.Int {
		removeSubrange(bounds.relative(to: self))
	}
  @discardableResult
  @inlinable public mutating func removeLast() -> Element {
		precondition(!isEmpty, "Cannot remove last element of an empty collection")
		guard _table != nil else {
			return _elements.removeLast()
		}
		guard _elements.count - 1 >= _minimumCapacity else {
			let old = _elements.removeLast()
			_regenerateHashTable()
			return old
		}
		defer { _checkInvariants() }
		let old = _elements.removeLast()
		_ensureUnique()
		_table!.update { hashTable in
			var it = hashTable.bucketIterator(for: old)
			it.advance(until: _elements.count)
			// Delete the entry for the removed member.
			hashTable.delete(
				bucket: it.currentBucket,
				hashValueGenerator: { offset, seed in
					_elements[offset]._rawHashValue(seed: seed)
				}
			)
		}
		return old
	}
  @inlinable public mutating func removeLast(_ n: Swift.Int) {
		precondition(n >= 0, "Can't remove a negative number of elements")
		precondition(n <= count, "Can't remove more elements than there are in the collection")
		removeSubrange(count - n ..< count)
	}
  @discardableResult
  @inlinable public mutating func removeFirst() -> Element {
		precondition(!isEmpty, "Cannot remove first element of an empty collection")
		return remove(at: startIndex)
	}
  @inlinable public mutating func removeFirst(_ n: Swift.Int) {
		precondition(n >= 0, "Can't remove a negative number of elements")
		precondition(n <= count, "Can't remove more elements than there are in the collection")
		removeSubrange(0 ..< n)
	}
  @inlinable public mutating func removeAll(where shouldBeRemoved: (Element) throws -> Swift.Bool) rethrows {
		defer {
			_regenerateHashTable()
			_checkInvariants()
		}
		try _elements.removeAll(where: shouldBeRemoved)
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public mutating func formIntersection(_ other: DevicesCore.OrderedSet<Element>) {
		self = self.intersection(other)
	}
  @inlinable @inline(__always) public mutating func formIntersection(_ other: DevicesCore.OrderedSet<Element>.UnorderedView) {
		formIntersection(other._base)
	}
  @inlinable public mutating func formIntersection<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
		self = self.intersection(other)
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public mutating func formSymmetricDifference(_ other: __owned DevicesCore.OrderedSet<Element>) {
		self = self.symmetricDifference(other)
	}
  @inlinable @inline(__always) public mutating func formSymmetricDifference(_ other: __owned DevicesCore.OrderedSet<Element>.UnorderedView) {
		formSymmetricDifference(other._base)
	}
  @inlinable public mutating func formSymmetricDifference<S>(_ other: __owned S) where Element == S.Element, S : Swift.Sequence {
		self = self.symmetricDifference(other)
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public mutating func formUnion(_ other: __owned DevicesCore.OrderedSet<Element>) {
		append(contentsOf: other)
	}
  @inlinable @inline(__always) public mutating func formUnion(_ other: __owned DevicesCore.OrderedSet<Element>.UnorderedView) {
		formUnion(other._base)
	}
  @inlinable public mutating func formUnion<S>(_ other: __owned S) where Element == S.Element, S : Swift.Sequence {
		append(contentsOf: other)
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public __consuming func intersection(_ other: DevicesCore.OrderedSet<Element>) -> DevicesCore.OrderedSet<Element> {
		var result = Self()
		for item in self {
			if other.contains(item) {
				result._appendNew(item)
			}
		}
		result._checkInvariants()
		return result
	}
  @inlinable @inline(__always) public __consuming func intersection(_ other: DevicesCore.OrderedSet<Element>.UnorderedView) -> DevicesCore.OrderedSet<Element> {
		intersection(other._base)
	}
  @inlinable public __consuming func intersection<S>(_ other: S) -> DevicesCore.OrderedSet<Element> where Element == S.Element, S : Swift.Sequence {
		_UnsafeBitset.withTemporaryBitset(capacity: self.count) { bitset in
			for item in other {
				if let index = self._find_inlined(item).index {
					bitset.insert(index)
				}
			}
			let result = self._extractSubset(using: bitset)
			result._checkInvariants()
			return result
		}
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public func isDisjoint(with other: DevicesCore.OrderedSet<Element>) -> Swift.Bool {
		guard !self.isEmpty, !other.isEmpty else { return true }
		if self.count <= other.count {
			for item in self {
				if other.contains(item) { return false }
			}
		} else {
			for item in other {
				if self.contains(item) { return false }
			}
		}
		return true
	}
  @inlinable @inline(__always) public func isDisjoint(with other: DevicesCore.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
		isDisjoint(with: other._base)
	}
  @inlinable public func isDisjoint(with other: Swift.Set<Element>) -> Swift.Bool {
		guard !self.isEmpty, !other.isEmpty else { return true }
		if self.count <= other.count {
			for item in self {
				if other.contains(item) { return false }
			}
		} else {
			for item in other {
				if self.contains(item) { return false }
			}
		}
		return true
	}
  @inlinable public func isDisjoint<S>(with other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
		guard !self.isEmpty else { return true }
		for item in other {
			if self.contains(item) { return false }
		}
		return true
	}
}
extension DevicesCore.OrderedSet {
  public func isEqual(to other: DevicesCore.OrderedSet<Element>) -> Swift.Bool
  public func isEqual(to other: DevicesCore.OrderedSet<Element>.UnorderedView) -> Swift.Bool
  public func isEqual<S>(to other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence
}
extension DevicesCore.OrderedSet {
  @inlinable public func isStrictSubset(of other: DevicesCore.OrderedSet<Element>) -> Swift.Bool {
		self.count < other.count && self.isSubset(of: other)
	}
  @inlinable @inline(__always) public func isStrictSubset(of other: DevicesCore.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
		isStrictSubset(of: other._base)
	}
  @inlinable public func isStrictSubset(of other: Swift.Set<Element>) -> Swift.Bool {
		self.count < other.count && self.isSubset(of: other)
	}
  @inlinable public func isStrictSubset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
		if S.self == Self.self {
			return self.isStrictSubset(of: other as! Self)
		}
		if S.self == Set<Element>.self {
			return self.isStrictSubset(of: other as! Set<Element>)
		}

		var it = self.makeIterator()
		guard let first = it.next() else {
			return other.contains(where: { _ in true })
		}
		if let match = other._customContainsEquatableElement(first) {
			// Fast path: the sequence has fast containment checks.
			guard match else { return false }
			while let item = it.next() {
				guard other.contains(item) else { return false }
			}
			return !other.allSatisfy { self.contains($0) }
		}

		return _UnsafeBitset.withTemporaryBitset(capacity: count) { seen in
			// Mark elements in `self` that we've seen in `other`.
			var isKnownStrict = false
			for item in other {
				if let index = _find(item).index {
					if seen.insert(index), seen.count == self.count, isKnownStrict {
						// We've seen enough.
						return true
					}
				} else {
					if !isKnownStrict, seen.count == self.count { return true }
					isKnownStrict = true
				}
			}
			return false
		}
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public func isStrictSuperset(of other: DevicesCore.OrderedSet<Element>) -> Swift.Bool {
		self.count > other.count && other.isSubset(of: self)
	}
  @inlinable @inline(__always) public func isStrictSuperset(of other: DevicesCore.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
		isStrictSuperset(of: other._base)
	}
  @inlinable public func isStrictSuperset(of other: Swift.Set<Element>) -> Swift.Bool {
		self.count > other.count && other.isSubset(of: self)
	}
  @inlinable public func isStrictSuperset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
		if S.self == Self.self {
			return self.isStrictSuperset(of: other as! Self)
		}
		if S.self == Set<Element>.self {
			return self.isStrictSuperset(of: other as! Set<Element>)
		}

		var it = self.makeIterator()
		guard let first = it.next() else { return false }
		if let match = other._customContainsEquatableElement(first) {
			// Fast path: the sequence has fast containment checks.
			guard other.allSatisfy({ self.contains($0) }) else { return false }
			guard match else { return true }
			while let item = it.next() {
				guard other.contains(item) else { return true }
			}
			return false
		}

		return _UnsafeBitset.withTemporaryBitset(capacity: count) { seen in
			// Mark elements in `self` that we've seen in `other`.
			for item in other {
				guard let index = _find(item).index else {
					return false
				}
				if seen.insert(index), seen.count == self.count {
					// We've seen enough.
					return false
				}
			}
			return seen.count < self.count
		}
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public func isSubset(of other: DevicesCore.OrderedSet<Element>) -> Swift.Bool {
		guard other.count >= self.count else { return false }
		for item in self {
			guard other.contains(item) else { return false }
		}
		return true
	}
  @inlinable @inline(__always) public func isSubset(of other: DevicesCore.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
		isSubset(of: other._base)
	}
  @inlinable public func isSubset(of other: Swift.Set<Element>) -> Swift.Bool {
		guard other.count >= self.count else { return false }
		for item in self {
			guard other.contains(item) else { return false }
		}
		return true
	}
  @inlinable public func isSubset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
		guard !isEmpty else { return true }

		if S.self == Self.self {
			return isSubset(of: other as! Self)
		}

		var it = self.makeIterator()
		let first = it.next()!
		if let match = other._customContainsEquatableElement(first) {
			// Fast path: the sequence has fast containment checks.
			guard match else { return false }
			while let item = it.next() {
				guard other.contains(item) else { return false }
			}
			return true
		}

		return _UnsafeBitset.withTemporaryBitset(capacity: count) { seen in
			// Mark elements in `self` that we've seen in `other`.
			for item in other {
				if let index = _find(item).index {
					if seen.insert(index), seen.count == self.count {
						// We've seen enough.
						return true
					}
				}
			}
			return false
		}
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public func isSuperset(of other: DevicesCore.OrderedSet<Element>) -> Swift.Bool {
		other.isSubset(of: self)
	}
  @inlinable public func isSuperset(of other: DevicesCore.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
		isSuperset(of: other._base)
	}
  @inlinable public func isSuperset(of other: Swift.Set<Element>) -> Swift.Bool {
		guard self.count >= other.count else { return false }
		return _isSuperset(of: other)
	}
  @inlinable public func isSuperset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
		_isSuperset(of: other)
	}
  @inlinable internal func _isSuperset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
		if S.self == Self.self {
			return self.isSuperset(of: other as! Self)
		}
		for item in other {
			guard self.contains(item) else { return false }
		}
		return true
	}
}
extension DevicesCore.OrderedSet {
  @inlinable @inline(__always) public mutating func subtract(_ other: DevicesCore.OrderedSet<Element>) {
		self = subtracting(other)
	}
  @inlinable @inline(__always) public mutating func subtract(_ other: DevicesCore.OrderedSet<Element>.UnorderedView) {
		subtract(other._base)
	}
  @inlinable @inline(__always) public mutating func subtract<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
		self = _subtracting(other)
	}
}
extension DevicesCore.OrderedSet {
  @inlinable @inline(__always) public __consuming func subtracting(_ other: DevicesCore.OrderedSet<Element>) -> DevicesCore.OrderedSet<Element> {
		_subtracting(other)
	}
  @inlinable @inline(__always) public __consuming func subtracting(_ other: DevicesCore.OrderedSet<Element>.UnorderedView) -> DevicesCore.OrderedSet<Element> {
		subtracting(other._base)
	}
  @inlinable @inline(__always) public __consuming func subtracting<S>(_ other: S) -> DevicesCore.OrderedSet<Element> where Element == S.Element, S : Swift.Sequence {
		_subtracting(other)
	}
  @inlinable internal __consuming func _subtracting<S>(_ other: S) -> DevicesCore.OrderedSet<Element> where Element == S.Element, S : Swift.Sequence {
		guard count > 0 else { return Self() }
		return _UnsafeBitset.withTemporaryBitset(capacity: count) { difference in
			difference.insertAll(upTo: count)
			for item in other {
				if let index = self._find(item).index {
					if difference.remove(index), difference.isEmpty {
						return Self()
					}
				}
			}
			assert(!difference.isEmpty)
			let result = _extractSubset(using: difference)
			result._checkInvariants()
			return result
		}
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public __consuming func symmetricDifference(_ other: __owned DevicesCore.OrderedSet<Element>) -> DevicesCore.OrderedSet<Element> {
		_UnsafeBitset.withTemporaryBitset(capacity: self.count) { bitset1 in
			_UnsafeBitset.withTemporaryBitset(capacity: other.count) { bitset2 in
				bitset1.insertAll(upTo: self.count)
				for item in other {
					if let index = self._find(item).index {
						bitset1.remove(index)
					}
				}
				bitset2.insertAll(upTo: other.count)
				for item in self {
					if let index = other._find(item).index {
						bitset2.remove(index)
					}
				}
				var result = self._extractSubset(
					using: bitset1,
					extraCapacity: bitset2.count
				)
				for offset in bitset2 {
					result._appendNew(other._elements[offset])
				}
				result._checkInvariants()
				return result
			}
		}
	}
  @inlinable @inline(__always) public __consuming func symmetricDifference(_ other: __owned DevicesCore.OrderedSet<Element>.UnorderedView) -> DevicesCore.OrderedSet<Element> {
		symmetricDifference(other._base)
	}
  @inlinable public __consuming func symmetricDifference<S>(_ other: __owned S) -> DevicesCore.OrderedSet<Element> where Element == S.Element, S : Swift.Sequence {
		_UnsafeBitset.withTemporaryBitset(capacity: self.count) { bitset in
			var new = Self()
			bitset.insertAll(upTo: self.count)
			for item in other {
				if let index = self._find(item).index {
					bitset.remove(index)
				} else {
					new.append(item)
				}
			}
			var result = _extractSubset(using: bitset, extraCapacity: new.count)
			for item in new._elements {
				result._appendNew(item)
			}
			result._checkInvariants()
			return result
		}
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public __consuming func union(_ other: __owned DevicesCore.OrderedSet<Element>) -> DevicesCore.OrderedSet<Element> {
		var result = self
		result.formUnion(other)
		return result
	}
  @inlinable @inline(__always) public __consuming func union(_ other: __owned DevicesCore.OrderedSet<Element>.UnorderedView) -> DevicesCore.OrderedSet<Element> {
		union(other._base)
	}
  @inlinable public __consuming func union<S>(_ other: __owned S) -> DevicesCore.OrderedSet<Element> where Element == S.Element, S : Swift.Sequence {
		var result = self
		result.formUnion(other)
		return result
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public init() {
		__storage = nil
		_elements = []
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public func contains(_ element: Element) -> Swift.Bool {
		_find_inlined(element).index != nil
	}
}
extension DevicesCore.OrderedSet {
  @discardableResult
  @inlinable public mutating func remove(_ member: Element) -> Element? {
		let (idx, bucket) = _find(member)
		guard let index = idx else { return nil }
		return _removeExistingMember(at: index, in: bucket)
	}
}
extension DevicesCore.OrderedSet : Swift.Sequence {
  public typealias Iterator = Swift.IndexingIterator<DevicesCore.OrderedSet<Element>>
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
		_find(element).index != nil
	}
  @inlinable public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
		_elements._copyToContiguousArray()
	}
  @inlinable public __consuming func _copyContents(initializing ptr: Swift.UnsafeMutableBufferPointer<Element>) -> (DevicesCore.OrderedSet<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {
		guard !isEmpty else { return (makeIterator(), 0) }
		let copied: Int = _elements.withUnsafeBufferPointer { buffer in
			guard let p = ptr.baseAddress else {
				preconditionFailure("Attempt to copy contents into nil buffer pointer")
			}
			let c = Swift.min(buffer.count, ptr.count)
			p.initialize(from: buffer.baseAddress!, count: c)
			return c
		}
		return (Iterator(_elements: self, _position: copied), copied)
	}
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
		try _elements.withContiguousStorageIfAvailable(body)
	}
}
extension DevicesCore.OrderedSet : Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable @inline(__always) public var startIndex: Swift.Int {
    get { _elements.startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Int {
    get { _elements.endIndex }
  }
  @inlinable @inline(__always) public var indices: DevicesCore.OrderedSet<Element>.Indices {
    get { _elements.indices }
  }
  @inlinable @inline(__always) public func index(after i: Swift.Int) -> Swift.Int { i + 1 }
  @inlinable @inline(__always) public func index(before i: Swift.Int) -> Swift.Int { i - 1 }
  @inlinable @inline(__always) public func formIndex(after i: inout Swift.Int) { i += 1 }
  @inlinable @inline(__always) public func formIndex(before i: inout Swift.Int) { i -= 1 }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
		i + distance
	}
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
		_elements.index(i, offsetBy: distance, limitedBy: limit)
	}
  @inlinable @inline(__always) public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
		end - start
	}
  @inlinable @inline(__always) public subscript(position: Swift.Int) -> Element {
    get {
		_elements[position]
	}
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> DevicesCore.OrderedSet<Element>.SubSequence {
    get {
		_failEarlyRangeCheck(bounds, bounds: startIndex ..< endIndex)
		return SubSequence(_base: self, bounds: bounds)
	}
  }
  @inlinable @inline(__always) public var isEmpty: Swift.Bool {
    get { _elements.isEmpty }
  }
  @inlinable @inline(__always) public var count: Swift.Int {
    get { _elements.count }
  }
  @inlinable public func _customIndexOfEquatableElement(_ element: Element) -> Swift.Int?? {
		guard let table = _table else {
			return _elements._customIndexOfEquatableElement(element)
		}
		return table.read { hashTable in
			let (o, _) = hashTable._find(element, in: _elements)
			guard let offset = o else { return .some(nil) }
			return offset
		}
	}
  @inlinable @inline(__always) public func _customLastIndexOfEquatableElement(_ element: Element) -> Swift.Int?? {
		// OrderedSet holds unique elements.
		_customIndexOfEquatableElement(element)
	}
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
		_elements._failEarlyRangeCheck(index, bounds: bounds)
	}
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.ClosedRange<Swift.Int>) {
		_elements._failEarlyRangeCheck(index, bounds: bounds)
	}
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
		_elements._failEarlyRangeCheck(range, bounds: bounds)
	}
}
extension DevicesCore.OrderedSet : DevicesCore._UniqueCollection {
}
extension DevicesCore.OrderedSet {
  @inlinable public init(minimumCapacity: Swift.Int, persistent: Swift.Bool = false) {
		self.init()
		self._reserveCapacity(minimumCapacity, persistent: persistent)
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
		self._reserveCapacity(minimumCapacity, persistent: false)
	}
}
extension DevicesCore.OrderedSet {
  @inlinable internal mutating func _reserveCapacity(_ minimumCapacity: Swift.Int, persistent: Swift.Bool) {
		precondition(minimumCapacity >= 0, "Minimum capacity cannot be negative")
		defer { _checkInvariants() }

		_elements.reserveCapacity(minimumCapacity)

		let currentScale = _scale
		let newScale = _HashTable.scale(forCapacity: minimumCapacity)

		let reservedScale = persistent ? newScale : _reservedScale

		if currentScale < newScale {
			// Grow the table.
			_regenerateHashTable(scale: newScale, reservedScale: reservedScale)
			return
		}

		let requiredScale = _HashTable.scale(forCapacity: self.count)
		let minScale = Swift.max(Swift.max(newScale, reservedScale), requiredScale)
		if minScale < currentScale {
			// Shrink the table.
			_regenerateHashTable(scale: minScale, reservedScale: reservedScale)
			return
		}

		// When we have the right size table, ensure it's unique and it has the
		// right persisted reservation.
		_ensureUnique()
		if _reservedScale != reservedScale {
			// Remember reserved scale.
			__storage!.header.reservedScale = reservedScale
		}
	}
}
extension DevicesCore.OrderedSet : @unchecked Swift.Sendable where Element : Swift.Sendable {
}
extension DevicesCore.OrderedSet {
  @frozen public struct SubSequence {
    @usableFromInline
    internal var _base: DevicesCore.OrderedSet<Element>
    @usableFromInline
    internal var _bounds: Swift.Range<Swift.Int>
    @inlinable @inline(__always) internal init(_base: DevicesCore.OrderedSet<Element>, bounds: Swift.Range<Swift.Int>) {
			self._base = _base
			self._bounds = bounds
		}
  }
}
extension DevicesCore.OrderedSet.SubSequence : Swift.Sendable where Element : Swift.Sendable {
}
extension DevicesCore.OrderedSet.SubSequence {
  @inlinable internal var _slice: Swift.Array<Element>.SubSequence {
    get {
		_base._elements[_bounds]
	}
  }
  @inlinable internal func _index(of element: Element) -> Swift.Int? {
		guard let index = _base._find(element).index else { return nil }
		guard _bounds.contains(index) else { return nil }
		return index
	}
}
extension DevicesCore.OrderedSet.SubSequence : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension DevicesCore.OrderedSet.SubSequence : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension DevicesCore.OrderedSet.SubSequence : Swift.Sequence {
  public typealias Element = DevicesCore.OrderedSet<Element>.Element
  public typealias Iterator = Swift.IndexingIterator<DevicesCore.OrderedSet<Element>.SubSequence>
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
		_index(of: element) != nil
	}
  @inlinable public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
		_slice._copyToContiguousArray()
	}
  @inlinable public __consuming func _copyContents(initializing ptr: Swift.UnsafeMutableBufferPointer<Element>) -> (DevicesCore.OrderedSet<Element>.SubSequence.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {
		guard !isEmpty else { return (makeIterator(), 0) }
		let copied: Int = _slice.withUnsafeBufferPointer { buffer in
			guard let p = ptr.baseAddress else {
				preconditionFailure("Attempt to copy contents into nil buffer pointer")
			}
			let c = Swift.min(buffer.count, ptr.count)
			if c > 0 {
				p.initialize(from: buffer.baseAddress!, count: c)
			}
			return c
		}
		return (
			Iterator(_elements: self, _position: _bounds.lowerBound + copied),
			copied
		)
	}
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
		try _slice.withContiguousStorageIfAvailable(body)
	}
}
extension DevicesCore.OrderedSet.SubSequence : DevicesCore._UniqueCollection {
}
extension DevicesCore.OrderedSet.SubSequence : Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Array<Element>.SubSequence.Indices
  public typealias SubSequence = DevicesCore.OrderedSet<Element>.SubSequence
  @inlinable @inline(__always) public var startIndex: Swift.Int {
    get { _bounds.lowerBound }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Int {
    get { _bounds.upperBound }
  }
  @inlinable @inline(__always) public var indices: DevicesCore.OrderedSet<Element>.SubSequence.Indices {
    get { _slice.indices }
  }
  @inlinable @inline(__always) public func index(after i: Swift.Int) -> Swift.Int { i + 1 }
  @inlinable @inline(__always) public func index(before i: Swift.Int) -> Swift.Int { i - 1 }
  @inlinable @inline(__always) public func formIndex(after i: inout Swift.Int) { i += 1 }
  @inlinable @inline(__always) public func formIndex(before i: inout Swift.Int) { i -= 1 }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
		i + distance
	}
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
		_slice.index(i, offsetBy: distance, limitedBy: limit)
	}
  @inlinable @inline(__always) public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
		end - start
	}
  @inlinable @inline(__always) public subscript(position: Swift.Int) -> Element {
    get {
		_slice[position]
	}
  }
  @inlinable @inline(__always) public subscript(bounds: Swift.Range<Swift.Int>) -> DevicesCore.OrderedSet<Element>.SubSequence.SubSequence {
    get {
		_failEarlyRangeCheck(bounds, bounds: startIndex ..< endIndex)
		return SubSequence(_base: _base, bounds: bounds)
	}
  }
  @inlinable @inline(__always) public var isEmpty: Swift.Bool {
    get { _bounds.isEmpty }
  }
  @inlinable @inline(__always) public var count: Swift.Int {
    get { _bounds.count }
  }
  @inlinable @inline(__always) public func _customIndexOfEquatableElement(_ element: Element) -> Swift.Int?? {
		.some(_index(of: element))
	}
  @inlinable @inline(__always) public func _customLastIndexOfEquatableElement(_ element: Element) -> Swift.Int?? {
		.some(_index(of: element))
	}
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
		_slice._failEarlyRangeCheck(index, bounds: bounds)
	}
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.ClosedRange<Swift.Int>) {
		_slice._failEarlyRangeCheck(index, bounds: bounds)
	}
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
		_slice._failEarlyRangeCheck(range, bounds: bounds)
	}
}
extension DevicesCore.OrderedSet.SubSequence : Swift.Equatable {
  @inlinable public static func == (left: DevicesCore.OrderedSet<Element>.SubSequence, right: DevicesCore.OrderedSet<Element>.SubSequence) -> Swift.Bool {
		left.elementsEqual(right)
	}
}
extension DevicesCore.OrderedSet.SubSequence : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
		hasher.combine(count)
		for item in self {
			hasher.combine(item)
		}
	}
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesCore.OrderedSet {
  @frozen public struct UnorderedView {
    @usableFromInline
    internal var _base: DevicesCore.OrderedSet<Element>
    @inlinable @inline(__always) internal init(_base: DevicesCore.OrderedSet<Element>) {
			self._base = _base
		}
  }
  @inlinable @inline(__always) public init(_ view: DevicesCore.OrderedSet<Element>.UnorderedView) {
		self = view._base
	}
  @inlinable public var unordered: DevicesCore.OrderedSet<Element>.UnorderedView {
    @inline(__always) get {
			UnorderedView(_base: self)
		}
    @inline(__always) _modify {
			var view = UnorderedView(_base: self)
			self = OrderedSet()
			defer { self = view._base }
			yield &view
		}
  }
}
extension DevicesCore.OrderedSet.UnorderedView : Swift.Sendable where Element : Swift.Sendable {
}
extension DevicesCore.OrderedSet.UnorderedView : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension DevicesCore.OrderedSet.UnorderedView : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension DevicesCore.OrderedSet.UnorderedView : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension DevicesCore.OrderedSet.UnorderedView : Swift.Equatable {
  @inlinable public static func == (left: DevicesCore.OrderedSet<Element>.UnorderedView, right: DevicesCore.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
		if left._base.__storage != nil,
		   left._base.__storage === right._base.__storage
		{
			return true
		}
		guard left._base.count == right._base.count else { return false }

		for item in left._base {
			if !right._base.contains(item) { return false }
		}
		return true
	}
}
extension DevicesCore.OrderedSet.UnorderedView : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
		// Generate a seed from a snapshot of the hasher.  This makes members' hash
		// values depend on the state of the hasher, which improves hashing
		// quality. (E.g., it makes it possible to resolve collisions by passing in
		// a different hasher.)
		let copy = hasher
		let seed = copy.finalize()

		var hash = 0
		for member in _base {
			hash ^= member._rawHashValue(seed: seed)
		}
		hasher.combine(hash)
	}
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesCore.OrderedSet.UnorderedView : Swift.ExpressibleByArrayLiteral {
  @inlinable @inline(__always) public init(arrayLiteral elements: Element...) {
		_base = OrderedSet(elements)
	}
  public typealias ArrayLiteralElement = Element
}
extension DevicesCore.OrderedSet.UnorderedView : Swift.SetAlgebra {
  public typealias Element = DevicesCore.OrderedSet<Element>.Element
}
extension DevicesCore.OrderedSet.UnorderedView {
  @inlinable @inline(__always) public init() {
		_base = OrderedSet()
	}
  @inlinable @inline(__always) public init<S>(_ elements: S) where Element == S.Element, S : Swift.Sequence {
		_base = OrderedSet(elements)
	}
  @inlinable @inline(__always) public init(_ elements: DevicesCore.OrderedSet<Element>.UnorderedView) {
		self = elements
	}
  @inlinable @inline(__always) public init(_ elements: Swift.Set<Element>) {
		self._base = OrderedSet(elements)
	}
  @inlinable @inline(__always) public init<Value>(_ elements: Swift.Dictionary<Element, Value>.Keys) {
		self._base = OrderedSet(elements)
	}
}
extension DevicesCore.OrderedSet.UnorderedView {
  @inlinable @inline(__always) public func contains(_ element: Element) -> Swift.Bool {
		_base.contains(element)
	}
}
extension DevicesCore.OrderedSet.UnorderedView {
  @inlinable public mutating func insert(_ newMember: __owned Element) -> (inserted: Swift.Bool, memberAfterInsert: Element) {
		let (inserted, index) = _base.append(newMember)
		return (inserted, _base[index])
	}
  @inlinable public mutating func update(with newMember: __owned Element) -> Element? {
		let (inserted, index) = _base.append(newMember)
		if inserted { return nil }
		let old = _base._elements[index]
		_base._elements[index] = newMember
		return old
	}
}
extension DevicesCore.OrderedSet.UnorderedView {
  @discardableResult
  @inlinable @inline(__always) public mutating func remove(_ member: Element) -> Element? {
		_base.remove(member)
	}
}
extension DevicesCore.OrderedSet.UnorderedView {
  @inlinable @inline(__always) public mutating func formUnion(_ other: __owned DevicesCore.OrderedSet<Element>.UnorderedView) {
		_base.formUnion(other._base)
	}
  @inlinable public __consuming func union(_ other: __owned DevicesCore.OrderedSet<Element>.UnorderedView) -> DevicesCore.OrderedSet<Element>.UnorderedView {
		_base.union(other._base).unordered
	}
  @inlinable public mutating func formUnion<S>(_ other: __owned S) where Element == S.Element, S : Swift.Sequence {
		_base.formUnion(other)
	}
  @inlinable public __consuming func union<S>(_ other: __owned S) -> DevicesCore.OrderedSet<Element>.UnorderedView where Element == S.Element, S : Swift.Sequence {
		_base.union(other).unordered
	}
}
extension DevicesCore.OrderedSet.UnorderedView {
  @inlinable public __consuming func intersection(_ other: DevicesCore.OrderedSet<Element>.UnorderedView) -> DevicesCore.OrderedSet<Element>.UnorderedView {
		_base.intersection(other._base).unordered
	}
  @inlinable public mutating func formIntersection(_ other: DevicesCore.OrderedSet<Element>.UnorderedView) {
		_base.formIntersection(other._base)
	}
  @inlinable public __consuming func intersection<S>(_ other: S) -> DevicesCore.OrderedSet<Element>.UnorderedView where Element == S.Element, S : Swift.Sequence {
		_base.intersection(other).unordered
	}
  @inlinable public mutating func formIntersection<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
		_base.formIntersection(other)
	}
}
extension DevicesCore.OrderedSet.UnorderedView {
  @inlinable public __consuming func symmetricDifference(_ other: __owned DevicesCore.OrderedSet<Element>.UnorderedView) -> DevicesCore.OrderedSet<Element>.UnorderedView {
		_base.symmetricDifference(other._base).unordered
	}
  @inlinable public mutating func formSymmetricDifference(_ other: __owned DevicesCore.OrderedSet<Element>.UnorderedView) {
		_base.formSymmetricDifference(other._base)
	}
  @inlinable public __consuming func symmetricDifference<S>(_ other: __owned S) -> DevicesCore.OrderedSet<Element>.UnorderedView where Element == S.Element, S : Swift.Sequence {
		_base.symmetricDifference(other).unordered
	}
  @inlinable public mutating func formSymmetricDifference<S>(_ other: __owned S) where Element == S.Element, S : Swift.Sequence {
		_base.formSymmetricDifference(other)
	}
}
extension DevicesCore.OrderedSet.UnorderedView {
  @inlinable public __consuming func subtracting(_ other: DevicesCore.OrderedSet<Element>.UnorderedView) -> DevicesCore.OrderedSet<Element>.UnorderedView {
		_base.subtracting(other._base).unordered
	}
  @inlinable public mutating func subtract(_ other: DevicesCore.OrderedSet<Element>.UnorderedView) {
		_base.subtract(other._base)
	}
  @inlinable public __consuming func subtracting<S>(_ other: S) -> DevicesCore.OrderedSet<Element>.UnorderedView where Element == S.Element, S : Swift.Sequence {
		_base.subtracting(other).unordered
	}
  @inlinable public mutating func subtract<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
		_base.subtract(other)
	}
}
extension DevicesCore.OrderedSet.UnorderedView {
  @inlinable public func isSubset(of other: DevicesCore.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
		_base.isSubset(of: other._base)
	}
  @inlinable public func isSubset(of other: Swift.Set<Element>) -> Swift.Bool {
		_base.isSubset(of: other)
	}
  @inlinable public func isSubset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
		_base.isSubset(of: other)
	}
}
extension DevicesCore.OrderedSet.UnorderedView {
  @inlinable public func isSuperset(of other: DevicesCore.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
		_base.isSuperset(of: other._base)
	}
  @inlinable public func isSuperset(of other: Swift.Set<Element>) -> Swift.Bool {
		_base.isSuperset(of: other)
	}
  @inlinable public func isSuperset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
		_base.isSuperset(of: other)
	}
}
extension DevicesCore.OrderedSet.UnorderedView {
  @inlinable public func isStrictSubset(of other: DevicesCore.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
		_base.isStrictSubset(of: other._base)
	}
  @inlinable public func isStrictSubset(of other: Swift.Set<Element>) -> Swift.Bool {
		_base.isStrictSubset(of: other)
	}
  @inlinable public func isStrictSubset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
		_base.isStrictSubset(of: other)
	}
}
extension DevicesCore.OrderedSet.UnorderedView {
  @inlinable public func isStrictSuperset(of other: DevicesCore.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
		_base.isStrictSuperset(of: other._base)
	}
  @inlinable public func isStrictSuperset(of other: Swift.Set<Element>) -> Swift.Bool {
		_base.isStrictSuperset(of: other)
	}
  @inlinable public func isStrictSuperset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
		_base.isStrictSuperset(of: other)
	}
}
extension DevicesCore.OrderedSet.UnorderedView {
  @inlinable public func isDisjoint(with other: DevicesCore.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
		_base.isDisjoint(with: other._base)
	}
  @inlinable public func isDisjoint(with other: Swift.Set<Element>) -> Swift.Bool {
		_base.isDisjoint(with: other)
	}
  @inlinable public func isDisjoint<S>(with other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
		_base.isDisjoint(with: other)
	}
}
extension DevicesCore.OrderedSet {
  @frozen public struct _UnstableInternals {
    @usableFromInline
    internal typealias _Bucket = DevicesCore._HashTable.Bucket
    @usableFromInline
    internal var base: DevicesCore.OrderedSet<Element>
    @inlinable internal init(_ base: DevicesCore.OrderedSet<Element>) {
			self.base = base
		}
  }
  @inlinable public var __unstable: DevicesCore.OrderedSet<Element>._UnstableInternals {
    @inline(__always) get {
			_UnstableInternals(self)
		}
    @inline(__always) _modify {
			var view = _UnstableInternals(self)
			self = OrderedSet()
			defer { self = view.base }
			yield &view
		}
  }
}
extension DevicesCore.OrderedSet._UnstableInternals : Swift.Sendable where Element : Swift.Sendable {
}
@frozen public struct OrderedSet<Element> where Element : Swift.Hashable {
  @usableFromInline
  internal typealias _Bucket = DevicesCore._HashTable.Bucket
  @usableFromInline
  internal var __storage: DevicesCore._HashTable.Storage?
  @usableFromInline
  internal var _elements: Swift.ContiguousArray<Element>
  @inlinable internal init(_uniqueElements: Swift.ContiguousArray<Element>, _ table: DevicesCore._HashTable?) {
		self.__storage = table?._storage
		self._elements = _uniqueElements
	}
  @inlinable @inline(__always) internal var _table: DevicesCore._HashTable? {
    get { __storage.map { _HashTable($0) } }
    set { __storage = newValue?._storage }
  }
}
extension DevicesCore.OrderedSet {
  @inlinable public var elements: [Element] {
    get {
			Array(_elements)
		}
    set {
			self = .init(newValue)
		}
    @inline(__always) _modify {
			var members = Array(_elements)
			_elements = []
			defer { self = .init(members) }
			yield &members
		}
  }
}
extension DevicesCore.OrderedSet {
  @inlinable internal var _capacity: Swift.Int {
    get {
		_table?.capacity ?? _HashTable.maximumUnhashedCount
	}
  }
  @inlinable internal var _minimumCapacity: Swift.Int {
    get {
		if _scale == _reservedScale { return 0 }
		return _HashTable.minimumCapacity(forScale: _scale)
	}
  }
  @inlinable internal var _scale: Swift.Int {
    get {
		_table?.scale ?? 0
	}
  }
  @inlinable internal var _reservedScale: Swift.Int {
    get {
		_table?.reservedScale ?? 0
	}
  }
  @inlinable internal var _bias: Swift.Int {
    get {
		_table?.bias ?? 0
	}
  }
}
extension DevicesCore.OrderedSet {
  @inlinable internal mutating func _regenerateHashTable(scale: Swift.Int, reservedScale: Swift.Int) {
		assert(_HashTable.maximumCapacity(forScale: scale) >= _elements.count)
		assert(reservedScale == 0 || reservedScale >= _HashTable.minimumScale)
		_table = _HashTable.create(
			uncheckedUniqueElements: _elements,
			scale: Swift.max(scale, reservedScale),
			reservedScale: reservedScale
		)
	}
  @inlinable internal mutating func _regenerateHashTable() {
		let reservedScale = _reservedScale
		guard
			_elements.count > _HashTable.maximumUnhashedCount || reservedScale != 0
		else {
			// We have too few elements; disable hashing.
			_table = nil
			return
		}
		let scale = _HashTable.scale(forCapacity: _elements.count)
		_regenerateHashTable(scale: scale, reservedScale: reservedScale)
	}
  @inlinable internal mutating func _regenerateExistingHashTable() {
		assert(_capacity >= _elements.count)
		guard _table != nil else {
			return
		}
		_ensureUnique()
		_table!.update { hashTable in
			hashTable.clear()
			hashTable.fill(uncheckedUniqueElements: _elements)
		}
	}
}
extension DevicesCore.OrderedSet {
  @inlinable @inline(__always) internal mutating func _isUnique() -> Swift.Bool {
		isKnownUniquelyReferenced(&__storage)
	}
  @inlinable internal mutating func _ensureUnique() {
		if __storage == nil { return }
		if isKnownUniquelyReferenced(&__storage) { return }
		_table = _table!.copy()
	}
}
extension DevicesCore.OrderedSet {
  @inlinable internal func _find(_ item: Element) -> (index: Swift.Int?, bucket: DevicesCore.OrderedSet<Element>._Bucket) {
		_find_inlined(item)
	}
  @inlinable @inline(__always) internal func _find_inlined(_ item: Element) -> (index: Swift.Int?, bucket: DevicesCore.OrderedSet<Element>._Bucket) {
		_elements.withUnsafeBufferPointer { elements in
			guard let table = _table else {
				return (elements.firstIndex(of: item), _Bucket(offset: 0))
			}
			return table.read { hashTable in
				hashTable._find(item, in: elements)
			}
		}
	}
  @inlinable internal func _bucket(for index: Swift.Int) -> DevicesCore.OrderedSet<Element>._Bucket {
		guard let table = _table else { return _Bucket(offset: 0) }
		return table.read { hashTable in
			var it = hashTable.bucketIterator(for: _elements[index])
			it.advance(until: index)
			precondition(it.isOccupied, "Corrupt hash table")
			return it.currentBucket
		}
	}
  @inlinable @inline(__always) public func firstIndex(of element: Element) -> Swift.Int? {
		_find(element).index
	}
  @inlinable @inline(__always) public func lastIndex(of element: Element) -> Swift.Int? {
		_find(element).index
	}
}
extension DevicesCore.OrderedSet {
  @inlinable @inline(never) internal __consuming func _extractSubset(using bitset: DevicesCore._UnsafeBitset, extraCapacity: Swift.Int = 0) -> DevicesCore.OrderedSet<Element> {
		assert(bitset.isEmpty || bitset.max()! <= count)
		if bitset.isEmpty { return Self(minimumCapacity: extraCapacity) }
		if bitset.count == self.count {
			if extraCapacity <= self._capacity - self.count {
				return self
			}
			var copy = self
			copy.reserveCapacity(count + extraCapacity)
			return copy
		}
		var result = Self(minimumCapacity: bitset.count + extraCapacity)
		for offset in bitset {
			result._appendNew(_elements[offset])
		}
		assert(result.count == bitset.count)
		return result
	}
}
extension DevicesCore.OrderedSet {
  @discardableResult
  @inlinable internal mutating func _removeExistingMember(at index: Swift.Int, in bucket: DevicesCore.OrderedSet<Element>._Bucket) -> Element {
		guard _elements.count - 1 >= _minimumCapacity else {
			let old = _elements.remove(at: index)
			_regenerateHashTable()
			return old
		}
		guard _table != nil else {
			return _elements.remove(at: index)
		}

		defer { _checkInvariants() }
		_ensureUnique()
		_table!.update { hashTable in
			// Delete the entry for the removed member.
			hashTable.delete(
				bucket: bucket,
				hashValueGenerator: { offset, seed in
					_elements[offset]._rawHashValue(seed: seed)
				}
			)
			hashTable.adjustContents(preparingForRemovalOf: index, in: _elements)
		}
		return _elements.remove(at: index)
	}
}
extension DevicesCore.OrderedSet {
  @inlinable public func filter(_ isIncluded: (Element) throws -> Swift.Bool) rethrows -> DevicesCore.OrderedSet<Element> {
		try _UnsafeBitset.withTemporaryBitset(capacity: self.count) { bitset in
			for i in _elements.indices where try isIncluded(_elements[i]) {
				bitset.insert(i)
			}
			let result = self._extractSubset(using: bitset)
			result._checkInvariants()
			return result
		}
	}
}
public protocol PHImageManagerTwin {
  @discardableResult
  func requestImage(for asset: Photos.PHAsset, targetSize: CoreFoundation.CGSize, contentMode: Photos.PHImageContentMode, options: Photos.PHImageRequestOptions?, resultHandler: @escaping (UIKit.UIImage?, [Swift.AnyHashable : Any]?) -> Swift.Void) -> Photos.PHImageRequestID
  @discardableResult
  func requestAVAsset(forVideo asset: Photos.PHAsset, options: Photos.PHVideoRequestOptions?, resultHandler: @escaping (AVFoundation.AVAsset?, AVFoundation.AVAudioMix?, [Swift.AnyHashable : Any]?) -> Swift.Void) -> Photos.PHImageRequestID
  @discardableResult
  func requestImageData(for asset: Photos.PHAsset, options: Photos.PHImageRequestOptions?, resultHandler: @escaping (Foundation.Data?, Swift.String?, UIKit.UIImage.Orientation, [Swift.AnyHashable : Any]?) -> Swift.Void) -> Photos.PHImageRequestID
  func cancelImageRequest(_ requestID: Photos.PHImageRequestID)
}
extension Photos.PHImageManager : DevicesCore.PHImageManagerTwin {
}
public protocol PKPushRegistryTwin {
  var delegate: PushKit.PKPushRegistryDelegate? { get nonmutating set }
  var desiredPushTypes: Swift.Set<PushKit.PKPushType>? { get nonmutating set }
}
extension PushKit.PKPushRegistry : DevicesCore.PKPushRegistryTwin {
}
final public class PassThroughChallengeReceiver : DevicesCore.SecurityChallengeReceiver {
  public init()
  final public func receiveChallenge(_: Foundation.URLAuthenticationChallenge, task _: DevicesCore.NetworkTask?, completion: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc deinit
}
final public class PassthroughRelay<Output> : DevicesCore.Relay {
  public typealias Failure = Swift.Never
  public init()
  final public func send(_ value: Output)
  final public func subscribe<P>(_ publisher: P) -> DevicesCore.AnyCancellable where Output == P.Output, P : Combine.Publisher, P.Failure == Swift.Never
  final public func receive<S>(subscriber: S) where Output == S.Input, S : Combine.Subscriber, S.Failure == Swift.Never
  @objc deinit
}
public protocol Pasteboard {
  var onTextCopy: DevicesCore.Signal<Swift.String> { get }
  func copyToClipboard(_ text: Swift.String)
}
final public class PasteboardImpl : DevicesCore.Pasteboard {
  final public var onTextCopy: DevicesCore.Signal<Swift.String> {
    get
  }
  public init()
  final public func copyToClipboard(_ text: Swift.String)
  @objc deinit
}
final public class PathAndQueryRequestModifier {
  public init(path: Swift.String?, queryItems: [Swift.String : Swift.String]?)
  final public func modify(_ request: Foundation.URLRequest) -> Swift.Result<Foundation.URLRequest, Swift.Error>
  @objc deinit
}
public protocol Pausable : AnyObject {
  func pause()
  func resume()
}
public struct Permission : DevicesCore.Serializable, Swift.Equatable {
  public enum Kind : Swift.String {
    case recordAudio
    case location
    case readContacts
    case push
    case appTracking
    case localNetwork
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Status : Swift.String {
    case granted
    case deniedOnce
    case deniedPermanently
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let type: DevicesCore.Permission.Kind
  public let status: DevicesCore.Permission.Status
  public init(type: DevicesCore.Permission.Kind, status: DevicesCore.Permission.Status)
  public func toJSONDictionary() -> DevicesCore.JSONDictionary
  public static func == (a: DevicesCore.Permission, b: DevicesCore.Permission) -> Swift.Bool
}
public protocol PermissionProvider : DevicesCore.AuthorizationProvider {
  var permission: DevicesCore.Permission { get }
}
extension DevicesCore.PersistentCache {
  final public func asMutableProperty(key: Key) -> DevicesCore.MutableProperty<Value?>
}
final public class PersistentCache<Key, Value> where Key : Swift.Decodable, Key : Swift.Encodable, Key : Swift.Hashable, Value : Swift.Decodable, Value : Swift.Encodable {
  final public var cacheWasDownload: Swift.Bool
  public init(cache: DevicesCore.Cache<Key, Value>, cacheDirectory: Swift.String, cacheName: Swift.String, applicationState: DevicesCore.Property<DevicesCore.ApplicationState>, assertionCaller: DevicesCore.AssertionCaller, logger: DevicesCore.Logger?, fileManager: DevicesCore.FileManagerTwin = FileManager.default, dataLoader: @escaping (Foundation.URL) throws -> Foundation.Data = { try Data(contentsOf: $0) }) throws
  @objc deinit
  final public func insert(_ value: Value, forKey key: Key)
  final public func saveToDisk()
  final public func value(forKey key: Key) -> Value?
  final public func allObjects() -> [Value]
}
extension DevicesCore.PersistentCache : DevicesCore.CleanableCache {
  final public func clean() throws
}
public enum PersistentCacheError : Foundation.LocalizedError, Swift.Equatable {
  case removeItemError(code: Swift.Int, domain: Swift.String, description: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: DevicesCore.PersistentCacheError, b: DevicesCore.PersistentCacheError) -> Swift.Bool
}
public typealias PhoneNumber = DevicesCore.Tagged<DevicesCore.PhoneNumberTag, Swift.String>
public enum PhoneNumberTag {
}
final public class PinningChallengeReceiver : DevicesCore.SecurityChallengeReceiver {
  public init(logger: DevicesCore.Logger?, trustDirective trustVerifier: DevicesCore.TrustVerifier)
  final public func receiveChallenge(_ challenge: Foundation.URLAuthenticationChallenge, task: DevicesCore.NetworkTask?, completion: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc deinit
}
public protocol PlaybackObserver {
  var currentTime: DevicesCore.Property<Foundation.TimeInterval> { get }
  func start()
  func stop()
}
public typealias PlaybackObserverFactory = DevicesCore.Factory<DevicesCore.AudioPlayer, DevicesCore.PlaybackObserver>
final public class PlaybackObserverImpl : DevicesCore.PlaybackObserver {
  final public var currentTime: DevicesCore.Property<Foundation.TimeInterval> {
    get
  }
  public init(player: DevicesCore.AudioPlayer, timerScheduler: DevicesCore.TimerScheduler, currentTimeObservingInterval: Foundation.TimeInterval)
  @objc deinit
  final public func start()
  final public func stop()
}
final public class Plist {
  public init(bundle: Foundation.Bundle, assertionCaller: DevicesCore.AssertionCaller)
  final public func value<T>(for key: Swift.String, type _: T.Type = T.self) -> Swift.Result<T, DevicesCore.Plist.Error> where T : Swift.LosslessStringConvertible
  final public func value<T>(for key: Swift.String) -> Swift.Result<T, DevicesCore.Plist.Error> where T : Swift.LosslessStringConvertible
  @objc deinit
}
extension DevicesCore.Plist {
  public enum Error : Swift.Error, Foundation.LocalizedError {
    case missingKey
    case invalidValue
    public var errorDescription: Swift.String? {
      get
    }
    public static func == (a: DevicesCore.Plist.Error, b: DevicesCore.Plist.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(*, deprecated, message: "Use ArgumentsStringID instead")
public protocol PluralNounStringID : DevicesCore.StringID {
}
public struct PrefixedKeyValueStorage : DevicesCore.KeyValueStorage {
  public init(subject: DevicesCore.KeyValueStorage, prefix: DevicesCore.PrefixedKeyValueStorage.Prefix)
  public func object(forKey key: Swift.String) -> DevicesCore.DirectStorable?
  public func array(forKey key: Swift.String) -> [DevicesCore.DirectStorable]?
  public func setObject(_ object: DevicesCore.DirectStorable, forKey key: Swift.String)
  public func removeObject(forKey key: Swift.String)
}
extension DevicesCore.PrefixedKeyValueStorage {
  public typealias Prefix = DevicesCore.Tagged<DevicesCore.PrefixedKeyValueStorage.PrefixTag, Swift.String>
  public enum PrefixTag {
  }
}
extension DevicesCore.KeyValueStorage {
  public func prefixed(by prefix: DevicesCore.PrefixedKeyValueStorage.Prefix) -> DevicesCore.KeyValueStorage
}
public enum PresentedViewHeight {
  public typealias HeightThatFits = (CoreFoundation.CGSize, UIKit.UIEdgeInsets) -> CoreFoundation.CGFloat
  case dynamic(DevicesCore.PresentedViewHeight.HeightThatFits)
  public func calculateSheetFrame(for size: CoreFoundation.CGSize, safeInsets: UIKit.UIEdgeInsets, mode: DevicesCore.StackPresentationMode) -> CoreFoundation.CGRect
}
extension DevicesCore.PrettyStringConvertible {
  public var caseName: Swift.String? {
    get
  }
}
public protocol PrettyStringConvertible : DevicesCore.NamedType, Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible {
  func makePrettyDescription(additionalOffset: Swift.String?) -> Swift.String
  var prettyDescription: Swift.String { get }
}
extension DevicesCore.PrettyStringConvertible {
  public func makePrettyDescription(additionalOffset: Swift.String?) -> Swift.String
  public var prettyDescription: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
public func prettyString(_ object: Any, additionalOffset: Swift.String? = nil) -> Swift.String
public var isRunningTests: Swift.Bool {
  get
}
extension Swift.Array {
  public func combine<Value>() -> DevicesCore.Property<[Value]> where Element == DevicesCore.Property<Value>
}
extension DevicesCore.Property {
  public func combine<T>(_ other: DevicesCore.Property<T>) -> DevicesCore.Property<(Value, T)>
}
extension DevicesCore.Property {
  public func filter(predicate: @escaping (Value) -> Swift.Bool) -> DevicesCore.Property<Value>
  @inlinable public func filter(_ keyPath: Swift.KeyPath<Value, Swift.Bool>) -> DevicesCore.Property<Value> {
		filter { $0[keyPath: keyPath] }
	}
}
extension DevicesCore.Property {
  public func mutable(setter: @escaping (Value) -> Swift.Void) -> DevicesCore.MutableProperty<Value>
}
extension DevicesCore.Property {
  public func removeDuplicates(using predicate: @escaping (Value, Value) -> Swift.Bool) -> DevicesCore.Property<Value>
}
extension DevicesCore.Property where Value : Swift.Collection {
  public func removeDuplicatesElements(using predicate: @escaping (Value.Element, Value.Element) -> Swift.Bool) -> DevicesCore.Property<Value>
}
extension DevicesCore.Property where Value : Swift.Equatable {
  @inlinable public func removeDuplicates() -> DevicesCore.Property<Value> {
		removeDuplicates(using: ==)
	}
}
extension DevicesCore.Property {
  public func sink(startWithCurrent: Swift.Bool, receiveValue: @escaping (Value) -> Swift.Void) -> DevicesCore.AnyCancellable
  public func sink(receiveValue: @escaping (_ previous: Value, Value) -> Swift.Void) -> DevicesCore.AnyCancellable
}
@propertyWrapper public struct Property<Value> {
  @usableFromInline
  internal let getter: () -> Value
  @inlinable public var value: Value {
    get { getter() }
  }
  public let signal: DevicesCore.Signal<Value>
  @inlinable public var wrappedValue: Value {
    get { value }
  }
  @inlinable public var projectedValue: DevicesCore.Property<Value> {
    get { self }
  }
  public init(getter: @escaping () -> Value, signal: DevicesCore.Signal<Value> = DefaultSignal<Value>().eraseToAnyPublisher())
}
extension DevicesCore.Property {
  @inlinable public static func constant(_ constant: Value) -> DevicesCore.Property<Value> {
		Property(constant)
	}
  public init(_ constant: Value)
  public init<T>(_ target: T, _ keyPath: Swift.KeyPath<T, Value>, signal: DevicesCore.Signal<Value> = DefaultSignal<Value>().eraseToAnyPublisher())
  public func map<Output>(using transform: @escaping (Value) -> Output) -> DevicesCore.Property<Output>
  public func shareMap<Output>(using transform: @escaping (Value) -> Output) -> DevicesCore.Property<Output>
  @inlinable public func map<Output>(_ keyPath: Swift.KeyPath<Value, Output>) -> DevicesCore.Property<Output> {
		map { $0[keyPath: keyPath] }
	}
  @inlinable public func shareMap<Output>(_ keyPath: Swift.KeyPath<Value, Output>) -> DevicesCore.Property<Output> {
		shareMap { $0[keyPath: keyPath] }
	}
  @inlinable public func subscribe(_ block: @escaping (Value) -> Swift.Void) -> DevicesCore.AnyCancellable {
		signal.sink(receiveValue: block)
	}
}
extension DevicesCore.Property where Value : AnyObject {
  public init(unowning value: Value)
}
extension DevicesCore.Property {
  public func flatMap<Wrapped, Output>(using transform: @escaping (Wrapped) -> Output) -> DevicesCore.Property<Output?> where Value == Wrapped?
  public func shareFlatMap<Wrapped, Output>(using transform: @escaping (Wrapped) -> Output) -> DevicesCore.Property<Output?> where Value == Wrapped?
  @inlinable public func flatMap<Wrapped, Output>(_ keyPath: Swift.KeyPath<Wrapped, Output>) -> DevicesCore.Property<Output?> where Value == Wrapped? {
		flatMap { $0[keyPath: keyPath] }
	}
  @inlinable public func shareFlatMap<Wrapped, Output>(_ keyPath: Swift.KeyPath<Wrapped, Output>) -> DevicesCore.Property<Output?> where Value == Wrapped? {
		shareFlatMap { $0[keyPath: keyPath] }
	}
}
extension DevicesCore.Property : Swift.Equatable where Value : Swift.Equatable {
  @inlinable public static func == (lhs: DevicesCore.Property<Value>, rhs: DevicesCore.Property<Value>) -> Swift.Bool {
		lhs.value == rhs.value
	}
}
extension DevicesCore.Property where Value : Swift.Collection {
  public func mapElements<OutputElement>(using transform: @escaping (Value.Element) -> OutputElement) -> DevicesCore.Property<[OutputElement]>
}
extension DevicesCore.Proxy : DevicesCore.AnalyticsService where Subject : DevicesCore.AnalyticsService {
  public func send(_ event: DevicesCore.AnalyticsEvent)
}
public class Proxy<Subject> : DevicesCore.NamedType {
  public var subject: Subject? {
    get
  }
  public init(label: Swift.String = #fileID, assertionCaller: DevicesCore.AssertionCaller)
  public func register(_: Subject)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class WeakProxy<Subject> : DevicesCore.Proxy<Subject> where Subject : AnyObject {
  override final public var subject: Subject? {
    get
  }
  override final public func register(_ subject: Subject)
  override public init(label: Swift.String = #fileID, assertionCaller: DevicesCore.AssertionCaller)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class StrongProxy<Subject> : DevicesCore.Proxy<Subject> {
  override final public var subject: Subject? {
    get
  }
  override final public func register(_ subject: Subject)
  override public init(label: Swift.String = #fileID, assertionCaller: DevicesCore.AssertionCaller)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class ProxyTaggedDeeplinkService<Tag> : DevicesCore.TaggedDeeplinkService<Tag> {
  weak final public var subject: DevicesCore.TaggedDeeplinkService<Tag>!
  @discardableResult
  override final public func handle(_ deeplink: DevicesCore.Tagged<Tag, DevicesCore.Deeplink>) -> Swift.Bool
  override public init()
  @objc deinit
}
final public class ProxyURLHandler : DevicesCore.URLHandler {
  weak final public var subject: DevicesCore.URLHandler?
  public init(assertionCaller: DevicesCore.AssertionCaller)
  final public func openURL(_ url: Foundation.URL, context: DevicesCore.URLContext, completion: @escaping (DevicesCore.URLHandlerResult) -> Swift.Void)
  final public func canOpen(_ url: Foundation.URL) -> Swift.Bool
  @objc deinit
}
final public class PushAuthorizationDefaultRequester : DevicesCore.PushAuthorizationRequester {
  public init(options: UserNotifications.UNAuthorizationOptions, userNotificationCenter: DevicesCore.UserNotificationCenter, assertionCaller: DevicesCore.AssertionCaller = assertionCallerShared)
  final public func requestAuthorization(completion: @escaping (DevicesCore.AuthorizationStatus) -> Swift.Void)
  @objc deinit
}
public protocol PushAuthorizationProvider : DevicesCore.AuthorizationProvider {
}
public protocol PushAuthorizationRequester : DevicesCore.AuthorizationRequester {
}
public protocol PushModifier {
  func modify(_ request: UserNotifications.UNNotificationRequest, completion: @escaping (Swift.Result<UserNotifications.UNNotificationContent, Swift.Error>) -> Swift.Void)
}
final public class PushRegistryController {
  public init(pushRegistry: DevicesCore.PKPushRegistryTwin, voipListener: DevicesCore.PushRegistryListener)
  @objc deinit
}
public protocol PushRegistryListener {
  func tokenUpdated(_ token: Foundation.Data?)
  func payloadReceived(_ payload: [Swift.AnyHashable : Any], completion: @escaping () -> Swift.Void)
}
public protocol PushService : DevicesCore.PushAuthorizationProvider, DevicesCore.PushAuthorizationRequester {
  var onAuthorizationStatusChange: DevicesCore.Signal<DevicesCore.AuthorizationStatus> { get }
}
extension DevicesCore.PushService {
  public func asAuthorizationStatusProperty() -> DevicesCore.Property<DevicesCore.AuthorizationStatus>
}
public struct Queue<T> {
  public var isEmpty: Swift.Bool {
    get
  }
  public var count: Swift.Int {
    get
  }
  public init(_ list: [T] = [])
  public mutating func enqueue(_ element: T)
  @discardableResult
  public mutating func dequeue() -> T?
  public mutating func peek() -> T?
  public mutating func clean()
}
public struct QuoteStripeAttribute {
  public var color: UIKit.UIColor
  public var thickness: CoreFoundation.CGFloat
  public var spacingAfter: CoreFoundation.CGFloat
  public var locations: [CoreFoundation.CGFloat]
}
extension Foundation.NSAttributedString.Key {
  public static let quoteStripe: Foundation.NSAttributedString.Key
}
extension Swift.Int {
  public static func makeRandom(_ range: Swift.Range<Swift.Int32> = 1 ..< INT32_MAX) -> Swift.Int
}
extension Swift.Int64 {
  public static func makeRandom(_ range: Swift.Range<Swift.Int64> = 1 ..< INT64_MAX) -> Swift.Int64
}
extension Swift.String {
  public static func makeRandomAlphanumericString(length: Swift.Int) -> Swift.String
  public static func makeRandomDigitsString(length: Swift.Int) -> Swift.String
  public static func makeRandomSymbolicString(from charactersPool: Swift.Set<Swift.Character>, length: Swift.Int, assertionCaller: DevicesCore.AssertionCaller = assertionCallerShared) -> Swift.String
}
extension Swift.RandomAccessCollection {
  @_alwaysEmitIntoClient @inline(__always) public func _index(at offset: Swift.Int) -> Self.Index {
		index(startIndex, offsetBy: offset)
	}
  @_alwaysEmitIntoClient @inline(__always) public func _offset(of index: Self.Index) -> Swift.Int {
		distance(from: startIndex, to: index)
	}
  @_alwaysEmitIntoClient @inline(__always) public subscript(_offset offset: Swift.Int) -> Self.Element {
    get {
		self[_index(at: offset)]
	}
  }
}
@_hasMissingDesignatedInitializers final public class Reachability {
  public enum Connection : Swift.CustomStringConvertible {
    @available(*, deprecated, renamed: "unavailable")
    case none
    case unavailable
    case wifi
    case cellular
    public var description: Swift.String {
      get
    }
    public static func == (a: DevicesCore.Reachability.Connection, b: DevicesCore.Reachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc deinit
}
public protocol ReachabilityService {
  var state: DevicesCore.Property<DevicesCore.ReachabilityState> { get }
  func startNotifier()
  func stopNotifier()
}
final public class ReachabilityServiceImpl : DevicesCore.ReachabilityService {
  final public var state: DevicesCore.Property<DevicesCore.ReachabilityState> {
    get
  }
  public init(logger: DevicesCore.Logger, assertionCaller: DevicesCore.AssertionCaller)
  final public func startNotifier()
  final public func stopNotifier()
  @objc deinit
}
public enum ReachabilityState {
  public enum Error : Swift.Error, Foundation.LocalizedError, Swift.Equatable {
    case failedCreate
    case failedNotifier
    public var errorDescription: Swift.String? {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesCore.ReachabilityState.Error, b: DevicesCore.ReachabilityState.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  case unknown
  case wifiReachable
  case cellularReachable
  case notReachable
  case failed
  public var isReachable: Swift.Bool {
    get
  }
  public static func == (a: DevicesCore.ReachabilityState, b: DevicesCore.ReachabilityState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol RedirectHandler {
  func handle(url: Foundation.URL)
}
public protocol Relay : Combine.Publisher where Self.Failure == Swift.Never {
  func send(_ value: Self.Output)
  func subscribe<P>(_ publisher: P) -> DevicesCore.AnyCancellable where P : Combine.Publisher, Self.Output == P.Output, P.Failure == Swift.Never
}
extension Combine.Publisher where Self.Failure == Swift.Never {
  public func subscribe<R>(_ relay: R) -> DevicesCore.AnyCancellable where R : DevicesCore.Relay, Self.Output == R.Output
}
extension DevicesCore.Relay where Self.Output == () {
  public func send()
}
public enum RemoteFileLoaderEvent {
  case finished
  public static func == (a: DevicesCore.RemoteFileLoaderEvent, b: DevicesCore.RemoteFileLoaderEvent) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol RemoteFileLoader : AnyObject {
  var onEvent: DevicesCore.Signal<DevicesCore.RemoteFileLoaderEvent> { get }
  func load(object: DevicesCore.RemoteFileObject, cancelToken: DevicesCore.CancellationToken?, completionHandler: @escaping (Swift.Result<Swift.Void, DevicesCore.RemoteFileLoaderError>) -> Swift.Void)
}
public enum RemoteFileLoaderError : Swift.Error {
  case downloadFailed(Swift.Error)
  case loadedTempFileIsMissing
  case moveFailed
  case incorrectResponse
  public var isCancelled: Swift.Bool {
    get
  }
}
final public class RemoteFileLoaderImpl : DevicesCore.RemoteFileLoader {
  final public var onEvent: DevicesCore.Signal<DevicesCore.RemoteFileLoaderEvent> {
    get
  }
  public init(fileManager: DevicesCore.FileManagerTwin, downloadPerformer: DevicesCore.URLDownloadPerformer, logger: DevicesCore.Logger?, assertionCaller: DevicesCore.AssertionCaller)
  final public func load(object: DevicesCore.RemoteFileObject, cancelToken: DevicesCore.CancellationToken?, completionHandler: @escaping (Swift.Result<Swift.Void, DevicesCore.RemoteFileLoaderError>) -> Swift.Void)
  @objc deinit
}
public struct RemoteFileObject {
  public let inputURL: Foundation.URL
  public let outputURL: Foundation.URL
  public init(inputURL: Foundation.URL, outputURL: Foundation.URL)
}
public protocol RemoteImageProvider {
  func downloadImage(from url: Foundation.URL, hash: Swift.String?, cancelToken: DevicesCore.CancellationToken, completion: @escaping (Swift.Result<UIKit.UIImage, Swift.Error>) -> Swift.Void)
}
final public class RemoteImageProviderFake : DevicesCore.RemoteImageProvider {
  public enum ProviderError : Swift.Error, DevicesCore.PrettyStringConvertible {
    case fakeProviderCannotDownloadImages
    public static func == (a: DevicesCore.RemoteImageProviderFake.ProviderError, b: DevicesCore.RemoteImageProviderFake.ProviderError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init()
  final public func downloadImage(from _: Foundation.URL, hash _: Swift.String?, cancelToken _: DevicesCore.CancellationToken, completion: @escaping (Swift.Result<UIKit.UIImage, Swift.Error>) -> Swift.Void)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class RemoteImageProviderImpl : DevicesCore.RemoteImageProvider {
  convenience public init(requestPerformer: DevicesCore.URLRequestPerformer, analytics: DevicesCore.AnalyticsService, hashValidator: DevicesCore.HashValidator?, cache: DevicesCore.PersistentCache<Foundation.URL, DevicesCore.URLAnswer>?, uiImageFactory: DevicesCore.UIImageFactory?, logger: DevicesCore.Logger?, osLogger: DevicesCore.OSLogger?)
  final public func downloadImage(from url: Foundation.URL, hash: Swift.String?, cancelToken: DevicesCore.CancellationToken, completion: @escaping (Swift.Result<UIKit.UIImage, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public enum RemoteImageProviders {
  public static func makeWithHashValidation(urlRequestPerformer: DevicesCore.URLRequestPerformer, analyticsService: DevicesCore.AnalyticsService, assertionCaller: DevicesCore.AssertionCaller, cache: DevicesCore.PersistentCache<Foundation.URL, DevicesCore.URLAnswer>?, uiImageFactory: DevicesCore.UIImageFactory?, logger: DevicesCore.Logger?, osLogger: DevicesCore.OSLogger?) -> DevicesCore.RemoteImageProvider
}
public typealias RemoteImageRequestPerformer = DevicesCore.RequestPerformer<Swift.Void, UIKit.UIImage>
extension DevicesCore.RequestPerformer where Request == (), Response == UIKit.UIImage {
  public static func make(url: Foundation.URL, hash: Swift.String?, urlRequestPerformer: DevicesCore.URLRequestPerformer, analytics: DevicesCore.AnalyticsService, hashValidator: DevicesCore.HashValidator?, cache: DevicesCore.PersistentCache<Foundation.URL, DevicesCore.URLAnswer>?, uiImageFactory: DevicesCore.UIImageFactory?, logger: DevicesCore.Logger?, osLogger: DevicesCore.OSLogger?) -> DevicesCore.RemoteImageRequestPerformer
}
public typealias RemoteImageRequestPerformerFactory = DevicesCore.Factory<(Foundation.URL, Swift.String?), DevicesCore.RemoteImageRequestPerformer>
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
final public class ReplaySubject<Output, Failure> : Combine.Subject where Failure : Swift.Error {
  public typealias Output = Output
  public typealias Failure = Failure
  public init(bufferSize: Swift.Int)
  final public func send(_ value: Output)
  final public func send(completion: Combine.Subscribers.Completion<Failure>)
  final public func send(subscription: Combine.Subscription)
  final public func receive<Subscriber>(subscriber: Subscriber) where Output == Subscriber.Input, Failure == Subscriber.Failure, Subscriber : Combine.Subscriber
  @objc deinit
}
open class RequestBuilder<Request> {
  public init()
  open func build(_: Request, cancelToken _: DevicesCore.CancellationToken?, completion _: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public enum RequestBuilders {
}
extension DevicesCore.RequestBuilders {
  public static func `default`<Request>(url: Foundation.URL, method: DevicesCore.HTTPMethod, headerBuilder: DevicesCore.HeaderBuilder, serializer: @escaping (Request) -> Swift.Result<Foundation.Data, Swift.Error>) -> DevicesCore.RequestBuilder<Request>
  public static func `default`(url: Foundation.URL, method: DevicesCore.HTTPMethod, headerBuilder: DevicesCore.HeaderBuilder) -> DevicesCore.RequestBuilder<Swift.Void>
  public static func `default`<Request>(url: Foundation.URL, method: DevicesCore.HTTPMethod, headerBuilder: DevicesCore.HeaderBuilder, inPrettyAndStableFormat: Swift.Bool = false, of _: Request.Type = Request.self) -> DevicesCore.RequestBuilder<Request> where Request : DevicesCore.Serializable
  public static func withRequestComponents<Request>(url: Foundation.URL, method: DevicesCore.HTTPMethod, headerBuilder: DevicesCore.HeaderBuilder) -> DevicesCore.RequestBuilder<Request> where Request : DevicesCore.RequestComponents
  public static func withRequestComponentsAndBody<Request>(url: Foundation.URL, method: DevicesCore.HTTPMethod, headerBuilder: DevicesCore.HeaderBuilder, inPrettyAndStableFormat: Swift.Bool = false, of _: Request.Type = Request.self) -> DevicesCore.RequestBuilder<Request> where Request : DevicesCore.RequestComponents, Request : DevicesCore.Serializable
  public static func multipartFormData<Request>(of paramsType: Request.Type = Request.self, assertionCaller: DevicesCore.AssertionCaller, url: Foundation.URL, method: DevicesCore.HTTPMethod, headerBuilder: DevicesCore.HeaderBuilder) -> DevicesCore.RequestBuilder<Request> where Request : DevicesCore.MultipartFormEncodable
}
public typealias ResultCompletion<T> = (Swift.Result<T, Swift.Error>) -> Swift.Void
public typealias ChainCompletion<T, E> = (Swift.Result<T, E>) -> Swift.Void where E : Swift.Error
final public class RequestChain<T, U, E> where E : Swift.Error {
  public init(closure: @escaping (T, @escaping DevicesCore.ChainCompletion<U, E>) -> Swift.Void)
  final public func next<Z>(_ nextClosure: @escaping (U, @escaping DevicesCore.ChainCompletion<Z, E>) -> Swift.Void) -> DevicesCore.RequestChain<T, Z, E>
  final public func perform(with value: T, completion: @escaping DevicesCore.ChainCompletion<U, E>)
  @objc deinit
}
extension DevicesCore.RequestChain where T == () {
  convenience public init(closure: @escaping (@escaping DevicesCore.ChainCompletion<U, E>) -> Swift.Void)
  final public func perform(completion: @escaping DevicesCore.ChainCompletion<U, E>)
  final public func perform(onSuccess: @escaping (U) -> Swift.Void, onError: @escaping (E) -> Swift.Void)
}
extension DevicesCore.RequestChain where U == () {
  final public func next<Z>(_ nextClosure: @escaping (@escaping DevicesCore.ChainCompletion<Z, E>) -> Swift.Void) -> DevicesCore.RequestChain<T, Z, E>
}
public enum PathRequestTag {
}
public protocol RequestComponents {
  var path: Swift.String? { get }
  var queryParameters: [Swift.String : Swift.String]? { get }
}
public enum RequestError : Foundation.LocalizedError {
  case prepare(Swift.Error)
  case send(Swift.Error)
  case parse(Swift.Error, urlAnswer: DevicesCore.URLAnswer)
  public var errorDescription: Swift.String? {
    get
  }
  public var httpCode: Swift.Int? {
    get
  }
  public var urlAnswer: DevicesCore.URLAnswer? {
    get
  }
  public var isForbidden: Swift.Bool {
    get
  }
  public func asPlain() -> Swift.Error
  public enum NSURLErrorDomainCode : Swift.Int {
    case networkConnectionLost
    case notConnectedToInternet
    case dataNotAllowed
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension Swift.Error {
  public var isRequestCancelledError: Swift.Bool {
    get
  }
  @available(*, deprecated, renamed: "unavailable")
  public var isForbiddenHTTP: Swift.Bool {
    get
  }
  public var httpCode: Swift.Int? {
    get
  }
  public func asPlainRequestError() -> Swift.Error
  public var isRequestInternetError: Swift.Bool {
    get
  }
}
open class RequestInterceptor<Request, Response> {
  public init()
  open func prepare(_ request: Request, cancelToken: DevicesCore.CancellationToken? = nil, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  open func send(_ urlRequest: Foundation.URLRequest, cancelToken: DevicesCore.CancellationToken? = nil, completion: @escaping (Swift.Result<DevicesCore.URLAnswer, Swift.Error>) -> Swift.Void)
  open func parse(_ urlAnswer: DevicesCore.URLAnswer, cancelToken: DevicesCore.CancellationToken? = nil, completion: @escaping (Swift.Result<Response, Swift.Error>) -> Swift.Void)
  @objc deinit
}
extension DevicesCore.RequestInterceptor {
  public func toRequestPerformer() -> DevicesCore.RequestPerformer<Request, Response>
}
open class RequestParser<Response> {
  public init()
  open func parse(_: DevicesCore.URLAnswer, cancelToken _: DevicesCore.CancellationToken?, completion _: @escaping (Swift.Result<Response, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public enum RequestParsers {
}
extension DevicesCore.RequestParsers {
  public static func `default`() -> DevicesCore.RequestParser<Swift.Void>
  public static func `default`<Response>(of _: Response.Type = Response.self, context: DevicesCore.DeserializationContext = .default) -> DevicesCore.RequestParser<Response> where Response : DevicesCore.Deserializable
  public static func anyResponse<Response>(deserializer: @escaping (DevicesCore.URLAnswer) throws -> Response) -> DevicesCore.RequestParser<Response>
  public static func data() -> DevicesCore.RequestParser<Foundation.Data>
}
open class RequestPerformer<Request, Response> {
  public typealias CompletionHandler = (Swift.Result<(Response, urlAnswer: DevicesCore.URLAnswer), DevicesCore.RequestError>) -> Swift.Void
  public init()
  open func perform(_ request: Request, cancelToken: DevicesCore.CancellationToken? = nil, completionHandler: @escaping DevicesCore.RequestPerformer<Request, Response>.CompletionHandler)
  @objc deinit
}
extension DevicesCore.RequestPerformer {
  @inlinable final public func perform(_ request: Request, cancelToken: DevicesCore.CancellationToken? = nil, responseHandler: @escaping (Swift.Result<Response, DevicesCore.RequestError>) -> Swift.Void) {
		perform(
			request,
			cancelToken: cancelToken,
			completionHandler: { result in
				responseHandler(result.map(\.0))
			}
		)
	}
}
extension DevicesCore.RequestPerformer where Request == () {
  @inlinable final public func perform(cancelToken: DevicesCore.CancellationToken? = nil, completionHandler: @escaping DevicesCore.RequestPerformer<Request, Response>.CompletionHandler) {
		perform(
			(),
			cancelToken: cancelToken,
			completionHandler: completionHandler
		)
	}
  @inlinable final public func perform(cancelToken: DevicesCore.CancellationToken? = nil, responseHandler: @escaping (Swift.Result<Response, DevicesCore.RequestError>) -> Swift.Void) {
		perform(
			(),
			cancelToken: cancelToken,
			responseHandler: responseHandler
		)
	}
}
extension Swift.Result where Failure == DevicesCore.RequestError {
  public func asPlain() -> Swift.Result<Success, Swift.Error>
}
@available(*, deprecated, message: "Use Result with URLAnswer and RequestError")
public enum RequestResult<Response> {
  case localError(Swift.Error)
  case network(Swift.Result<DevicesCore.HTTPResponse, Swift.Error>, processed: Swift.Result<Response, Swift.Error>)
  case localResponse(Response)
  @inlinable public static func processed(_ requestResult: DevicesCore.RequestResult<Response>) -> Swift.Result<Response, Swift.Error> {
		requestResult.processed
	}
  @inlinable public var network: Swift.Result<DevicesCore.HTTPResponse, Swift.Error>? {
    get {
		switch self {
		case .localError,
			 .localResponse:
			return nil
		case let .network(network, _):
			return network
		}
	}
  }
  @inlinable public var processed: Swift.Result<Response, Swift.Error> {
    get {
		switch self {
		case let .localError(error):
			return .failure(error)
		case let .network(_, processed):
			return processed
		case let .localResponse(response):
			return .success(response)
		}
	}
  }
  @inlinable public var httpCode: Swift.Int? {
    get {
		switch network {
		case let .success(response):
			return response.code
		case let .failure(error):
			return (error as? HTTPError)?.code
		case .none:
			return nil
		}
	}
  }
  @inlinable public func map<NewResponse>(_ transform: (Response) -> NewResponse) -> DevicesCore.RequestResult<NewResponse> {
		switch self {
		case let .localError(error):
			return .localError(error)
		case let .network(network, processed: processed):
			return .network(network, processed: processed.map(transform))
		case let .localResponse(response):
			return .localResponse(transform(response))
		}
	}
  @inlinable public func flatMap<NewResponse>(_ transform: (Response) -> Swift.Result<NewResponse, Swift.Error>) -> DevicesCore.RequestResult<NewResponse> {
		switch self {
		case let .localError(error):
			return .localError(error)
		case let .network(network, processed: processed):
			return .network(network, processed: processed.flatMap(transform))
		case let .localResponse(response):
			switch transform(response) {
			case let .success(newResponse):
				return .localResponse(newResponse)
			case let .failure(error):
				return .localError(error)
			}
		}
	}
}
final public class RequestWithPathBuilder<Request> : DevicesCore.RequestBuilder<Request> where Request : DevicesCore.RequestComponents {
  public init(url: Foundation.URL, method: DevicesCore.HTTPMethod, headerBuilder: DevicesCore.HeaderBuilder, requestFactory: DevicesCore.URLRequestFactory = StaticURLRequestFactory(), serializer: @escaping (Request) -> Swift.Result<Foundation.Data, Swift.Error>)
  override final public func build(_ request: Request, cancelToken: DevicesCore.CancellationToken?, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  @objc deinit
}
@propertyWrapper final public class ResettableLazy<Item> {
  final public var wrappedValue: Item {
    get
  }
  public init(_ initializer: @escaping () -> Item)
  final public func clear()
  @objc deinit
}
public struct ResourceConfigObject : Swift.Equatable {
  public let id: DevicesCore.ResourceID
  public let filename: Swift.String
  public let revision: Swift.Int
  public let subfolder: Swift.String?
  public let requiredInStartup: Swift.Bool
  public let url: Foundation.URL?
  public init(id: DevicesCore.ResourceID, filename: Swift.String, revision: Swift.Int, subfolder: Swift.String?, requiredInStartup: Swift.Bool?, url: Foundation.URL?)
  public static func == (a: DevicesCore.ResourceConfigObject, b: DevicesCore.ResourceConfigObject) -> Swift.Bool
}
extension DevicesCore.ResourceConfigObject : DevicesCore.Deserializable {
  public init(deserializer: DevicesCore.Deserializer) throws
}
extension DevicesCore.ResourceConfigObject : DevicesCore.ResourceTag {
  public var remoteURL: Foundation.URL? {
    get
  }
  public var shouldLoadOnStartup: Swift.Bool {
    get
  }
}
public struct ResourceDownloadParams {
  public let resource: DevicesCore.ResourceTag
  public let outputURL: Foundation.URL
  public let url: Foundation.URL
  public init(resource: DevicesCore.ResourceTag, outputURL: Foundation.URL, url: Foundation.URL)
}
extension DevicesCore.ResourceDownloadParams : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension DevicesCore.ResourceDownloadParams : Swift.Equatable {
  public static func == (lhs: DevicesCore.ResourceDownloadParams, rhs: DevicesCore.ResourceDownloadParams) -> Swift.Bool
}
public protocol ResourceDownloadParamsFactory {
  func makeResourceDownloadParams(resource: DevicesCore.ResourceTag, params: DevicesCore.ResourceLoaderParams, fileURLFactory: DevicesCore.FileURLFactory) -> DevicesCore.ResourceDownloadParams
}
final public class ResourceDownloadParamsFactoryImpl : DevicesCore.ResourceDownloadParamsFactory {
  public init(urlFromConfig: Swift.Bool)
  final public func makeResourceDownloadParams(resource: DevicesCore.ResourceTag, params: DevicesCore.ResourceLoaderParams, fileURLFactory: DevicesCore.FileURLFactory) -> DevicesCore.ResourceDownloadParams
  @objc deinit
}
extension DevicesCore.ResourceConfigObject {
  public var analyticsInfo: [Swift.String : Any] {
    get
  }
}
public protocol ResourceLoaderController : DevicesCore.DownloadController {
  var delegate: DevicesCore.ResourceLoaderControllerDelegate? { get set }
  var resourceDirectory: Foundation.URL { get }
}
public protocol ResourceLoaderControllerDelegate : AnyObject {
  func didFinishLoading(resource: DevicesCore.ResourceTag)
}
@_hasMissingDesignatedInitializers final public class ResourceLoaderControllerImpl : DevicesCore.ResourceLoaderController {
  final public let resourceDirectory: Foundation.URL
  weak final public var delegate: DevicesCore.ResourceLoaderControllerDelegate?
  final public func downloadResources(onlyStartupObjects: Swift.Bool)
  @objc deinit
}
extension DevicesCore.ResourceLoaderControllerImpl {
  convenience public init(params: DevicesCore.ResourceLoaderParams, rootDirectory: Foundation.URL, resourcesPath: Swift.String, requestPerformer: DevicesCore.URLRequestPerformer, downloadPerformer: DevicesCore.URLDownloadPerformer, keyValueStorage: DevicesCore.KeyValueStorage, analyticsService: DevicesCore.AnalyticsService, urlFromConfig: Swift.Bool, fileManager: DevicesCore.FileManagerTwin, logger: DevicesCore.Logger?, assertionCaller: DevicesCore.AssertionCaller, deserializationContext: DevicesCore.DeserializationContext)
}
public struct ResourceLoaderParams : DevicesCore.Serializable {
  public let host: Foundation.URL
  public let resourcePath: Swift.String
  public let useOnlyHost: Swift.Bool
  public init(host: Foundation.URL, resourcePath: Swift.String)
  public func toJSONDictionary() -> DevicesCore.JSONDictionary
}
public enum ResourceIDTag {
}
public typealias ResourceID = DevicesCore.Tagged<DevicesCore.ResourceIDTag, Swift.String>
public protocol ResourceTag {
  var id: DevicesCore.ResourceID { get }
  var filename: Swift.String { get }
  var revision: Swift.Int { get }
  var subfolder: Swift.String? { get }
  var remoteURL: Foundation.URL? { get }
  var shouldLoadOnStartup: Swift.Bool { get }
  var analyticsInfo: [Swift.String : Any] { get }
}
extension Swift.Result {
  public var isSuccess: Swift.Bool {
    get
  }
  public var isFailure: Swift.Bool {
    get
  }
  public var success: Success? {
    get
  }
  public var error: Failure? {
    get
  }
}
extension Swift.Result where Success == () {
  public static var success: Swift.Result<(), Failure> {
    get
  }
}
extension Swift.Result : DevicesCore.PrettyStringConvertible {
}
open class RetryHandler<Response> : DevicesCore.RetryHandling {
  public init()
  open func setRetryHandler(_: @escaping (DevicesCore.RetryResult) -> Swift.Void)
  open func scheduleRetry(_: Swift.Result<Response, Swift.Error>) -> DevicesCore.RetryResult
  @objc deinit
}
public typealias RetryCount = Swift.Int
public enum RetryResult : Swift.Equatable {
  case needRetry
  case declined(DevicesCore.RetryCount)
  public static func == (a: DevicesCore.RetryResult, b: DevicesCore.RetryResult) -> Swift.Bool
}
public protocol RetryHandling {
  associatedtype Response
  func setRetryHandler(_ retryHandler: @escaping (DevicesCore.RetryResult) -> Swift.Void)
  func scheduleRetry(_ result: Swift.Result<Self.Response, Swift.Error>) -> DevicesCore.RetryResult
}
final public class RetryResetHandler<Response> : DevicesCore.RetryHandler<Response> {
  public init(_ factory: @escaping () -> DevicesCore.RetryHandler<Response>)
  override final public func setRetryHandler(_ handler: @escaping (DevicesCore.RetryResult) -> Swift.Void)
  override final public func scheduleRetry(_ handler: Swift.Result<Response, Swift.Error>) -> DevicesCore.RetryResult
  final public func reset()
  @objc deinit
}
extension DevicesCore.RequestPerformer {
  public func retrying(using retryHandler: @escaping () -> DevicesCore.RetryHandler<Response>) -> DevicesCore.RequestPerformer<Request, Response>
}
final public class RetryTimeConstantPolicy : DevicesCore.RetryTimePolicy {
  public init(interval: Foundation.TimeInterval)
  final public func next() -> Foundation.TimeInterval
  @objc deinit
}
final public class RetryTimeIncreasePolicy : DevicesCore.RetryTimePolicy {
  public init(baseInterval: Foundation.TimeInterval = 0.1, intervalMultiplier: Foundation.TimeInterval = 2.7)
  final public func next() -> Foundation.TimeInterval
  @objc deinit
}
public protocol RetryTimePolicy {
  func next() -> Foundation.TimeInterval
}
final public class RetryTimerHandler<Response> : DevicesCore.RetryHandler<Response> {
  public init(logger: DevicesCore.Logger? = nil, assertionCaller: DevicesCore.AssertionCaller, retriesTimeout: Foundation.TimeInterval? = nil, maxRetriesCount: Swift.Int? = nil, substractsRequestTime: Swift.Bool = false, timePolicy: DevicesCore.RetryTimePolicy = RetryTimeIncreasePolicy(), timerScheduler: DevicesCore.TimerScheduler = SystemTimerScheduler(), dateProvider: @escaping () -> Foundation.Date = Date.init, shouldRetry: @escaping (Swift.Result<Response, Swift.Error>) -> Swift.Bool = { _ in true })
  @objc deinit
  override final public func setRetryHandler(_ retryHandler: @escaping (DevicesCore.RetryResult) -> Swift.Void)
  override final public func scheduleRetry(_ result: Swift.Result<Response, Swift.Error>) -> DevicesCore.RetryResult
}
extension Combine.Publisher {
  public func retryWhen<P>(_ handler: @escaping (Combine.AnyPublisher<Self.Failure, Swift.Never>) -> P) -> Combine.Publishers.RetryWhen<Self, P> where P : Combine.Publisher, Self.Failure == P.Failure
}
extension Combine.Publishers {
  public class RetryWhen<Upstream, Handler> : Combine.Publisher where Upstream : Combine.Publisher, Handler : Combine.Publisher, Upstream.Failure == Handler.Failure {
    public typealias Output = Upstream.Output
    public typealias Failure = Upstream.Failure
    public init(upstream: Upstream, handler: @escaping (Combine.AnyPublisher<Upstream.Failure, Swift.Never>) -> Handler)
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, Upstream.Output == S.Input, Handler.Failure == S.Failure
    @objc deinit
  }
}
extension DevicesCore.ReusableAudioPlayer {
  public func decoded(audioDecoderFactory: DevicesCore.AudioDecoderFactory) -> DevicesCore.ReusableAudioPlayer
}
public protocol ReusableAudioPlayer {
  var state: DevicesCore.Property<DevicesCore.ReusableAudioPlayerState> { get }
  func play(payload: DevicesCore.AudioPayload, atTime time: Foundation.TimeInterval)
  func pause()
  func stop()
}
final public class ReusableAudioPlayerImpl : DevicesCore.ReusableAudioPlayer {
  final public var state: DevicesCore.Property<DevicesCore.ReusableAudioPlayerState> {
    get
  }
  public init(audioPlaybackPlayerFactory: DevicesCore.AudioPlaybackPlayerFactory, assertionCaller: DevicesCore.AssertionCaller)
  convenience public init(audioSessionConfigurator: DevicesCore.AudioSessionConfigurator, applicationState: DevicesCore.Property<DevicesCore.ApplicationState>, assertionCaller: DevicesCore.AssertionCaller)
  final public func play(payload: DevicesCore.AudioPayload, atTime time: Foundation.TimeInterval)
  final public func pause()
  final public func stop()
  @objc deinit
}
extension DevicesCore.ReusableAudioPlayerState : Swift.Equatable {
  public static func == (lhs: DevicesCore.ReusableAudioPlayerState, rhs: DevicesCore.ReusableAudioPlayerState) -> Swift.Bool
}
extension DevicesCore.ReusableAudioPlayerState {
  public struct Playing : Swift.Equatable {
    public let time: Foundation.TimeInterval
    public let duration: Foundation.TimeInterval
    public init(time: Foundation.TimeInterval, duration: Foundation.TimeInterval)
    public static func == (a: DevicesCore.ReusableAudioPlayerState.Playing, b: DevicesCore.ReusableAudioPlayerState.Playing) -> Swift.Bool
  }
}
public enum ReusableAudioPlayerState {
  public typealias Paused = DevicesCore.ReusableAudioPlayerState.Playing
  case idle
  case playing(DevicesCore.ReusableAudioPlayerState.Playing)
  case paused(DevicesCore.ReusableAudioPlayerState.Paused)
  case stopped(finished: Swift.Bool)
  case failed(Swift.Error)
}
public protocol RootAccessChecker {
  func userHasRootAccess() -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class RootAccessCheckerImpl : DevicesCore.RootAccessChecker {
  convenience public init(fileManager: DevicesCore.FileManagerTwin, logger: DevicesCore.Logger, bundle: DevicesCore.BundleTwin)
  final public func userHasRootAccess() -> Swift.Bool
  @objc deinit
}
public protocol SDWebSocketClient : AnyObject {
  var isConnected: Swift.Bool { get }
  var delegate: DevicesCore.SDWebSocketDelegate? { get set }
  var pongDelegate: DevicesCore.SDWebSocketPongDelegate? { get set }
  var disableSSLCertValidation: Swift.Bool { get set }
  var security: DevicesCore.TrustDefaultVerifier? { get set }
  func connect()
  func disconnect(closeCode: Swift.UInt16)
  func write(string: Swift.String, completion: (() -> Swift.Void)?)
  func write(data: Foundation.Data, completion: (() -> Swift.Void)?)
  func writePing(completion: (() -> Swift.Void)?)
}
extension DevicesCore.SDWebSocketClient {
  public func write(string: Swift.String)
  public func write(data: Foundation.Data)
  public func writePing()
  public func disconnect()
}
public protocol SDWebSocketDelegate : AnyObject {
  func websocketDidConnect(socket: DevicesCore.SDWebSocketClient)
  func websocketDidDisconnect(socket: DevicesCore.SDWebSocketClient, error: Swift.Error?)
  func websocketDidReceiveMessage(socket: DevicesCore.SDWebSocketClient, text: Swift.String)
  func websocketDidReceiveData(socket: DevicesCore.SDWebSocketClient, data: Foundation.Data)
  func websocketDidReceiveError(socket: DevicesCore.SDWebSocketClient, error: Swift.Error)
}
public protocol SDWebSocketPongDelegate : AnyObject {
  func websocketDidReceivePong(socket: DevicesCore.SDWebSocketClient)
}
public protocol SDWebSocketFactory {
  func make(request: Foundation.URLRequest) -> DevicesCore.SDWebSocketClient
  func make(url: Foundation.URL) -> DevicesCore.SDWebSocketClient
}
public struct SDWebSocketFactoryImpl : DevicesCore.SDWebSocketFactory {
  public init(useNativeWebSocket: Swift.Bool, logger: DevicesCore.Logger?, callbackQueue: DevicesCore.SerialQueue = DispatchSerialQueue.main)
  public func make(request: Foundation.URLRequest) -> DevicesCore.SDWebSocketClient
  public func make(url: Foundation.URL) -> DevicesCore.SDWebSocketClient
}
public struct SDSSLClientCertificateError : Foundation.LocalizedError {
  public var errorDescription: Swift.String?
  public init(errorDescription: Swift.String)
}
public class SDSSLClientCertificate {
  convenience public init(pkcs12Path: Swift.String, password: Swift.String) throws
  public init(identity: Security.SecIdentity, identityCertificate: Security.SecCertificate)
  convenience public init(pkcs12Url: Foundation.URL, password: Swift.String) throws
  public init(pkcs12Url: Foundation.URL, importOptions: CoreFoundation.CFDictionary) throws
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SDSSLCert {
  @objc deinit
}
public class SSLSecurity : DevicesCore.TrustDefaultVerifier {
  convenience public init(usePublicKeys: Swift.Bool = false)
  public init(certs: [DevicesCore.SDSSLCert], usePublicKeys: Swift.Bool)
  public func validate(_ trust: Security.SecTrust, domain: Swift.String?) throws
  @objc deinit
}
public protocol Screen {
  var viewController: UIKit.UIViewController { get }
}
public protocol SecurityChallengeReceiver {
  func receiveChallenge(_ challenge: Foundation.URLAuthenticationChallenge, task: DevicesCore.NetworkTask?, completion: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
extension Dispatch.DispatchSemaphore {
  public static func mutex(_ value: Swift.Int = 1) -> Dispatch.DispatchSemaphore
  @discardableResult
  public func with<T>(_ block: () throws -> T) rethrows -> T
}
extension Swift.Sequence {
  @inlinable public func nonnull<T>() -> [T] where Self.Element == T? { compactMap { $0 } }
}
extension Swift.Sequence where Self.Element == Swift.Character {
  @inlinable public func toString() -> Swift.String {
		String(self)
	}
}
extension Swift.Sequence where Self.Element : Swift.Hashable {
  public func uniqued() -> [Self.Element]
}
final public class SequenceSecurityChallengeReceiver : DevicesCore.SecurityChallengeReceiver {
  public typealias DefaultHandler = (Foundation.URLAuthenticationChallenge, DevicesCore.NetworkTask?) -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
  public init(receivers: [DevicesCore.SecurityChallengeReceiver], defaultHandler: @escaping DevicesCore.SequenceSecurityChallengeReceiver.DefaultHandler)
  final public func receiveChallenge(_ challenge: Foundation.URLAuthenticationChallenge, task: DevicesCore.NetworkTask?, completion: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc deinit
}
public struct SequenceTrustVerifier : DevicesCore.TrustVerifier {
  public enum Error : Swift.Error, Swift.Equatable {
    case invalid
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesCore.SequenceTrustVerifier.Error, b: DevicesCore.SequenceTrustVerifier.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(subjects: [DevicesCore.TrustVerifier])
  public func validate(_ trust: Security.SecTrust, domain: Swift.String?) throws
}
public protocol SerialQueue : DevicesCore.AsyncPerformer {
  func sync<T>(execute work: () throws -> T) rethrows -> T
  func assertOnMe()
}
public struct DispatchSerialQueue : DevicesCore.SerialQueue {
  @usableFromInline
  internal let queue: Dispatch.DispatchQueue
  public init(label: Swift.String, qos: Dispatch.DispatchQoS)
  @inlinable public func sync<T>(execute work: () throws -> T) rethrows -> T {
		try queue.sync { try work() }
	}
  @inlinable public func execute(_ operation: @escaping () -> Swift.Void) {
		queue.async(execute: operation)
	}
  @inlinable public func assertOnMe() {
		queue.assertOnMe()
	}
  public func executeAfter(delay: DevicesCore.Milliseconds, _ operation: @escaping () -> Swift.Void)
  public func execute(after deadline: Dispatch.DispatchTime, work: @escaping () -> Swift.Void)
}
extension DevicesCore.DispatchSerialQueue {
  public static var main: DevicesCore.SerialQueue {
    get
  }
}
public typealias JSONString = Swift.String
public protocol Serializable {
  func toJSONDictionary() -> DevicesCore.JSONDictionary
  func toJSONString(inPrettyAndStableFormat: Swift.Bool, errorHandler: DevicesCore.SerializationErrorHandler) -> DevicesCore.JSONString
  func toJSONData(inPrettyAndStableFormat: Swift.Bool) throws -> Foundation.Data
}
extension DevicesCore.Serializable {
  public func toJSONData(inPrettyAndStableFormat: Swift.Bool) throws -> Foundation.Data
  public func toJSONString(inPrettyAndStableFormat: Swift.Bool, errorHandler: DevicesCore.SerializationErrorHandler) -> DevicesCore.JSONString
  public func toJSONData(inPrettyAndStableFormat: Swift.Bool, errorHandler: DevicesCore.SerializationErrorHandler) -> Foundation.Data
}
public enum SerializationError : Foundation.LocalizedError {
  case invalidJSONObject
  case failedToFormJSONString
  case failedToFormJSONDictionary
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: DevicesCore.SerializationError, b: DevicesCore.SerializationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol SerializationErrorHandler {
  @discardableResult
  func handleSerializationError(_ error: Swift.Error, on object: DevicesCore.Serializable) -> DevicesCore.JSONString
  @discardableResult
  func handleDataSerializationError(_ error: Swift.Error, on object: DevicesCore.Serializable) -> Foundation.Data
}
final public class SerializationErrorHandlerImpl : DevicesCore.SerializationErrorHandler {
  public init(logger: DevicesCore.Logger?, assertionCaller: DevicesCore.AssertionCaller)
  @discardableResult
  final public func handleSerializationError(_ error: Swift.Error, on object: DevicesCore.Serializable) -> DevicesCore.JSONString
  @discardableResult
  final public func handleDataSerializationError(_ error: Swift.Error, on object: DevicesCore.Serializable) -> Foundation.Data
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func share(replay count: Swift.Int) -> Combine.Publishers.Autoconnect<Combine.Publishers.Multicast<Self, DevicesCore.ReplaySubject<Self.Output, Self.Failure>>>
}
public typealias AudioFocus = DevicesCore.SharedResource
public typealias AudioFocusUtilizer = DevicesCore.SharedResourceUtilizer
public enum SharedResourceCaptureType {
  case inclusive
  case exclusive(priority: DevicesCore.Tagged<DevicesCore.SharedResourceUtilizerPriorityTag, Swift.Int>)
}
extension DevicesCore.SharedResource {
  public typealias CaptureType = DevicesCore.SharedResourceCaptureType
}
public enum SharedResourceNameTag {
}
extension DevicesCore.SharedResource {
  public typealias Name = DevicesCore.Tagged<DevicesCore.SharedResourceNameTag, Swift.String>
}
public protocol SharedResource {
  var name: DevicesCore.Tagged<DevicesCore.SharedResourceNameTag, Swift.String> { get }
  var utilizers: [DevicesCore.Tagged<DevicesCore.SharedResourceUtilizerNameTag, Swift.String> : DevicesCore.SharedResourceUtilizer] { get }
  func requestAccess(for utilizer: DevicesCore.SharedResourceUtilizer) -> Swift.Bool
  func requestAccessAsynchronously(for utilizer: DevicesCore.SharedResourceUtilizer)
  func revokeAccess(for utilizer: DevicesCore.SharedResourceUtilizer)
}
final public class SharedResourceImpl : DevicesCore.AudioFocus {
  final public let name: DevicesCore.SharedResourceImpl.Name
  final public var utilizers: [DevicesCore.Tagged<DevicesCore.SharedResourceUtilizerNameTag, Swift.String> : DevicesCore.SharedResourceUtilizer] {
    get
  }
  public init(name: DevicesCore.SharedResourceImpl.Name)
  final public func requestAccess(for utilizer: DevicesCore.SharedResourceUtilizer) -> Swift.Bool
  final public func requestAccessAsynchronously(for utilizer: DevicesCore.SharedResourceUtilizer)
  final public func revokeAccess(for utilizer: DevicesCore.SharedResourceUtilizer)
  @objc deinit
}
public enum SharedResourceUtilizerNameTag : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesCore.SharedResourceUtilizerNameTag, b: DevicesCore.SharedResourceUtilizerNameTag) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DevicesCore.SharedResourceUtilizer {
  public typealias Name = DevicesCore.Tagged<DevicesCore.SharedResourceUtilizerNameTag, Swift.String>
}
public enum SharedResourceUtilizerPriorityTag {
}
extension DevicesCore.SharedResourceUtilizer {
  public typealias Priority = DevicesCore.Tagged<DevicesCore.SharedResourceUtilizerPriorityTag, Swift.Int>
}
public protocol SharedResourceUtilizer {
  var name: Self.Name { get }
  var captureType: DevicesCore.SharedResourceCaptureType { get }
  func onCapture()
  func onInclusiveUpdate()
  func onRelease()
}
extension DevicesCore.SharedResourceUtilizer {
  public func onCapture()
  public func onInclusiveUpdate()
  public func onRelease()
}
public typealias Signal<Output> = Combine.AnyPublisher<Output, Swift.Never>
extension DevicesCore.KeychainAttributes {
  public typealias Label = DevicesCore.Tagged<DevicesCore.KeychainAttributes.LabelTag, Swift.String>
  public typealias Service = DevicesCore.Tagged<DevicesCore.KeychainAttributes.ServiceTag, Swift.String>
  public typealias Account = DevicesCore.Tagged<DevicesCore.KeychainAttributes.AccountTag, Swift.String>
  public typealias AccessGroup = DevicesCore.Tagged<DevicesCore.KeychainAttributes.AccessGroupTag, Swift.String>
  public enum LabelTag {
  }
  public enum ServiceTag {
  }
  public enum AccountTag {
  }
  public enum AccessGroupTag {
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  @inlinable public func sink() -> Combine.AnyCancellable {
		sink(receiveCompletion: { _ in }, receiveValue: { _ in })
	}
}
extension DevicesCore.WebSocket {
  public struct SocketError : Swift.Error {
    public let type: DevicesCore.WebSocket.ErrorType
    public let message: Swift.String
    public let code: Swift.Int
  }
}
public enum SoundPlaybackStrategy : Swift.Equatable {
  case once
  case loop(Swift.Int)
  case infiniteLoop
  public static func == (a: DevicesCore.SoundPlaybackStrategy, b: DevicesCore.SoundPlaybackStrategy) -> Swift.Bool
}
public protocol SoundPlayer {
  typealias Completion = (Swift.Result<Swift.Void, DevicesCore.SoundPlayerError>) -> Swift.Void
  func play(_ strategy: DevicesCore.SoundPlaybackStrategy, completion: @escaping Self.Completion)
  func stop()
}
extension DevicesCore.SoundPlayer {
  public func play(_ strategy: DevicesCore.SoundPlaybackStrategy)
}
public enum SoundPlayerError : Swift.Error {
  case configuration
  case decoding
  case canceled
  public static func == (a: DevicesCore.SoundPlayerError, b: DevicesCore.SoundPlayerError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias SoundPlayerFactory = DevicesCore.Factory<Foundation.URL, DevicesCore.SoundPlayer?>
extension DevicesCore.Factory where Arg == Foundation.URL, Item == DevicesCore.SoundPlayer? {
  public static func defaultPlayback(configurator: DevicesCore.AudioSessionConfigurator) -> DevicesCore.SoundPlayerFactory
  public static func currentConfiguration() -> DevicesCore.SoundPlayerFactory
}
public protocol SqliteCodingKey {
  var key: Swift.String { get }
}
extension DevicesCore.SqliteCodingKey where Self : Swift.RawRepresentable, Self.RawValue == Swift.String {
  public var key: Swift.String {
    get
  }
}
public struct SqliteCodingStatement<Key> where Key : DevicesCore.SqliteCodingKey {
  @usableFromInline
  internal let wildcardColumns: [Swift.String : Swift.Int]
  @usableFromInline
  internal let selectColumns: [Swift.String : Swift.Int]
  @usableFromInline
  internal let statement: DevicesCore.SqliteStatement
  @inlinable internal func wildcardColumn(for key: Key) throws -> Swift.Int {
		try wildcardColumns[key.key].get() + 1
	}
  @inlinable internal func selectColumn(for key: Key) throws -> Swift.Int {
		try selectColumns[key.key].get()
	}
  @discardableResult
  @inlinable public func step() throws -> Swift.Bool {
		try statement.step()
	}
  @inlinable public func reset() throws {
		try statement.reset()
	}
}
extension DevicesCore.SqliteCodingStatement {
  @inlinable public func bind(_ value: Swift.Int?, key: Key) throws {
		try statement.bind(value, column: wildcardColumn(for: key))
	}
  @inlinable public func bind(_ value: Swift.Double?, key: Key) throws {
		try statement.bind(value, column: wildcardColumn(for: key))
	}
  @inlinable public func bind(_ value: Swift.String?, key: Key) throws {
		try statement.bind(value, column: wildcardColumn(for: key))
	}
  @inlinable public func bind<T>(_ value: T?, key: Key) throws where T : Swift.RawRepresentable, T.RawValue == Swift.Int {
		try statement.bind(value?.rawValue, column: wildcardColumn(for: key))
	}
  @inlinable public func bind<T>(_ value: T?, key: Key) throws where T : Swift.RawRepresentable, T.RawValue == Swift.UInt {
		try statement.bind(value.map { Int($0.rawValue) }, column: wildcardColumn(for: key))
	}
  @inlinable public func bind<T>(_ value: T?, key: Key) throws where T : Swift.RawRepresentable, T.RawValue == Swift.String {
		try statement.bind(value?.rawValue, column: wildcardColumn(for: key))
	}
  @inlinable public func bind(_ value: Swift.Bool?, key: Key) throws {
		try statement.bind(value.map { $0 ? 1 : 0 }, column: wildcardColumn(for: key))
	}
}
extension DevicesCore.SqliteCodingStatement {
  @inlinable public func get(_: Swift.Int.Type, key: Key) throws -> Swift.Int {
		try statement.get(Int.self, column: selectColumn(for: key))
	}
  @inlinable public func get(_: Swift.UInt.Type, key: Key) throws -> Swift.UInt {
		try statement.get(UInt.self, column: selectColumn(for: key))
	}
  @inlinable public func get(_: Swift.Double.Type, key: Key) throws -> Swift.Double {
		try statement.get(Double.self, column: selectColumn(for: key))
	}
  @inlinable public func get(_: Swift.String.Type, key: Key) throws -> Swift.String? {
		try statement.get(String.self, column: selectColumn(for: key))
	}
  @inlinable public func get(_: Swift.Bool.Type = Bool.self, key: Key) throws -> Swift.Bool {
		try get(Int.self, key: key) != 0
	}
  @inlinable public func get<T>(_: T.Type = T.self, key: Key) throws -> T? where T : Swift.RawRepresentable, T.RawValue == Swift.UInt {
		try T(rawValue: get(UInt.self, key: key))
	}
  @inlinable public func get<T>(_: T.Type = T.self, key: Key) throws -> T? where T : Swift.RawRepresentable, T.RawValue == Swift.Int {
		try T(rawValue: get(Int.self, key: key))
	}
  @inlinable public func get<T>(_: T.Type = T.self, key: Key) throws -> T? where T : Swift.RawRepresentable, T.RawValue == Swift.String {
		try get(String.self, key: key).flatMap(T.init)
	}
}
extension DevicesCore.SqliteDatabase {
  public func insert<T, Key>(entity: Swift.String, keys: [Key], using block: (DevicesCore.SqliteCodingStatement<Key>) throws -> T) throws -> T where Key : DevicesCore.SqliteCodingKey
  public func select<T, Key>(entity: Swift.String, keys: [Key], using block: (DevicesCore.SqliteCodingStatement<Key>) throws -> T) throws -> T where Key : DevicesCore.SqliteCodingKey
  public func selectTop<T, Key>(count: Swift.Int, entity: Swift.String, keys: [Key], orderBy: Key, isAscending: Swift.Bool, using block: (DevicesCore.SqliteCodingStatement<Key>) throws -> T) throws -> T where Key : DevicesCore.SqliteCodingKey
}
public protocol SqliteDatabase {
  var lastInsertRowID: Swift.Int { get }
  func withStatement<T>(_ query: Swift.String, using block: (DevicesCore.SqliteStatement) throws -> T) throws -> T
  func setBusyTimeout(_ timeout: Foundation.TimeInterval) throws
}
extension DevicesCore.SqliteDatabase {
  @inlinable public func execute(_ query: Swift.String) throws {
		try withStatement(query) {
			_ = try $0.step()
		}
	}
}
final public class SqliteDatabaseImpl : DevicesCore.SqliteDatabase {
  public static var inMemory: DevicesCore.SqliteDatabaseImpl {
    get
  }
  public init(path: Swift.String)
  @objc deinit
  final public var lastInsertRowID: Swift.Int {
    get
  }
  final public func withStatement<T>(_ query: Swift.String, using block: (DevicesCore.SqliteStatement) throws -> T) throws -> T
  final public func setBusyTimeout(_ timeout: Foundation.TimeInterval) throws
}
extension DevicesCore.Loggers {
  public static func fileLogger(file: Swift.String, appGroup: DevicesCore.ApplicationGroup? = nil, fileManager: Foundation.FileManager = .default, assertionCaller: DevicesCore.AssertionCaller) -> DevicesCore.LogStorage & DevicesCore.Logger
}
public protocol SqliteStatement {
  func bind(_ value: Swift.Int?, column: Swift.Int)
  func bind(_ value: Swift.Double?, column: Swift.Int)
  func bind(_ value: Swift.String?, column: Swift.Int)
  func get(_: Swift.Int.Type, column: Swift.Int) -> Swift.Int
  func get(_: Swift.UInt.Type, column: Swift.Int) -> Swift.UInt
  func get(_: Swift.Double.Type, column: Swift.Int) -> Swift.Double
  func get(_: Swift.String.Type, column: Swift.Int) -> Swift.String?
  @discardableResult
  func step() throws -> Swift.Bool
  func reset() throws
}
extension DevicesCore.SqliteStatement {
  @inlinable public func bind<T>(_ value: T?, column: Swift.Int) where T : Swift.RawRepresentable, T.RawValue == Swift.Int {
		bind(value?.rawValue, column: column)
	}
  @inlinable public func bind<T>(_ value: T?, column: Swift.Int) where T : Swift.RawRepresentable, T.RawValue == Swift.UInt {
		bind(value.map { Int($0.rawValue) }, column: column)
	}
  @inlinable public func bind<T>(_ value: T?, column: Swift.Int) where T : Swift.RawRepresentable, T.RawValue == Swift.String {
		bind(value?.rawValue, column: column)
	}
  @inlinable public func bind(_ value: Swift.Bool?, column: Swift.Int) {
		bind(value.map { $0 ? 1 : 0 }, column: column)
	}
  @inlinable public func get(column: Swift.Int) -> Swift.Int {
		get(Int.self, column: column)
	}
  @inlinable public func get(column: Swift.Int) -> Swift.Double {
		get(Double.self, column: column)
	}
  @inlinable public func get(_: Swift.Bool.Type = Bool.self, column: Swift.Int) -> Swift.Bool {
		get(Int.self, column: column) != 0
	}
  @inlinable public func get(column: Swift.Int) -> Swift.String? {
		get(String.self, column: column)
	}
  @inlinable public func get<T>(_: T.Type = T.self, column: Swift.Int) -> T? where T : Swift.RawRepresentable, T.RawValue == Swift.UInt {
		T(rawValue: get(UInt.self, column: column))
	}
  @inlinable public func get<T>(_: T.Type = T.self, column: Swift.Int) -> T? where T : Swift.RawRepresentable, T.RawValue == Swift.Int {
		T(rawValue: get(Int.self, column: column))
	}
  @inlinable public func get<T>(_: T.Type = T.self, column: Swift.Int) -> T? where T : Swift.RawRepresentable, T.RawValue == Swift.String {
		get(String.self, column: column).flatMap(T.init)
	}
}
public struct Stack<T> {
  public var isEmpty: Swift.Bool {
    get
  }
  public var count: Swift.Int {
    get
  }
  public init(_ array: [T] = [])
  public mutating func push(_ element: T)
  @discardableResult
  public mutating func pop() -> T?
  public func peek() -> T?
  public mutating func clean()
  public mutating func replace(_ element: T)
}
public enum StackPresentationMode {
  case top
  case bottom
  case center
  public static func == (a: DevicesCore.StackPresentationMode, b: DevicesCore.StackPresentationMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol StackScreen : DevicesCore.Screen {
  var flags: DevicesCore.Property<DevicesCore.StackScreenFlags> { get }
  var presentationMode: DevicesCore.StackPresentationMode { get }
  var sizeRestriction: DevicesCore.StackScreenSizeRestriction { get }
  func sizeThatFits(_ size: CoreFoundation.CGSize, safeAreaInsets: UIKit.UIEdgeInsets) -> CoreFoundation.CGSize
}
extension DevicesCore.StackScreen {
  public var flags: DevicesCore.Property<DevicesCore.StackScreenFlags> {
    get
  }
  public var presentationMode: DevicesCore.StackPresentationMode {
    get
  }
  public var sizeRestriction: DevicesCore.StackScreenSizeRestriction {
    get
  }
  public func sizeThatFits(_ size: CoreFoundation.CGSize, safeAreaInsets _: UIKit.UIEdgeInsets) -> CoreFoundation.CGSize
}
public struct StackScreenAdapter<Content> : DevicesCore.StackScreen where Content : UIKit.UIViewController {
  public typealias MeasureHandler = (_ size: CoreFoundation.CGSize, _ safeAreaInsets: UIKit.UIEdgeInsets) -> CoreFoundation.CGSize
  public let content: Content
  public let flags: DevicesCore.Property<DevicesCore.StackScreenFlags>
  public let measure: DevicesCore.StackScreenAdapter<Content>.MeasureHandler
  @inlinable public var viewController: UIKit.UIViewController {
    get {
		content
	}
  }
  public init(content: Content, flags: DevicesCore.Property<DevicesCore.StackScreenFlags> = .constant(StackScreenFlags()), measure: @escaping DevicesCore.StackScreenAdapter<Content>.MeasureHandler = { size, _ in size })
  public func sizeThatFits(_ size: CoreFoundation.CGSize, safeAreaInsets: UIKit.UIEdgeInsets) -> CoreFoundation.CGSize
}
public enum StackScreenFlagsTag {
}
public typealias StackScreenFlags = DevicesCore.KeyValueContext<DevicesCore.StackScreenFlagsTag>
public typealias StackScreenFlagsKey<Value> = DevicesCore.KeyValueContextKey<Value, DevicesCore.StackScreenFlagsTag>
extension DevicesCore.KeyValueContext where Tag == DevicesCore.StackScreenFlagsTag {
  public init(label: Swift.String = #fileID)
}
extension DevicesCore.KeyValueContextKey where Tag == DevicesCore.StackScreenFlagsTag {
  public static var availableOrientations: DevicesCore.StackScreenFlagsKey<UIKit.UIInterfaceOrientationMask> {
    get
  }
  public static var shouldHideStatusBar: DevicesCore.StackScreenFlagsKey<Swift.Bool> {
    get
  }
  public static var shouldShowAssistant: DevicesCore.StackScreenFlagsKey<Swift.Bool> {
    get
  }
}
public struct StackScreenInteractivity {
  public typealias VoidClosure = () -> Swift.Void
  public typealias ObserveAction = (DevicesCore.StackScreenInteractivity.ActionSource) -> Swift.Void
  public enum ActionSource : Swift.Equatable {
    case interactivityGesture
    case programCode
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DevicesCore.StackScreenInteractivity.ActionSource, b: DevicesCore.StackScreenInteractivity.ActionSource) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum PushCollisionBehaviour {
    case assert
    case assertTag
    public static func == (a: DevicesCore.StackScreenInteractivity.PushCollisionBehaviour, b: DevicesCore.StackScreenInteractivity.PushCollisionBehaviour) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct HideBehaviour : Swift.Equatable {
    public enum SwipeBehaviour : Swift.Equatable {
      case allContent
      case header(height: CoreFoundation.CGFloat)
      case disabled
      public static func == (a: DevicesCore.StackScreenInteractivity.HideBehaviour.SwipeBehaviour, b: DevicesCore.StackScreenInteractivity.HideBehaviour.SwipeBehaviour) -> Swift.Bool
    }
    public let shouldHideOnDimTap: Swift.Bool
    public let swipeBehaviour: DevicesCore.StackScreenInteractivity.HideBehaviour.SwipeBehaviour
    public init(shouldHideOnDimTap: Swift.Bool, swipeBehaviour: DevicesCore.StackScreenInteractivity.HideBehaviour.SwipeBehaviour)
    public static func == (a: DevicesCore.StackScreenInteractivity.HideBehaviour, b: DevicesCore.StackScreenInteractivity.HideBehaviour) -> Swift.Bool
  }
  public let hideBehaviour: DevicesCore.StackScreenInteractivity.HideBehaviour
  public let collisionBehaviour: DevicesCore.StackScreenInteractivity.PushCollisionBehaviour
  public var onWillOpen: DevicesCore.StackScreenInteractivity.VoidClosure?
  public var onDidOpen: DevicesCore.StackScreenInteractivity.VoidClosure?
  public var onPause: DevicesCore.StackScreenInteractivity.VoidClosure?
  public var onResume: DevicesCore.StackScreenInteractivity.VoidClosure?
  public var onWillClose: DevicesCore.StackScreenInteractivity.ObserveAction?
  public var onDetach: DevicesCore.StackScreenInteractivity.ObserveAction?
  public var onDidClose: DevicesCore.StackScreenInteractivity.ObserveAction?
  public init(hideBehaviour: DevicesCore.StackScreenInteractivity.HideBehaviour, collisionBehaviour: DevicesCore.StackScreenInteractivity.PushCollisionBehaviour = .assert, onWillOpen: DevicesCore.StackScreenInteractivity.VoidClosure? = nil, onDidOpen: DevicesCore.StackScreenInteractivity.VoidClosure? = nil, onPause: DevicesCore.StackScreenInteractivity.VoidClosure? = nil, onResume: DevicesCore.StackScreenInteractivity.VoidClosure? = nil, onWillClose: DevicesCore.StackScreenInteractivity.ObserveAction? = nil, onDetach: DevicesCore.StackScreenInteractivity.ObserveAction? = nil, onDidClose: DevicesCore.StackScreenInteractivity.ObserveAction? = nil)
}
extension DevicesCore.StackScreenInteractivity {
  public static let allGestures: DevicesCore.StackScreenInteractivity
  public static let nonInteractive: DevicesCore.StackScreenInteractivity
  public static func allGestures(onDidClose: DevicesCore.StackScreenInteractivity.ObserveAction? = nil) -> DevicesCore.StackScreenInteractivity
  public static func nonInteractive(onDidClose: DevicesCore.StackScreenInteractivity.ObserveAction? = nil) -> DevicesCore.StackScreenInteractivity
}
extension DevicesCore.StackScreenInteractivity.HideBehaviour {
  public static let allGestures: DevicesCore.StackScreenInteractivity.HideBehaviour
  public static let nonInteractive: DevicesCore.StackScreenInteractivity.HideBehaviour
  public static let onlySwipe: DevicesCore.StackScreenInteractivity.HideBehaviour
}
public enum StackScreenPresentation {
  case pageSheet
  case modal
  public static func == (a: DevicesCore.StackScreenPresentation, b: DevicesCore.StackScreenPresentation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol StackScreenPresenter : AnyObject {
  func prepend(_ screen: DevicesCore.StackScreen, tag: DevicesCore.StackScreenTag, interactivity: DevicesCore.StackScreenInteractivity, trigger: DevicesCore.StackScreenInteractivity.ActionSource)
  func push(_ screen: DevicesCore.StackScreen, tag: DevicesCore.StackScreenTag, interactivity: DevicesCore.StackScreenInteractivity, trigger: DevicesCore.StackScreenInteractivity.ActionSource)
  func pop(tag: DevicesCore.StackScreenTag, trigger: DevicesCore.StackScreenInteractivity.ActionSource)
  func dropAll(withTag: DevicesCore.StackScreenTag)
  func hasDisplayedScreen(withTag tag: DevicesCore.StackScreenTag) -> Swift.Bool
}
public struct StackScreenSizeRestriction {
  public let width: CoreFoundation.CGFloat?
  public let height: CoreFoundation.CGFloat?
}
extension DevicesCore.StackScreenSizeRestriction {
  public static func width(_ width: CoreFoundation.CGFloat) -> DevicesCore.StackScreenSizeRestriction
  public static func height(_ height: CoreFoundation.CGFloat) -> DevicesCore.StackScreenSizeRestriction
  public static var none: DevicesCore.StackScreenSizeRestriction {
    get
  }
}
public protocol StackScreenTag {
  var value: Swift.String { get }
}
extension DevicesCore.StackScreenTag where Self : Swift.RawRepresentable, Self.RawValue == Swift.String {
  public var value: Swift.String {
    get
  }
}
extension DevicesCore.StackScreenTag {
  public func isTagEqual(to tag: DevicesCore.StackScreenTag) -> Swift.Bool
}
public struct StagedChangeset<Collection> where Collection : Swift.Collection {
  @usableFromInline
  internal var changesets: Swift.ContiguousArray<DevicesCore.Changeset<Collection>>
  public init<C>(_ changesets: C) where C : Swift.Collection, C.Element == DevicesCore.Changeset<Collection>
}
extension DevicesCore.StagedChangeset : Swift.RandomAccessCollection, Swift.RangeReplaceableCollection, Swift.MutableCollection {
  public typealias Element = DevicesCore.Changeset<Collection>
  @inlinable public init() {
		self.init([])
	}
  @inlinable public var startIndex: Swift.Int {
    get {
		changesets.startIndex
	}
  }
  @inlinable public var endIndex: Swift.Int {
    get {
		changesets.endIndex
	}
  }
  @inlinable public func index(after i: Swift.Int) -> Swift.Int {
		changesets.index(after: i)
	}
  @inlinable public subscript(position: Swift.Int) -> DevicesCore.Changeset<Collection> {
    get { changesets[position] }
    set { changesets[position] = newValue }
  }
  @inlinable public mutating func replaceSubrange<C, R>(_ subrange: R, with newElements: C) where C : Swift.Collection, R : Swift.RangeExpression, C.Element == DevicesCore.Changeset<Collection>, R.Bound == Swift.Int {
		changesets.replaceSubrange(subrange, with: newElements)
	}
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = Swift.IndexingIterator<DevicesCore.StagedChangeset<Collection>>
  public typealias SubSequence = Swift.Slice<DevicesCore.StagedChangeset<Collection>>
}
extension DevicesCore.StagedChangeset : Swift.Equatable where Collection : Swift.Equatable {
  @inlinable public static func == (lhs: DevicesCore.StagedChangeset<Collection>, rhs: DevicesCore.StagedChangeset<Collection>) -> Swift.Bool {
		lhs.changesets == rhs.changesets
	}
}
extension DevicesCore.StagedChangeset : Swift.ExpressibleByArrayLiteral {
  @inlinable public init(arrayLiteral elements: DevicesCore.Changeset<Collection>...) {
		self.init(elements)
	}
  public typealias ArrayLiteralElement = DevicesCore.Changeset<Collection>
}
extension DevicesCore.StagedChangeset : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
final public class StaticURLFactory : DevicesCore.URLFactory {
  public init(assertionCaller: DevicesCore.AssertionCaller = assertionCallerShared)
  final public func makeURL(scheme: Swift.String?, host: Swift.String, port: Swift.Int?, path: Swift.String?, items: [Swift.String : Swift.String]?) throws -> Foundation.URL
  final public func makeURL(baseURL: Foundation.URL, items: [Swift.String : Swift.String]) throws -> Foundation.URL
  @objc deinit
}
final public class StaticURLRequestFactory : DevicesCore.URLRequestFactory {
  public init()
  final public func makeURLRequest(method: DevicesCore.HTTPMethod, url: Foundation.URL, headers: DevicesCore.Headers?, payload: Foundation.Data?) -> Foundation.URLRequest
  @objc deinit
}
extension Swift.String {
  public static let defaultObjectDescriptionOffset: Swift.String
  public static func makeObjectDescription(name: Swift.String, lines: [Swift.String], lineOffset: Swift.String = defaultObjectDescriptionOffset, additionalOffset: Swift.String?, lineBreak: Swift.String = "\n") -> Swift.String
  public var isValidURLScheme: Swift.Bool {
    get
  }
  public func makeAttributed(with attributes: [Foundation.NSAttributedString.Key : Any]?) -> Foundation.NSAttributedString
  public func makeMutableAttributed(with attributes: [Foundation.NSAttributedString.Key : Any]?) -> Foundation.NSMutableAttributedString
  public func toBase64() -> Swift.String
  public func toBase64URL(convertToBase64First: Swift.Bool) -> Swift.String
  public func fromBase64URL(to encoding: Swift.String.Encoding = .utf8) -> Swift.String?
  public func escapeJSONSpecialCharacters() -> Swift.String
  public func toNSString() -> Foundation.NSString
  public func utf8Data() -> Foundation.Data
  public func removing(prefixes: [Swift.String]) -> Swift.String
  public func removing(prefix: Swift.String) -> Swift.String
  public func removing(suffix: Swift.String) -> Swift.String
}
extension Swift.Optional where Wrapped == Swift.String {
  public static func + (lhs: Swift.String?, rhs: Swift.String?) -> Swift.String?
}
extension Swift.String {
  public func contains(in searchString: Swift.String, transliterators: [DevicesCore.Transliterator]) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class StringFileReader : DevicesCore.StringReader {
  convenience public init(url: Foundation.URL, delimeter: Swift.String, capacity: Swift.Int = 1_024, encoding: Swift.String.Encoding = .utf8, assertQueue: @escaping DevicesCore.DispatchQueueAssert) throws
  final public func next() throws -> Swift.String?
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class StringFileWriter : DevicesCore.StringWriter {
  convenience public init(url: Foundation.URL, delimeter: Swift.String, encoding: Swift.String.Encoding = .utf8, assertQueue: @escaping DevicesCore.DispatchQueueAssert) throws
  final public func write(_ value: Swift.String) throws
  @objc deinit
}
public protocol StringID {
  var key: Swift.String { get }
  var comment: Swift.String { get }
}
extension DevicesCore.StringID where Self : Swift.RawRepresentable, Self.RawValue == Swift.String {
  public var key: Swift.String {
    get
  }
  public var comment: Swift.String {
    get
  }
}
extension DevicesCore.StringID {
  public func isStringEqual(to stringID: DevicesCore.StringID) -> Swift.Bool
}
public protocol StringProvider {
  func getString(for id: DevicesCore.StringID) -> Swift.String?
}
extension DevicesCore.StringProvider {
  public func string(for id: DevicesCore.StringID) -> Swift.String
  @available(*, deprecated, message: "Используем ArgumentsStringID с передачей аргументов")
  public func string(for id: DevicesCore.PluralNounStringID, count: Swift.Int) -> Swift.String
  public func unavailableStringIdentifiers(for identifiers: [DevicesCore.StringID]) -> [DevicesCore.StringID]
  public func unavailableStringIdentifiers(for identifiers: [DevicesCore.PluralNounStringID]) -> [DevicesCore.PluralNounStringID]
}
public enum StringProviders {
  public static func bundle(_ bundle: Foundation.Bundle) -> DevicesCore.StringProvider
  public static func sequence(_ providers: [DevicesCore.StringProvider]) -> DevicesCore.StringProvider
}
public protocol StringReader {
  func next() throws -> Swift.String?
}
public struct StringSequenceProvider : DevicesCore.StringProvider {
  public init(providers: [DevicesCore.StringProvider])
  public func getString(for id: DevicesCore.StringID) -> Swift.String?
}
public protocol StringWriter {
  func write(_ value: Swift.String) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Subject {
  public func eraseToAnySubject() -> DevicesCore.AnySubject<Self.Output, Self.Failure>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
final public class AnySubject<Output, Failure> : Combine.Subject where Failure : Swift.Error {
  public typealias EventHandler = (Output) -> Swift.Void
  public typealias CompletionHandler = (Combine.Subscribers.Completion<Failure>) -> Swift.Void
  public typealias SubscriptionHandler = (Combine.Subscription) -> Swift.Void
  public typealias ReceiveHandler<S> = (S) -> Swift.Void where Output == S.Input, Failure == S.Failure, S : Combine.Subscriber
  final public func send(_ value: Output)
  final public func send(completion: Combine.Subscribers.Completion<Failure>)
  final public func send(subscription: Combine.Subscription)
  final public func receive<S>(subscriber: S) where Output == S.Input, Failure == S.Failure, S : Combine.Subscriber
  public init(eventHandler: @escaping DevicesCore.AnySubject<Output, Failure>.EventHandler, completionHandler: @escaping DevicesCore.AnySubject<Output, Failure>.CompletionHandler, subscriptionHandler: @escaping DevicesCore.AnySubject<Output, Failure>.SubscriptionHandler, receiveHandler: @escaping DevicesCore.AnySubject<Output, Failure>.ReceiveHandler<Combine.AnySubscriber<Output, Failure>>)
  @objc deinit
}
open class SubjectRequestInterceptor<Request, Response> : DevicesCore.RequestInterceptor<Request, Response> {
  @usableFromInline
  final internal let subject: DevicesCore.RequestInterceptor<Request, Response>
  public init(subject: DevicesCore.RequestInterceptor<Request, Response>)
  @inlinable override open func prepare(_ request: Request, cancelToken: DevicesCore.CancellationToken? = nil, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void) {
		subject.prepare(request, cancelToken: cancelToken, completion: completion)
	}
  @inlinable override open func send(_ urlRequest: Foundation.URLRequest, cancelToken: DevicesCore.CancellationToken? = nil, completion: @escaping (Swift.Result<DevicesCore.URLAnswer, Swift.Error>) -> Swift.Void) {
		subject.send(urlRequest, cancelToken: cancelToken, completion: completion)
	}
  @inlinable override open func parse(_ answer: DevicesCore.URLAnswer, cancelToken: DevicesCore.CancellationToken? = nil, completion: @escaping (Swift.Result<Response, Swift.Error>) -> Swift.Void) {
		subject.parse(answer, cancelToken: cancelToken, completion: completion)
	}
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SubscriberList<Subscriber> {
  public func append(_ subscriber: Subscriber)
  public func remove(_ subscriber: Subscriber)
  public func contains(_ subscriber: Subscriber) -> Swift.Bool
  public func forEach(_ body: (Subscriber?) throws -> Swift.Void) rethrows
  @objc deinit
}
extension DevicesCore.SubscriberList {
  convenience public init()
}
public enum SystemDeeplinkSchemes : Swift.String, Swift.CaseIterable {
  case tel
  case messages
  case mailto
  case contact
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DevicesCore.SystemDeeplinkSchemes]
  public typealias RawValue = Swift.String
  public static var allCases: [DevicesCore.SystemDeeplinkSchemes] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
final public class SystemTimerScheduler : DevicesCore.TimerScheduler {
  public init()
  final public func scheduledTimer(timeInterval: Foundation.TimeInterval, tolerance: Foundation.TimeInterval = 0, repeats: Swift.Bool = false, block: @escaping DevicesCore.TimerAction) -> DevicesCore.TimerType
  final public func scheduledTimer(timeInterval: Foundation.TimeInterval, tolerance: Foundation.TimeInterval, repeats: Swift.Bool, runLoop: Foundation.RunLoop, runLoopMode: Foundation.RunLoop.Mode, block: @escaping DevicesCore.TimerAction) -> DevicesCore.TimerType
  @objc deinit
}
final public class TLSSession : DevicesCore.NetworkSession {
  public init(challengeReceiver: DevicesCore.SecurityChallengeReceiver, configuration: Foundation.URLSessionConfiguration = .default, needVerify: DevicesCore.Property<Swift.Bool>)
  convenience public init(logger: DevicesCore.Logger, configuration: Foundation.URLSessionConfiguration = .default, trustDirective: DevicesCore.TrustVerifier, needVerify: DevicesCore.Property<Swift.Bool>)
  final public func dataTask(request: Foundation.URLRequest, completion: @escaping (Foundation.Data?, Foundation.URLResponse?, Swift.Error?) -> Swift.Void) -> DevicesCore.NetworkTask
  final public func downloadTask(request: Foundation.URLRequest, completion: @escaping (Foundation.URL?, Foundation.URLResponse?, Swift.Error?) -> Swift.Void) -> DevicesCore.NetworkTask
  final public func clearCookies(since date: Foundation.Date)
  @objc deinit
}
public struct Tagged<Tag, T> {
  public typealias Tag = Tag
  public typealias Value = T
  public var value: T
  public init(value: T)
}
extension DevicesCore.Tagged : Swift.RawRepresentable {
  public var rawValue: T {
    get
  }
  public init?(rawValue: T)
  public typealias RawValue = T
}
extension DevicesCore.Tagged : Swift.Equatable where T : Swift.Equatable {
}
extension DevicesCore.Tagged : Swift.Hashable where T : Swift.Hashable {
}
extension DevicesCore.Tagged : Swift.Comparable where T : Swift.Comparable {
  public static func < (lhs: DevicesCore.Tagged<Tag, T>, rhs: DevicesCore.Tagged<Tag, T>) -> Swift.Bool
}
extension DevicesCore.Tagged : Swift.Codable where T : Swift.Decodable, T : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension DevicesCore.Tagged : Swift.ExpressibleByStringLiteral where T : Swift.ExpressibleByStringLiteral {
  public typealias StringLiteralType = T.StringLiteralType
  public init(stringLiteral value: DevicesCore.Tagged<Tag, T>.StringLiteralType)
}
extension DevicesCore.Tagged : Swift.ExpressibleByIntegerLiteral where T : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = T.IntegerLiteralType
  public init(integerLiteral value: DevicesCore.Tagged<Tag, T>.IntegerLiteralType)
}
extension DevicesCore.Tagged : Swift.ExpressibleByFloatLiteral where T : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = T.FloatLiteralType
  public init(floatLiteral value: DevicesCore.Tagged<Tag, T>.FloatLiteralType)
}
extension DevicesCore.Tagged : Swift.ExpressibleByUnicodeScalarLiteral where T : Swift.ExpressibleByUnicodeScalarLiteral {
  public typealias UnicodeScalarLiteralType = T.UnicodeScalarLiteralType
  public init(unicodeScalarLiteral value: DevicesCore.Tagged<Tag, T>.UnicodeScalarLiteralType)
}
extension DevicesCore.Tagged : Swift.ExpressibleByExtendedGraphemeClusterLiteral where T : Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = T.ExtendedGraphemeClusterLiteralType
  public init(extendedGraphemeClusterLiteral value: DevicesCore.Tagged<Tag, T>.ExtendedGraphemeClusterLiteralType)
}
extension DevicesCore.Tagged : Swift.ExpressibleByBooleanLiteral where T : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = T.BooleanLiteralType
  public init(booleanLiteral value: DevicesCore.Tagged<Tag, T>.BooleanLiteralType)
}
extension DevicesCore.Tagged : Swift.CustomStringConvertible where T : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension DevicesCore.Tagged {
  @inlinable public func retag<NewTag>(_: NewTag.Type = NewTag.self) -> DevicesCore.Tagged<NewTag, DevicesCore.Tagged<Tag, T>.RawValue> {
		Tagged<NewTag, _>(value: rawValue)
	}
}
extension DevicesCore.Tagged where T : Swift.Collection {
  public var nonEmpty: DevicesCore.Tagged<Tag, T>? {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
}
open class TaggedDeeplinkService<Tag> : DevicesCore.TaggedDeeplinkServicing {
  @discardableResult
  open func handle(_: DevicesCore.Tagged<Tag, DevicesCore.Deeplink>) -> Swift.Bool
  public init()
  @objc deinit
}
public protocol TaggedDeeplinkServicing {
  associatedtype Tag
  @discardableResult
  func handle(_ deeplink: DevicesCore.Tagged<Self.Tag, DevicesCore.Deeplink>) -> Swift.Bool
}
public enum TapticFeedback : Swift.Equatable {
  case success
  case error
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesCore.TapticFeedback, b: DevicesCore.TapticFeedback) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
final public class TargetActionAdapter {
  public init(action: @escaping () -> Swift.Void)
  @objc final public func handleTap()
  final public func addTarget(to control: UIKit.UIControl, for event: UIKit.UIControl.Event)
  final public func removeTarget(from control: UIKit.UIControl, for event: UIKit.UIControl.Event)
  final public func addTarget(to recognizer: UIKit.UIGestureRecognizer)
  @objc deinit
}
public struct DetectionOptions : Swift.OptionSet {
  public static let links: DevicesCore.DetectionOptions
  public static let all: DevicesCore.DetectionOptions
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = DevicesCore.DetectionOptions
  public typealias Element = DevicesCore.DetectionOptions
  public typealias RawValue = Swift.Int
}
final public class TextDataDetector {
  public init(detectionStyle: DevicesCore.DetectionStyle)
  final public func detect(data: DevicesCore.DetectionOptions, in text: Foundation.NSAttributedString) -> Foundation.NSAttributedString
  final public func getAllURL(in text: Foundation.NSAttributedString) -> [Foundation.URL]
  @objc deinit
}
extension DevicesCore.DetectionOptions : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
}
public struct ThematicBreakAttribute {
  public var thickness: CoreFoundation.CGFloat
  public var color: UIKit.UIColor
}
extension Foundation.NSAttributedString.Key {
  public static let thematicBreak: Foundation.NSAttributedString.Key
}
extension Swift.Double {
  public static let millisecond: Swift.Double
  public static let second: Swift.Double
  public static let minute: Swift.Double
  public static let fiveMinutes: Swift.Double
  public static let tenMinutes: Swift.Double
  public static let hour: Swift.Double
  public static let day: Swift.Double
  public static let week: Swift.Double
  public static let month: Swift.Double
}
public typealias TimerAction = (DevicesCore.TimerType) -> Swift.Void
public protocol TimerScheduler {
  func scheduledTimer(timeInterval: Foundation.TimeInterval, tolerance: Foundation.TimeInterval, repeats: Swift.Bool, block: @escaping DevicesCore.TimerAction) -> DevicesCore.TimerType
  func scheduledTimer(timeInterval: Foundation.TimeInterval, tolerance: Foundation.TimeInterval, repeats: Swift.Bool, runLoop: Foundation.RunLoop, runLoopMode: Foundation.RunLoop.Mode, block: @escaping DevicesCore.TimerAction) -> DevicesCore.TimerType
}
public protocol TimerType {
  var timeInterval: Foundation.TimeInterval { get }
  var tolerance: Foundation.TimeInterval { get set }
  var isValid: Swift.Bool { get }
  func fire()
  func invalidate()
}
extension Foundation.Timer : DevicesCore.TimerType {
}
public class TimestampModifier : DevicesCore.LogModifier {
  public static func makeFormatter(dateFormat: Swift.String = "dd.MM.yyyy HH:mm:ss.SSS", timeZone: Foundation.TimeZone = .current) -> Foundation.DateFormatter
  public init(dateProvider: @autoclosure @escaping () -> Foundation.Date = Date(), dateFormat: Swift.String = "dd.MM.yyyy HH:mm:ss.SSS", timeZone: Foundation.TimeZone = .current)
  public func modifyMessage(_ message: DevicesCore.LogMessage, with _: DevicesCore.LogLevel, file _: Swift.String, line _: Swift.Int) -> DevicesCore.LogMessage
  @objc deinit
}
public typealias TimestampProvider = () -> Foundation.TimeInterval
public func makeCurrentTimestamp() -> Foundation.TimeInterval
public protocol Transliterator {
  func cyrillicToLatynic(inputString: Swift.String) -> Swift.String
  func latynicToCyrillic(inputString: Swift.String) -> Swift.String
}
final public class TransliteratorImpl : DevicesCore.Transliterator {
  public init()
  final public func cyrillicToLatynic(inputString: Swift.String) -> Swift.String
  final public func cyrillicToLatynic(inputChar: Swift.Character) -> Swift.String
  final public func latynicToCyrillic(inputString: Swift.String) -> Swift.String
  final public func latynicToCyrillic(inputChar: Swift.Character) -> Swift.String
  @objc deinit
}
@available(*, deprecated, message: "Use TrustVerifier")
public typealias TrustDefaultVerifier = DevicesCore.TrustVerifier
public protocol TrustVerifier {
  func validate(_ trust: Security.SecTrust, domain: Swift.String?) throws
}
extension DevicesCore.TrustVerifier {
  public func isValid(_ trust: Security.SecTrust, domain: Swift.String?) -> Swift.Bool
}
public enum TrustVerifiers {
  public static func domains(_ domains: [Swift.String : [DevicesCore.Certificate]] = [:], global: [DevicesCore.Certificate] = [], isPinningOn: Swift.Bool = false) -> DevicesCore.TrustVerifier
}
public protocol UIAccessibilityTwin {
  static func screenChanged(accessibilityLabel: Swift.String?)
}
extension UIKit.UIAccessibility : DevicesCore.UIAccessibilityTwin {
  public static func screenChanged(accessibilityLabel: Swift.String?)
}
public protocol UIApplicationTwin {
  static var openSettingsURLString: Swift.String { get }
  func canOpenURL(_ url: Foundation.URL) -> Swift.Bool
  func open(_ url: Foundation.URL, options: [UIKit.UIApplication.OpenExternalURLOptionsKey : Any], completionHandler completion: ((Swift.Bool) -> Swift.Void)?)
}
extension UIKit.UIApplication : DevicesCore.UIApplicationTwin {
}
extension UIKit.UICollectionView {
  @_Concurrency.MainActor(unsafe) public func registerCell<T>(of type: T.Type) where T : UIKit.UICollectionViewCell
  @_Concurrency.MainActor(unsafe) public func dequeueReusableCell<T>(_ type: T.Type, for indexPath: Foundation.IndexPath) -> T where T : UIKit.UICollectionViewCell
  @_Concurrency.MainActor(unsafe) public func registerSupplementaryView<T>(_ type: T.Type, forSupplementaryViewOfKind kind: Swift.String) where T : UIKit.UICollectionReusableView
  @_Concurrency.MainActor(unsafe) public func dequeueSupplementaryView<T>(_ type: T.Type, ofKind kind: Swift.String, for indexPath: Foundation.IndexPath) -> T where T : UIKit.UICollectionReusableView
}
extension UIKit.UIColor {
  convenience public init(hex: Swift.Int64)
}
public protocol UIDeviceTwin : AnyObject {
  var orientation: UIKit.UIDeviceOrientation { get }
  var proximityState: Swift.Bool { get }
  var isProximityMonitoringEnabled: Swift.Bool { get set }
  func beginGeneratingDeviceOrientationNotifications()
  func endGeneratingDeviceOrientationNotifications()
}
public protocol DeviceOrientationUpdater : DevicesCore.UIDeviceTwin {
  func rotate(to orientation: UIKit.UIDeviceOrientation)
}
extension UIKit.UIDevice : DevicesCore.DeviceOrientationUpdater {
  @_Concurrency.MainActor(unsafe) public func rotate(to orientation: UIKit.UIDeviceOrientation)
}
public enum DeviceIDTag {
}
public typealias DeviceID = DevicesCore.Tagged<DevicesCore.DeviceIDTag, Foundation.UUID>
extension UIKit.UIDevice {
  @_Concurrency.MainActor(unsafe) public var deviceModel: Swift.String {
    get
  }
  @_Concurrency.MainActor(unsafe) public var deviceID: DevicesCore.DeviceID? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var type: Swift.String {
    get
  }
}
extension UIKit.UIEdgeInsets {
  public var horizontalInsetsSum: CoreFoundation.CGFloat {
    get
  }
  public var verticalInsetsSum: CoreFoundation.CGFloat {
    get
  }
  public var insetsSum: CoreFoundation.CGSize {
    get
  }
  public init(inset: CoreFoundation.CGFloat)
  public init(left: CoreFoundation.CGFloat, right: CoreFoundation.CGFloat)
  public init(top: CoreFoundation.CGFloat = 0, bottom: CoreFoundation.CGFloat = 0)
  public init(horizontal: CoreFoundation.CGFloat = 0, vertical: CoreFoundation.CGFloat = 0)
  prefix public static func - (insets: UIKit.UIEdgeInsets) -> UIKit.UIEdgeInsets
  public static func + (lhs: UIKit.UIEdgeInsets, rhs: UIKit.UIEdgeInsets) -> UIKit.UIEdgeInsets
  public static func - (lhs: UIKit.UIEdgeInsets, rhs: UIKit.UIEdgeInsets) -> UIKit.UIEdgeInsets
  public static func -= (lhs: inout UIKit.UIEdgeInsets, rhs: UIKit.UIEdgeInsets)
  public static func += (lhs: inout UIKit.UIEdgeInsets, rhs: UIKit.UIEdgeInsets)
}
extension UIKit.UIEdgeInsets : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension UIKit.UIGestureRecognizer {
  @_Concurrency.MainActor(unsafe) public func cancel()
}
extension UIKit.UIImage {
  public static func colored(_ color: UIKit.UIColor, size: CoreFoundation.CGSize = CGSize(square: 1.0)) -> UIKit.UIImage
  public func resize(to targetSize: CoreFoundation.CGSize) -> UIKit.UIImage?
  public func crop(to rect: CoreFoundation.CGRect) -> UIKit.UIImage?
  public func cropToSquare() -> UIKit.UIImage?
}
public protocol UIImageFactory {
  func makeUIImage(from data: Foundation.Data, contentType: Swift.String?, completion: @escaping (Swift.Result<UIKit.UIImage, Swift.Error>) -> Swift.Void)
}
final public class UIImageFactoryImpl : DevicesCore.UIImageFactory {
  public init(animatedImageFactory: DevicesCore.AnimatedImageFactory)
  final public func makeUIImage(from data: Foundation.Data, contentType: Swift.String?, completion: @escaping (Swift.Result<UIKit.UIImage, Swift.Error>) -> Swift.Void)
  @objc deinit
}
extension UIKit.UIEdgeInsets : DevicesCore.Configurable {
}
extension UIKit.UITableView {
  @_Concurrency.MainActor(unsafe) public func reload<C>(using stagedChangeset: DevicesCore.StagedChangeset<C>, with animation: @autoclosure () -> UIKit.UITableView.RowAnimation, interrupt: ((DevicesCore.Changeset<C>) -> Swift.Bool)? = nil, setData: (C) -> Swift.Void) where C : Swift.Collection
  @_Concurrency.MainActor(unsafe) public func reload<C>(using stagedChangeset: DevicesCore.StagedChangeset<C>, deleteSectionsAnimation: @autoclosure () -> UIKit.UITableView.RowAnimation, insertSectionsAnimation: @autoclosure () -> UIKit.UITableView.RowAnimation, reloadSectionsAnimation: @autoclosure () -> UIKit.UITableView.RowAnimation, deleteRowsAnimation: @autoclosure () -> UIKit.UITableView.RowAnimation, insertRowsAnimation: @autoclosure () -> UIKit.UITableView.RowAnimation, reloadRowsAnimation: @autoclosure () -> UIKit.UITableView.RowAnimation, interrupt: ((DevicesCore.Changeset<C>) -> Swift.Bool)? = nil, setData: (C) -> Swift.Void) where C : Swift.Collection
}
extension UIKit.UICollectionView {
  @_Concurrency.MainActor(unsafe) public func reload<C>(using stagedChangeset: DevicesCore.StagedChangeset<C>, interrupt: ((DevicesCore.Changeset<C>) -> Swift.Bool)? = nil, setData: (C) -> Swift.Void, completion: ((Swift.Bool) -> Swift.Void)? = nil) where C : Swift.Collection
}
extension UIKit.UITableView {
  @_Concurrency.MainActor(unsafe) public func registerCell<T>(_ type: T.Type) where T : UIKit.UITableViewCell
  @_Concurrency.MainActor(unsafe) public func dequeueReusableCell<T>(_ type: T.Type = T.self, indexPath: Foundation.IndexPath) -> T where T : UIKit.UITableViewCell
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func startRotation(duration: CoreFoundation.CFTimeInterval = 1)
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public func add(_ child: UIKit.UIViewController, in subview: UIKit.UIView? = nil)
  @_Concurrency.MainActor(unsafe) public func remove()
}
extension UIKit.UIViewController {
  @inlinable @_Concurrency.MainActor(unsafe) public var originalSafeInsets: UIKit.UIEdgeInsets {
    get {
		view.safeAreaInsets - additionalSafeAreaInsets
	}
  }
  @inlinable @_Concurrency.MainActor(unsafe) public func setSafeInsets(top: CoreFoundation.CGFloat? = nil, bottom: CoreFoundation.CGFloat? = nil, left: CoreFoundation.CGFloat? = nil, right: CoreFoundation.CGFloat? = nil) {
		let original = originalSafeInsets
		let totalInsets = UIEdgeInsets(
			top: top ?? original.top,
			left: left ?? original.left,
			bottom: bottom ?? original.bottom,
			right: right ?? original.right
		)

		additionalSafeAreaInsets = totalInsets - originalSafeInsets
	}
}
extension DevicesCore.Screen where Self : UIKit.UIViewController {
  @inlinable public var viewController: UIKit.UIViewController {
    get { self }
  }
}
extension UIKit.UIWindow {
  @_Concurrency.MainActor(unsafe) public static let debugInfoWindow: UIKit.UIWindow
}
extension Swift.UInt {
  @inlinable @inline(__always) public var _firstSetBit: Swift.UInt? {
    get {
		guard self != 0 else { return nil }
		let v = UInt.bitWidth &- 1 &- self.leadingZeroBitCount
		return UInt(truncatingIfNeeded: v)
	}
  }
  @inlinable @inline(__always) public var _lastSetBit: Swift.UInt? {
    get {
		guard self != 0 else { return nil }
		return UInt(truncatingIfNeeded: self.trailingZeroBitCount)
	}
  }
}
extension Swift.UInt {
  @inlinable public var _reversed: Swift.UInt {
    get {
		// https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel
		var shift = UInt(UInt.bitWidth)
		var mask: UInt = ~0
		var result = self
		while true {
			shift &>>= 1
			guard shift > 0 else { break }
			mask ^= mask &<< shift
			result = ((result &>> shift) & mask) | ((result &<< shift) & ~mask)
		}
		return result
	}
  }
}
extension UserNotifications.UNAuthorizationStatus {
  public func asAuthorizationStatus() -> DevicesCore.AuthorizationStatus
}
extension UserNotifications.UNNotificationRequest : DevicesCore.PrettyStringConvertible {
  public func makePrettyDescription(additionalOffset: Swift.String?) -> Swift.String
}
extension UserNotifications.UNNotificationContent : DevicesCore.PrettyStringConvertible {
  public func makePrettyDescription(additionalOffset: Swift.String?) -> Swift.String
}
extension UserNotifications.UNUserNotificationCenter {
  public func asUserNotificationCenter() -> DevicesCore.UserNotificationCenter
}
extension Foundation.URL : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral string: Swift.StaticString)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StaticString
  public typealias StringLiteralType = Swift.StaticString
  public typealias UnicodeScalarLiteralType = Swift.StaticString
}
extension Foundation.URL {
  public static let stub: Foundation.URL
  public var components: Foundation.URLComponents? {
    get
  }
  public var items: [Swift.String : Swift.String]? {
    get
  }
}
extension Foundation.URL {
  public func withItems(_ items: [Swift.String : Swift.String]) -> Foundation.URL?
  public func addingItems(_ items: [Swift.String : Swift.String]) -> Foundation.URL
}
extension Foundation.URL {
  public var withoutPathAndQuery: Foundation.URL? {
    get
  }
}
extension Foundation.URL : Swift.RawRepresentable {
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
extension Foundation.URL {
  public func getParameterValue<T>(type _: T.Type = T.self, parameterName: Swift.String) -> T? where T : Swift.RawRepresentable
}
extension Foundation.URL {
  public var isHttps: Swift.Bool {
    get
  }
  public func hasHost(from whitelist: DevicesCore.Whitelist, allowThirdLevelURLs: Swift.Bool = false) -> Swift.Bool
}
extension Foundation.URL {
  public init?(addingPercentEncodingTo string: Swift.String)
}
extension Foundation.URL : DevicesCore.PrettyStringConvertible {
  public func makePrettyDescription(additionalOffset: Swift.String?) -> Swift.String
}
public struct URLAnswer : Swift.Equatable, DevicesCore.PrettyStringConvertible, Swift.Codable {
  public let body: Foundation.Data
  public let httpCode: Swift.Int?
  public let httpHeaders: [DevicesCore.HTTPHeaderName : Swift.String]?
  public init(body: Foundation.Data, httpCode: Swift.Int?, httpHeaders: [DevicesCore.HTTPHeaderName : Swift.String]?)
  public static func == (a: DevicesCore.URLAnswer, b: DevicesCore.URLAnswer) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension DevicesCore.URLAnswer {
  public enum Error : Foundation.LocalizedError {
    case nonHTTPResponse
    public var errorDescription: Swift.String? {
      get
    }
    public static func == (a: DevicesCore.URLAnswer.Error, b: DevicesCore.URLAnswer.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var httpResult: Swift.Result<DevicesCore.HTTPResponse, Swift.Error> {
    get
  }
  public func httpResponse() throws -> DevicesCore.HTTPResponse
  public init(httpError: DevicesCore.HTTPError)
  public init(httpResponse: DevicesCore.HTTPResponse)
}
extension Foundation.URLAuthenticationChallenge {
  public func performDefaultHandling(completionHandler: (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
extension Foundation.URLComponents {
  public var items: [Foundation.URLQueryItem]? {
    get
  }
  public var keyedItems: [Swift.String : Swift.String]? {
    get
    set
  }
}
public enum URLContextTag {
}
public typealias URLContext = DevicesCore.KeyValueContext<DevicesCore.URLContextTag>
public typealias URLContextKey<Value> = DevicesCore.KeyValueContextKey<Value, DevicesCore.URLContextTag>
extension DevicesCore.KeyValueContext where Tag == DevicesCore.URLContextTag {
  public init(label: Swift.String = #fileID)
}
public protocol URLDownloadPerformer {
  func download(_ request: Foundation.URLRequest, cancelToken: DevicesCore.CancellationToken?, completion: @escaping (Swift.Result<DevicesCore.DownloadURLAnswer, Swift.Error>) -> Swift.Void)
}
extension DevicesCore.URLDownloadPerformer {
  @discardableResult
  public func downloadRequest(_ request: Foundation.URLRequest, completion: @escaping (Swift.Result<DevicesCore.DownloadURLAnswer, Swift.Error>) -> Swift.Void) -> DevicesCore.Cancellable
}
final public class URLDownloadPerformerImpl : DevicesCore.URLDownloadPerformer {
  public init(session: DevicesCore.NetworkSession = URLSession.shared)
  final public func download(_ request: Foundation.URLRequest, cancelToken: DevicesCore.CancellationToken?, completion: @escaping (Swift.Result<DevicesCore.DownloadURLAnswer, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public protocol URLFactory {
  func makeURL(scheme: Swift.String?, host: Swift.String, port: Swift.Int?, path: Swift.String?, items: [Swift.String : Swift.String]?) throws -> Foundation.URL
  func makeURL(baseURL: Foundation.URL, items: [Swift.String : Swift.String]) throws -> Foundation.URL
}
extension DevicesCore.URLHandler {
  public func showingConfirmationDialog(using block: @escaping (DevicesCore.URLHandlerConfirmationUIConfig) -> Swift.Void) -> DevicesCore.URLHandler
}
public struct URLHandlerConfirmationUIConfig {
  public let url: Foundation.URL
  public let context: DevicesCore.URLContext
  public let onAccept: () -> Swift.Void
  public let onDeny: () -> Swift.Void
  public init(url: Foundation.URL, context: DevicesCore.URLContext, onAccept: @escaping () -> Swift.Void, onDeny: @escaping () -> Swift.Void)
}
extension DevicesCore.URLHandler {
  public func showingErrorDialog(using block: @escaping (DevicesCore.URLHandlerErrorUIConfig) -> Swift.Void) -> DevicesCore.URLHandler
}
public struct URLHandlerErrorUIConfig {
  public let url: Foundation.URL
  public let context: DevicesCore.URLContext
  public let onDidClose: () -> Swift.Void
  public init(url: Foundation.URL, context: DevicesCore.URLContext, onDidClose: @escaping () -> Swift.Void)
}
extension DevicesCore.URLHandler {
  public func logging(logger: DevicesCore.Logger) -> DevicesCore.URLHandler
}
extension Swift.Array where Element == DevicesCore.URLHandler {
  public func sequenceHandler() -> DevicesCore.SequenceURLHandler
}
final public class SequenceURLHandler : DevicesCore.URLHandler {
  public init(_ children: [DevicesCore.URLHandler])
  final public func openURL(_ url: Foundation.URL, context: DevicesCore.URLContext, completion: @escaping (DevicesCore.URLHandlerResult) -> Swift.Void)
  final public func canOpen(_ url: Foundation.URL) -> Swift.Bool
  final public func openIfCan(_ url: Foundation.URL, label _: Swift.String) -> Swift.Bool
  @objc deinit
}
public protocol URLHandler : AnyObject {
  func openURL(_ url: Foundation.URL, context: DevicesCore.URLContext, completion: @escaping (DevicesCore.URLHandlerResult) -> Swift.Void)
  func canOpen(_ url: Foundation.URL) -> Swift.Bool
  func openIfCan(_ url: Foundation.URL, label: Swift.String) -> Swift.Bool
}
extension DevicesCore.URLHandler {
  public func openURL(_ url: Foundation.URL, label: Swift.String = #fileID)
  public func openIfCan(_ url: Foundation.URL, label: Swift.String = #fileID) -> Swift.Bool
}
extension UIKit.UIApplication : DevicesCore.URLHandler {
  @_Concurrency.MainActor(unsafe) public func openURL(_ url: Foundation.URL, context _: DevicesCore.URLContext, completion: @escaping (DevicesCore.URLHandlerResult) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func canOpen(_ url: Foundation.URL) -> Swift.Bool
}
public enum URLHandlerResult {
  case opened
  case userDenied
  case notSupported
  public static func == (a: DevicesCore.URLHandlerResult, b: DevicesCore.URLHandlerResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.URLRequest {
  public mutating func setHeader(_ fields: [Swift.String : Swift.String])
}
extension Foundation.URLRequest : DevicesCore.PrettyStringConvertible {
  public func makePrettyDescription(additionalOffset: Swift.String?) -> Swift.String
}
public protocol URLRequestFactory {
  func makeURLRequest(method: DevicesCore.HTTPMethod, url: Foundation.URL, headers: DevicesCore.Headers?, payload: Foundation.Data?) -> Foundation.URLRequest
}
public protocol URLRequestPerformer {
  func perform(_ request: Foundation.URLRequest, cancelToken: DevicesCore.CancellationToken?, completion: @escaping (Swift.Result<DevicesCore.URLAnswer, Swift.Error>) -> Swift.Void)
}
extension DevicesCore.URLRequestPerformer {
  @discardableResult
  public func performRequest(_ request: Foundation.URLRequest, completion: @escaping (Swift.Result<DevicesCore.HTTPResponse, Swift.Error>) -> Swift.Void) -> DevicesCore.Cancellable
}
public struct URLRequestPerformerConfig {
  public init(session: DevicesCore.NetworkSession, targetQueue: DevicesCore.AsyncPerformer)
}
public typealias URLRequestPerformerFactory = DevicesCore.Factory<DevicesCore.URLRequestPerformerConfig, DevicesCore.URLRequestPerformer>
extension DevicesCore.Factory where Arg == DevicesCore.URLRequestPerformerConfig, Item == DevicesCore.URLRequestPerformer {
  public static func `default`() -> DevicesCore.URLRequestPerformerFactory
}
final public class URLRequestPerformerImpl : DevicesCore.URLRequestPerformer {
  public init(session: DevicesCore.NetworkSession = URLSession.shared, targetQueue: DevicesCore.AsyncPerformer = DispatchQueue.main)
  final public func perform(_ request: Foundation.URLRequest, cancelToken: DevicesCore.CancellationToken?, completion: @escaping (Swift.Result<DevicesCore.URLAnswer, Swift.Error>) -> Swift.Void)
  @objc deinit
}
extension Foundation.URLSession : DevicesCore.NetworkSession {
  public func dataTask(request: Foundation.URLRequest, completion: @escaping (Foundation.Data?, Foundation.URLResponse?, Swift.Error?) -> Swift.Void) -> DevicesCore.NetworkTask
  public func downloadTask(request: Foundation.URLRequest, completion: @escaping (Foundation.URL?, Foundation.URLResponse?, Swift.Error?) -> Swift.Void) -> DevicesCore.NetworkTask
}
extension Foundation.URLSessionTask : DevicesCore.NetworkTask {
}
final public class UnfairLock {
  public init()
  @objc deinit
  final public func synchronized<T>(_: () -> T) -> T where T : AnyObject
  final public func synchronized<T>(_ block: () -> T) -> T
}
extension Swift.UnsafeBufferPointer {
  @inlinable @inline(__always) public func _ptr(at index: Swift.Int) -> Swift.UnsafePointer<Element> {
		assert(index >= 0 && index < count)
		return baseAddress.unsafelyUnwrapped + index
	}
}
final public class UnsafeChallengeReceiver : DevicesCore.SecurityChallengeReceiver {
  public init()
  final public func receiveChallenge(_ challenge: Foundation.URLAuthenticationChallenge, task _: DevicesCore.NetworkTask?, completion: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc deinit
}
extension Swift.UnsafeMutableBufferPointer {
  @inlinable public func initialize(fromContentsOf source: Swift.UnsafeMutableBufferPointer<Element>) -> Swift.UnsafeMutableBufferPointer<Element>.Index {
		guard !source.isEmpty else { return 0 }
		precondition(
			source.count <= self.count,
			"buffer cannot contain every element from source."
		)
		baseAddress.unsafelyUnwrapped.initialize(
			from: source.baseAddress.unsafelyUnwrapped,
			count: source.count
		)
		return source.count
	}
  @inlinable public func initialize(fromContentsOf source: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) -> Swift.UnsafeMutableBufferPointer<Element>.Index {
		let sourceCount = source.count
		guard sourceCount > 0 else { return 0 }
		precondition(
			sourceCount <= self.count,
			"buffer cannot contain every element from source."
		)
		baseAddress.unsafelyUnwrapped.initialize(
			from: source.base.baseAddress.unsafelyUnwrapped + source.startIndex,
			count: sourceCount
		)
		return sourceCount
	}
}
extension Swift.Slice {
  @inlinable @inline(__always) public func initialize<Element>(fromContentsOf source: Swift.UnsafeMutableBufferPointer<Element>) -> Swift.Slice<Base>.Index where Base == Swift.UnsafeMutableBufferPointer<Element> {
		let target = UnsafeMutableBufferPointer(rebasing: self)
		let i = target.initialize(fromContentsOf: source)
		return self.startIndex + i
	}
  @inlinable @inline(__always) public func initialize<Element>(fromContentsOf source: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) -> Swift.Slice<Base>.Index where Base == Swift.UnsafeMutableBufferPointer<Element> {
		let target = UnsafeMutableBufferPointer(rebasing: self)
		let i = target.initialize(fromContentsOf: source)
		return self.startIndex + i
	}
}
extension Swift.UnsafeMutableBufferPointer {
  @inlinable @inline(__always) public func initializeAll<C>(fromContentsOf source: C) where Element == C.Element, C : Swift.Collection {
		let i = self.initialize(fromContentsOf: source)
		assert(i == self.endIndex)
	}
  @inlinable @inline(__always) public func initializeAll(fromContentsOf source: Swift.UnsafeMutableBufferPointer<Element>) {
		let i = self.initialize(fromContentsOf: source)
		assert(i == self.endIndex)
	}
  @inlinable @inline(__always) public func initializeAll(fromContentsOf source: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) {
		let i = self.initialize(fromContentsOf: source)
		assert(i == self.endIndex)
	}
  @inlinable @inline(__always) public func moveInitializeAll(fromContentsOf source: Swift.UnsafeMutableBufferPointer<Element>) {
		let i = self.moveInitialize(fromContentsOf: source)
		assert(i == self.endIndex)
	}
  @inlinable @inline(__always) public func moveInitializeAll(fromContentsOf source: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) {
		let i = self.moveInitialize(fromContentsOf: source)
		assert(i == self.endIndex)
	}
}
extension Swift.Slice {
  @inlinable @inline(__always) public func initializeAll<C>(fromContentsOf source: C) where Base == Swift.UnsafeMutableBufferPointer<C.Element>, C : Swift.Collection {
		let i = self.initialize(fromContentsOf: source)
		assert(i == self.endIndex)
	}
  @inlinable @inline(__always) public func initializeAll<Element>(fromContentsOf source: Swift.UnsafeMutableBufferPointer<Element>) where Base == Swift.UnsafeMutableBufferPointer<Element> {
		let target = UnsafeMutableBufferPointer(rebasing: self)
		target.initializeAll(fromContentsOf: source)
	}
  @inlinable @inline(__always) public func initializeAll<Element>(fromContentsOf source: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) where Base == Swift.UnsafeMutableBufferPointer<Element> {
		let target = UnsafeMutableBufferPointer(rebasing: self)
		target.initializeAll(fromContentsOf: source)
	}
  @inlinable @inline(__always) public func moveInitializeAll<Element>(fromContentsOf source: Swift.UnsafeMutableBufferPointer<Element>) where Base == Swift.UnsafeMutableBufferPointer<Element> {
		let target = UnsafeMutableBufferPointer(rebasing: self)
		target.moveInitializeAll(fromContentsOf: source)
	}
  @inlinable @inline(__always) public func moveInitializeAll<Element>(fromContentsOf source: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) where Base == Swift.UnsafeMutableBufferPointer<Element> {
		let target = UnsafeMutableBufferPointer(rebasing: self)
		target.moveInitializeAll(fromContentsOf: source)
	}
}
extension Swift.UnsafeMutableBufferPointer {
  @discardableResult
  @inlinable public func deinitialize() -> Swift.UnsafeMutableRawBufferPointer {
		guard let start = baseAddress else { return .init(start: nil, count: 0) }
		start.deinitialize(count: count)
		return .init(
			start: UnsafeMutableRawPointer(start),
			count: count * MemoryLayout<Element>.stride
		)
	}
}
extension Swift.UnsafeMutableBufferPointer {
  @inlinable public func initialize<C>(fromContentsOf source: C) -> Swift.UnsafeMutableBufferPointer<Element>.Index where Element == C.Element, C : Swift.Collection {
		let count: Int? = source._withContiguousStorageIfAvailable_SR14663 {
			guard let sourceAddress = $0.baseAddress, !$0.isEmpty else {
				return 0
			}
			precondition(
				$0.count <= self.count,
				"buffer cannot contain every element from source."
			)
			baseAddress?.initialize(from: sourceAddress, count: $0.count)
			return $0.count
		}
		if let count = count {
			return startIndex.advanced(by: count)
		}

		var (iterator, copied) = source._copyContents(initializing: self)
		precondition(
			iterator.next() == nil,
			"buffer cannot contain every element from source."
		)
		return startIndex.advanced(by: copied)
	}
  @inlinable @_alwaysEmitIntoClient public func moveInitialize(fromContentsOf source: Swift.UnsafeMutableBufferPointer<Element>) -> Swift.UnsafeMutableBufferPointer<Element>.Index {
		guard let sourceAddress = source.baseAddress, !source.isEmpty else {
			return startIndex
		}
		precondition(
			source.count <= self.count,
			"buffer cannot contain every element from source."
		)
		baseAddress?.moveInitialize(from: sourceAddress, count: source.count)
		return startIndex.advanced(by: source.count)
	}
  @inlinable @_alwaysEmitIntoClient public func moveInitialize(fromContentsOf source: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) -> Swift.UnsafeMutableBufferPointer<Element>.Index {
		moveInitialize(fromContentsOf: Self(rebasing: source))
	}
  @inlinable @_alwaysEmitIntoClient public func initializeElement(at index: Swift.UnsafeMutableBufferPointer<Element>.Index, to value: Element) {
		assert(startIndex <= index && index < endIndex)
		let p = baseAddress.unsafelyUnwrapped.advanced(by: index)
		p.initialize(to: value)
	}
  @inlinable @_alwaysEmitIntoClient public func moveElement(from index: Swift.UnsafeMutableBufferPointer<Element>.Index) -> Element {
		assert(startIndex <= index && index < endIndex)
		return baseAddress.unsafelyUnwrapped.advanced(by: index).move()
	}
  @inlinable @_alwaysEmitIntoClient public func deinitializeElement(at index: Swift.UnsafeMutableBufferPointer<Element>.Index) {
		assert(startIndex <= index && index < endIndex)
		let p = baseAddress.unsafelyUnwrapped.advanced(by: index)
		p.deinitialize(count: 1)
	}
}
extension Swift.Slice {
  @inlinable @_alwaysEmitIntoClient public func initialize<C>(fromContentsOf source: C) -> Swift.Slice<Base>.Index where Base == Swift.UnsafeMutableBufferPointer<C.Element>, C : Swift.Collection {
		let buffer = Base(rebasing: self)
		let index = buffer.initialize(fromContentsOf: source)
		let distance = buffer.distance(from: buffer.startIndex, to: index)
		return startIndex.advanced(by: distance)
	}
  @inlinable @_alwaysEmitIntoClient public func moveInitialize<Element>(fromContentsOf source: Swift.UnsafeMutableBufferPointer<Element>) -> Swift.Slice<Base>.Index where Base == Swift.UnsafeMutableBufferPointer<Element> {
		let buffer = Base(rebasing: self)
		let index = buffer.moveInitialize(fromContentsOf: source)
		let distance = buffer.distance(from: buffer.startIndex, to: index)
		return startIndex.advanced(by: distance)
	}
  @inlinable @_alwaysEmitIntoClient public func moveInitialize<Element>(fromContentsOf source: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) -> Swift.Slice<Base>.Index where Base == Swift.UnsafeMutableBufferPointer<Element> {
		let buffer = Base(rebasing: self)
		let index = buffer.moveInitialize(fromContentsOf: source)
		let distance = buffer.distance(from: buffer.startIndex, to: index)
		return startIndex.advanced(by: distance)
	}
  @discardableResult
  @inlinable @_alwaysEmitIntoClient public func deinitialize<Element>() -> Swift.UnsafeMutableRawBufferPointer where Base == Swift.UnsafeMutableBufferPointer<Element> {
		Base(rebasing: self).deinitialize()
	}
  @inlinable @_alwaysEmitIntoClient public func initializeElement<Element>(at index: Swift.Int, to value: Element) where Base == Swift.UnsafeMutableBufferPointer<Element> {
		assert(startIndex <= index && index < endIndex)
		base.baseAddress.unsafelyUnwrapped.advanced(by: index).initialize(to: value)
	}
}
extension Swift.UnsafeMutableBufferPointer {
  @_alwaysEmitIntoClient public func update(repeating repeatedValue: Element) {
		guard let dstBase = baseAddress else { return }
		dstBase.update(repeating: repeatedValue, count: count)
	}
}
extension Swift.Slice {
  @_alwaysEmitIntoClient public func update<Element>(repeating repeatedValue: Element) where Base == Swift.UnsafeMutableBufferPointer<Element> {
		Base(rebasing: self).update(repeating: repeatedValue)
	}
}
extension Swift.UnsafeMutablePointer {
  @_alwaysEmitIntoClient public func update(repeating repeatedValue: Pointee, count: Swift.Int) {
		assert(count >= 0, "UnsafeMutablePointer.update(repeating:count:) with negative count")
		for i in 0 ..< count {
			self[i] = repeatedValue
		}
	}
}
infix operator >>> : BitwiseShiftPrecedence
public func >>> (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64
final public class UserDefaultsStorage : DevicesCore.KeyValueStorage {
  public init(userDefaults: Foundation.UserDefaults = .standard)
  final public func object(forKey key: Swift.String) -> DevicesCore.DirectStorable?
  final public func array(forKey key: Swift.String) -> [DevicesCore.DirectStorable]?
  final public func setObject(_ object: DevicesCore.DirectStorable, forKey key: Swift.String)
  final public func removeObject(forKey key: Swift.String)
  @objc deinit
}
public struct UserNotification : Swift.Equatable {
  public let date: Foundation.Date
  public let request: UserNotifications.UNNotificationRequest
  public init(date: Foundation.Date, request: UserNotifications.UNNotificationRequest)
  public static func == (a: DevicesCore.UserNotification, b: DevicesCore.UserNotification) -> Swift.Bool
}
public protocol UserNotificationCenter : UserNotifications.UNUserNotificationCenterDelegate {
  var delegate: DevicesCore.UserNotificationCenterDelegate? { get set }
  func requestAuthorizationStatus(completion: @escaping (UserNotifications.UNAuthorizationStatus) -> Swift.Void)
  func requestAuthorization(options: UserNotifications.UNAuthorizationOptions, completion: @escaping (Swift.Bool, Swift.Error?) -> Swift.Void)
  func removeDeliveredNotifications(withIdentifiers identifiers: [DevicesCore.UserNotificationRequestId])
  func getDeliveredNotifications(completionHandler: @escaping (([UserNotifications.UNNotification]) -> Swift.Void))
  @discardableResult
  func showNotification(_ content: DevicesCore.UserNotificationContent) -> DevicesCore.UserNotificationRequestId
}
public protocol UserNotificationCenterDelegate : AnyObject {
  func userNotificationCenter(_ center: DevicesCore.UserNotificationCenter, willPresent notification: DevicesCore.UserNotification, withCompletionHandler completionHandler: @escaping (UserNotifications.UNNotificationPresentationOptions) -> Swift.Void)
  func userNotificationCenter(_ center: DevicesCore.UserNotificationCenter, didReceive response: DevicesCore.UserNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Swift.Void)
}
public struct UserNotificationContent {
  public let title: Swift.String
  public let subtitle: Swift.String
  public let body: Swift.String
  public let badge: Swift.Int?
  public let userInfo: DevicesCore.JSONDictionary
  public init(title: Swift.String = "", subtitle: Swift.String = "", body: Swift.String = "", badge: Swift.Int? = nil, userInfo: DevicesCore.JSONDictionary = [:])
}
extension DevicesCore.UserNotificationContent : Swift.Equatable {
  public static func == (lhs: DevicesCore.UserNotificationContent, rhs: DevicesCore.UserNotificationContent) -> Swift.Bool
}
public protocol UserNotificationHandler : DevicesCore.UserNotificationCenterDelegate {
  func canHandle(notification: DevicesCore.UserNotification) -> Swift.Bool
}
public typealias UserNotificationRequestId = DevicesCore.Tagged<UserNotifications.UNNotificationRequest, Swift.String>
extension UserNotifications.UNNotificationRequest {
  public var id: DevicesCore.UserNotificationRequestId {
    get
  }
}
public struct UserNotificationResponse : Swift.Equatable {
  public enum ActionType : Swift.String {
    case opened
    case dismissed
    case unknown
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let notification: DevicesCore.UserNotification
  public let action: DevicesCore.UserNotificationResponse.ActionType
  public init(notification: DevicesCore.UserNotification, actionIdentifier: Swift.String)
  public static func == (a: DevicesCore.UserNotificationResponse, b: DevicesCore.UserNotificationResponse) -> Swift.Bool
}
public protocol VideoCaptureDevice : DevicesCore.AuthorizationManager {
}
final public class VideoCaptureDeviceImpl<Device> : DevicesCore.VideoCaptureDevice where Device : DevicesCore.CaptureDevice {
  final public var authorizationStatus: DevicesCore.AuthorizationStatus {
    get
  }
  public init(_: Device.Type)
  final public func requestAuthorization(completion: @escaping (DevicesCore.AuthorizationStatus) -> Swift.Void)
  @objc deinit
}
public protocol VideoCaptureSession {
  var state: DevicesCore.Property<DevicesCore.VideoCaptureSessionState> { get }
  func makePreviewLayer(orientation: AVFoundation.AVCaptureVideoOrientation) -> AVFoundation.AVCaptureVideoPreviewLayer
  func start()
  func stop()
  func deactivate()
  func switchCamera()
  func setFlash(_ isOn: Swift.Bool) throws
}
public typealias VideoCaptureSessionFactory = DevicesCore.Factory<(AVFoundation.AVCaptureDevice.Position, AVFoundation.AVCaptureSession.Preset, DevicesCore.CaptureOutputResolver?), DevicesCore.VideoCaptureSession>
extension DevicesCore.Factory where Arg == (AVFoundation.AVCaptureDevice.Position, AVFoundation.AVCaptureSession.Preset, DevicesCore.CaptureOutputResolver?), Item == DevicesCore.VideoCaptureSession {
  public static func defaultFactory() -> DevicesCore.VideoCaptureSessionFactory
}
final public class VideoCaptureSessionImpl : DevicesCore.VideoCaptureSession {
  final public var state: DevicesCore.Property<DevicesCore.VideoCaptureSessionState> {
    get
  }
  public init(captureSession: DevicesCore.CaptureSessionTwin, captureDeviceDiscoverySession: DevicesCore.CaptureDeviceDiscoverySessionTwin?, outputResolver: DevicesCore.CaptureOutputResolver?, position: AVFoundation.AVCaptureDevice.Position, preset: AVFoundation.AVCaptureSession.Preset, asyncPerformer: DevicesCore.AsyncPerformer, mainThreadRunner: DevicesCore.AsyncPerformer)
  final public func makePreviewLayer(orientation: AVFoundation.AVCaptureVideoOrientation) -> AVFoundation.AVCaptureVideoPreviewLayer
  final public func start()
  final public func stop()
  final public func deactivate()
  final public func switchCamera()
  final public func setFlash(_ isOn: Swift.Bool) throws
  @objc deinit
}
public enum VideoCaptureSessionState {
  case idle
  case configuring
  case running
  case stopping
  case stopped
  public var canRun: Swift.Bool {
    get
  }
  public var isRunning: Swift.Bool {
    get
  }
  public var canStop: Swift.Bool {
    get
  }
  public static func == (a: DevicesCore.VideoCaptureSessionState, b: DevicesCore.VideoCaptureSessionState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol VideoPreviewRectConverter {
  func layerRectConverted(fromMetadataOutputRect: CoreFoundation.CGRect) -> CoreFoundation.CGRect
}
extension AVFoundation.AVCaptureVideoPreviewLayer : DevicesCore.VideoPreviewRectConverter {
}
final public class WAVAudioDecoder : DevicesCore.AudioDecoder {
  public init(wavHeaderDecoder: DevicesCore.WAVHeaderDecoder)
  final public func decode(audioData: Foundation.Data) throws -> DevicesCore.AudioPayload
  final public func reset()
  @objc deinit
}
public struct WAVHeader : Swift.Equatable {
  public let chunkID: Swift.String
  public let chunkSize: Swift.UInt32
  public let format: Swift.String
  public let subchunk1ID: Swift.String
  public let subchunk1Size: Swift.UInt32
  public let audioFormat: Swift.UInt16
  public let numChannels: DevicesCore.ChannelsCount
  public let sampleRate: DevicesCore.SampleRate
  public let byteRate: Swift.UInt32
  public let blockAlign: Swift.UInt16
  public let bitsPerSample: DevicesCore.BitsPerChannel
  public let subchunk2ID: Swift.String
  public let subchunk2Size: Swift.UInt32
  public init(chunkID: Swift.String?, chunkSize: Swift.UInt32, format: Swift.String?, subchunk1ID: Swift.String?, subchunk1Size: Swift.UInt32?, audioFormat: Swift.UInt16?, numChannels: DevicesCore.ChannelsCount, sampleRate: DevicesCore.SampleRate, byteRate: Swift.UInt32, blockAlign: Swift.UInt16, bitsPerSample: DevicesCore.BitsPerChannel, subchunk2ID: Swift.String?, subchunk2Size: Swift.UInt32)
  public init(chunkSize: Swift.UInt32, numChannels: DevicesCore.ChannelsCount, sampleRate: DevicesCore.SampleRate, byteRate: Swift.UInt32, blockAlign: Swift.UInt16, bitsPerSample: DevicesCore.BitsPerChannel, subchunk2Size: Swift.UInt32)
  public init(format: DevicesCore.AudioFormat, chunkSize: Swift.Int = 0, subchunk2Size: Swift.Int = 0)
  public static func == (a: DevicesCore.WAVHeader, b: DevicesCore.WAVHeader) -> Swift.Bool
}
public protocol WAVHeaderDecoder {
  func isWav(data: Foundation.Data) -> Swift.Bool
  func decode(data: Foundation.Data) throws -> DevicesCore.WAVHeader
}
final public class WAVHeaderDecoderImpl : DevicesCore.WAVHeaderDecoder {
  public init()
  final public func isWav(data: Foundation.Data) -> Swift.Bool
  final public func decode(data: Foundation.Data) throws -> DevicesCore.WAVHeader
  @objc deinit
}
public protocol WAVHeaderEncoder {
  func encode(header: DevicesCore.WAVHeader) throws -> Foundation.Data
}
public enum WAVHeaderEncoders {
  public static func makeDefault() -> DevicesCore.WAVHeaderEncoder
}
public enum WAVHeaderSpecs {
  public static let headerSize: Swift.Int
  public static let riffHeaderSize: Swift.Int
  public static let chunkID: Swift.String
  public static let headerFormat: Swift.String
  public static let subchunk1ID: Swift.String
  public static let subchunk1SizeForPCM: Swift.UInt32
  public static let audioFormatForPCM: Swift.UInt16
  public static let subchunk2ID: Swift.String
}
extension WebKit.WKWebView : DevicesCore.WebView {
  @_Concurrency.MainActor(unsafe) public var scrollInsets: UIKit.UIEdgeInsets {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var bounces: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var isScrollEnabled: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var keyboardDismissMode: UIKit.UIScrollView.KeyboardDismissMode {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var contentInsetAdjustmentBehavior: UIKit.UIScrollView.ContentInsetAdjustmentBehavior {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var canvasNavigationGesturesEnabled: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var isOpaqueCanvas: Swift.Bool {
    get
    set
  }
}
extension WebKit.WKNavigation : DevicesCore.WebNavigation {
}
@propertyWrapper final public class WeakBox<T> {
  @inlinable final public var wrappedValue: T? {
    get { value }
    set { value = newValue }
  }
  final public var isLastValueWasNil: Swift.Bool {
    get
  }
  final public var value: T? {
    get
    set
  }
  public init(value: T? = nil)
  @objc deinit
}
public class WeakCollection<Element> {
  public var lastNonNil: Element? {
    get
  }
  public init()
  public func append(_ newElement: Element)
  public func remove(_ element: Element)
  @objc deinit
}
extension DevicesCore.WeakCollection : Swift.Collection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(index: Swift.Int) -> Element? {
    get
  }
  public func index(after idx: Swift.Int) -> Swift.Int
  public typealias Index = Swift.Int
  public typealias Indices = Swift.DefaultIndices<DevicesCore.WeakCollection<Element>>
  public typealias Iterator = Swift.IndexingIterator<DevicesCore.WeakCollection<Element>>
  public typealias SubSequence = Swift.Slice<DevicesCore.WeakCollection<Element>>
}
extension DevicesCore.WeakCollection {
  public func forEach(_ body: (Element?) throws -> Swift.Void) rethrows
}
public protocol WebContentController : AnyObject, DevicesCore.JSExecutor {
  func load(request: Foundation.URLRequest)
  func setNavigationDelegate(_ delegate: DevicesCore.WebViewNavigationDelegate)
  func setUIDelegate(_ delegate: DevicesCore.WebViewUIDelegate)
  func setTerminationDelegate(_ delegate: DevicesCore.WebTerminationDelegate)
  func setAuthChallengeDelegate(_ delegate: DevicesCore.WebViewAuthChallengeDelegate)
  func setSSLErrorHandlerDelegate(_ delegate: DevicesCore.WebViewSSLErrorHandlerDelegate)
  func stopLoading()
  func injectJSAPI(_ api: DevicesCore.JSAPI)
}
public protocol WebNavigation : AnyObject {
}
public struct WebNavigationAction : Swift.Equatable {
  public enum `Type` {
    case linkTap
    case newTab
    case other
    public static func == (a: DevicesCore.WebNavigationAction.`Type`, b: DevicesCore.WebNavigationAction.`Type`) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let url: Foundation.URL?
  public let type: DevicesCore.WebNavigationAction.`Type`
  public let shouldPerformDownload: Swift.Bool
  public init(type: DevicesCore.WebNavigationAction.`Type`, url: Foundation.URL?, shouldPerformDownload: Swift.Bool = false)
  public static func == (a: DevicesCore.WebNavigationAction, b: DevicesCore.WebNavigationAction) -> Swift.Bool
}
extension DevicesCore.WebNavigationAction : DevicesCore.PrettyStringConvertible {
}
@_hasMissingDesignatedInitializers final public class WebNavigationActionPolicyHandler {
  final public func handle(_ isAllowed: Swift.Bool)
  @objc deinit
}
public protocol WebNavigationController : AnyObject {
  var canGoBack: DevicesCore.Property<Swift.Bool> { get }
  func goBack() throws
}
public enum WebNavigationControllerError : Swift.Error, Swift.Equatable {
  case cantGoBack
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DevicesCore.WebNavigationControllerError, b: DevicesCore.WebNavigationControllerError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
final public class WebNavigationHandler : DevicesCore.WebViewNavigationDelegate {
  public init(logger: DevicesCore.Logger?, handlers: [DevicesCore.NavigationHandler], assertionCaller: DevicesCore.AssertionCaller = assertionCallerShared)
  final public func webView(_: DevicesCore.WebView, didReceiveServerRedirectForProvisionalNavigation _: DevicesCore.WebNavigation)
  final public func webView(_: DevicesCore.WebView, didStartProvisionalNavigation _: DevicesCore.WebNavigation)
  final public func webView(_: DevicesCore.WebView, decidePolicyFor navigationAction: DevicesCore.WebNavigationAction, decisionHandler: DevicesCore.WebNavigationActionPolicyHandler)
  final public func webView(_: DevicesCore.WebView, decidePolicyFor _: DevicesCore.WebNavigationResponse, decisionHandler: DevicesCore.WebNavigationResponsePolicyHandler)
  final public func webView(_: DevicesCore.WebView, didFinish _: DevicesCore.WebNavigation)
  @objc deinit
}
public struct WebNavigationResponse : Swift.Equatable {
  public let url: Foundation.URL?
  public let mimeType: Swift.String?
  public let suggestedFilename: Swift.String?
  public let contentLength: Swift.Int64?
  public let headers: [DevicesCore.HTTPHeaderName : Swift.String]
  public init(url: Foundation.URL?, mimeType: Swift.String?, suggestedFilename: Swift.String?, contentLength: Swift.Int64?, headers: [DevicesCore.HTTPHeaderName : Swift.String])
  public static func == (a: DevicesCore.WebNavigationResponse, b: DevicesCore.WebNavigationResponse) -> Swift.Bool
}
extension DevicesCore.WebNavigationResponse : DevicesCore.PrettyStringConvertible {
}
@_hasMissingDesignatedInitializers final public class WebNavigationResponsePolicyHandler {
  final public func handle(_ isAllowed: Swift.Bool)
  @objc deinit
}
final public class WebRedirectHandler : DevicesCore.WebViewNavigationDelegate {
  public init(logger: DevicesCore.Logger, handlers: [DevicesCore.RedirectHandler], assertionCaller: DevicesCore.AssertionCaller = assertionCallerShared)
  final public func webView(_ webView: DevicesCore.WebView, didReceiveServerRedirectForProvisionalNavigation _: DevicesCore.WebNavigation)
  final public func webView(_ webView: DevicesCore.WebView, didStartProvisionalNavigation _: DevicesCore.WebNavigation)
  final public func webView(_: DevicesCore.WebView, decidePolicyFor _: DevicesCore.WebNavigationAction, decisionHandler handler: DevicesCore.WebNavigationActionPolicyHandler)
  final public func webView(_: DevicesCore.WebView, decidePolicyFor _: DevicesCore.WebNavigationResponse, decisionHandler handler: DevicesCore.WebNavigationResponsePolicyHandler)
  final public func webView(_: DevicesCore.WebView, didFinish _: DevicesCore.WebNavigation)
  @objc deinit
}
public enum WebSocket {
}
public protocol WebTerminationDelegate : AnyObject {
  func didTerminate()
}
public protocol WebView : UIKit.UIView {
  var url: Foundation.URL? { get }
  var bounces: Swift.Bool { get set }
  var scrollInsets: UIKit.UIEdgeInsets { get set }
  var isScrollEnabled: Swift.Bool { get set }
  var keyboardDismissMode: UIKit.UIScrollView.KeyboardDismissMode { get set }
  var contentInsetAdjustmentBehavior: UIKit.UIScrollView.ContentInsetAdjustmentBehavior { get set }
  var canvasNavigationGesturesEnabled: Swift.Bool { get set }
  var isOpaqueCanvas: Swift.Bool { get set }
}
public protocol WebViewAuthChallengeDelegate : AnyObject {
  func webView(_ webView: DevicesCore.WebView, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
public struct WebViewConfiguration : Swift.Equatable {
  public let userAgentType: DevicesCore.UserAgentType?
  public let allowsInlineMediaPlayback: Swift.Bool
  public let allowsAutoplayMedia: Swift.Bool
  public init(allowsInlineMediaPlayback: Swift.Bool, allowsAutoplayMedia: Swift.Bool, userAgentType: DevicesCore.UserAgentType?)
  public static func == (a: DevicesCore.WebViewConfiguration, b: DevicesCore.WebViewConfiguration) -> Swift.Bool
}
public enum UserAgentType : Swift.Equatable {
  case custom(Swift.String)
  case applicationName(Swift.String)
  public static func == (a: DevicesCore.UserAgentType, b: DevicesCore.UserAgentType) -> Swift.Bool
}
final public class WebViewGraph {
  final public let view: DevicesCore.WebView
  final public let contentController: DevicesCore.WebContentController
  final public let webNavigationController: DevicesCore.WebNavigationController
  public init(view: DevicesCore.WebView, contentController: DevicesCore.WebContentController, webNavigationController: DevicesCore.WebNavigationController)
  @objc deinit
}
public protocol WebViewGraphFactory {
  func make(configuration: DevicesCore.WebViewConfiguration) -> DevicesCore.WebViewGraph
}
final public class WebViewGraphFactoryImpl : DevicesCore.WebViewGraphFactory {
  public init()
  final public func make(configuration: DevicesCore.WebViewConfiguration) -> DevicesCore.WebViewGraph
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class WebViewImpl : UIKit.UIView, DevicesCore.WebView {
  @_Concurrency.MainActor(unsafe) @objc override final public var backgroundColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) final public var url: Foundation.URL? {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var bounces: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var scrollInsets: UIKit.UIEdgeInsets {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var isScrollEnabled: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var keyboardDismissMode: UIKit.UIScrollView.KeyboardDismissMode {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var contentInsetAdjustmentBehavior: UIKit.UIScrollView.ContentInsetAdjustmentBehavior {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var canvasNavigationGesturesEnabled: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var isOpaqueCanvas: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) convenience public init(configuration: DevicesCore.WebViewConfiguration)
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override final public func observeValue(forKeyPath keyPath: Swift.String?, of _: Any?, change _: [Foundation.NSKeyValueChangeKey : Any]?, context _: Swift.UnsafeMutableRawPointer?)
  @objc deinit
}
extension DevicesCore.WebViewImpl : DevicesCore.WebContentController {
  @_Concurrency.MainActor(unsafe) final public func setNavigationDelegate(_ delegate: DevicesCore.WebViewNavigationDelegate)
  @_Concurrency.MainActor(unsafe) final public func setUIDelegate(_ delegate: DevicesCore.WebViewUIDelegate)
  @_Concurrency.MainActor(unsafe) final public func setTerminationDelegate(_ delegate: DevicesCore.WebTerminationDelegate)
  @_Concurrency.MainActor(unsafe) final public func setAuthChallengeDelegate(_ delegate: DevicesCore.WebViewAuthChallengeDelegate)
  @_Concurrency.MainActor(unsafe) final public func setSSLErrorHandlerDelegate(_ delegate: DevicesCore.WebViewSSLErrorHandlerDelegate)
  @_Concurrency.MainActor(unsafe) final public func load(request: Foundation.URLRequest)
  @_Concurrency.MainActor(unsafe) final public func execute(_ script: Swift.String, completion: @escaping (Swift.Result<Any?, Swift.Error>) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) final public func injectJSAPI(_ api: DevicesCore.JSAPI)
  @_Concurrency.MainActor(unsafe) final public func stopLoading()
}
extension DevicesCore.WebViewImpl : DevicesCore.WebNavigationController {
  @_Concurrency.MainActor(unsafe) final public var canGoBack: DevicesCore.Property<Swift.Bool> {
    get
  }
  @_Concurrency.MainActor(unsafe) final public func goBack() throws
}
public protocol WebViewNavigationDelegate : AnyObject {
  func webView(_ webView: DevicesCore.WebView, didReceiveServerRedirectForProvisionalNavigation navigation: DevicesCore.WebNavigation)
  func webView(_ webView: DevicesCore.WebView, didStartProvisionalNavigation navigation: DevicesCore.WebNavigation)
  func webView(_ webView: DevicesCore.WebView, decidePolicyFor navigationAction: DevicesCore.WebNavigationAction, decisionHandler: DevicesCore.WebNavigationActionPolicyHandler)
  func webView(_ webView: DevicesCore.WebView, decidePolicyFor navigationResponse: DevicesCore.WebNavigationResponse, decisionHandler: DevicesCore.WebNavigationResponsePolicyHandler)
  func webView(_ webView: DevicesCore.WebView, didFinish navigation: DevicesCore.WebNavigation)
}
public protocol WebViewSSLErrorHandlerDelegate : AnyObject {
  func didReceiveSSLError()
}
public protocol WebViewUIDelegate : AnyObject {
  func webViewDidClose(_ webView: DevicesCore.WebView)
}
public typealias Whitelist = DevicesCore.Tagged<DevicesCore.WhitelistTag, Swift.Set<Foundation.URL>>
public enum WhitelistTag {
}
extension DevicesCore.SecurityChallengeReceiver {
  public func checkWhitelist(_ whitelist: [Swift.String], logger: DevicesCore.Logger? = nil) -> DevicesCore.SecurityChallengeReceiver
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func zip<Others>(with others: Others) -> Combine.AnyPublisher<[Self.Output], Self.Failure> where Others : Swift.Collection, Self.Failure == Others.Element.Failure, Self.Output == Others.Element.Output, Others.Element : Combine.Publisher
  public func zip<Other>(with others: Other...) -> Combine.AnyPublisher<[Self.Output], Self.Failure> where Other : Combine.Publisher, Self.Failure == Other.Failure, Self.Output == Other.Output
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.Collection where Self.Element : Combine.Publisher {
  public func zipMany() -> Combine.AnyPublisher<[Self.Element.Output], Self.Element.Failure>
}
extension DevicesCore._HashTable {
  @usableFromInline
  @frozen internal struct Bucket {
    @usableFromInline
    internal var offset: Swift.Int
    @inlinable @inline(__always) internal init(offset: Swift.Int) {
			assert(offset >= 0)
			self.offset = offset
		}
  }
}
extension DevicesCore._HashTable.Bucket : Swift.Equatable {
  @_transparent public static func == (left: DevicesCore._HashTable.Bucket, right: DevicesCore._HashTable.Bucket) -> Swift.Bool {
		left.offset == right.offset
	}
}
extension DevicesCore._HashTable {
  @usableFromInline
  internal struct BucketIterator {
    @usableFromInline
    internal typealias Bucket = DevicesCore._HashTable.Bucket
    @usableFromInline
    internal var _currentBucket: DevicesCore._HashTable.BucketIterator.Bucket
    @usableFromInline
    @_effects(releasenone) internal init(hashTable: DevicesCore._UnsafeHashTable, startingAt bucket: DevicesCore._HashTable.BucketIterator.Bucket)
  }
}
extension DevicesCore._HashTable.UnsafeHandle {
  @usableFromInline
  internal typealias BucketIterator = DevicesCore._HashTable.BucketIterator
  @_effects(releasenone) @inlinable @inline(__always) internal func idealBucket(forHashValue hashValue: Swift.Int) -> DevicesCore._HashTable.UnsafeHandle.Bucket {
		Bucket(offset: hashValue & (bucketCount - 1))
	}
  @inlinable @inline(__always) internal func idealBucket<Element>(for element: Element) -> DevicesCore._HashTable.UnsafeHandle.Bucket where Element : Swift.Hashable {
		let hashValue = element._rawHashValue(seed: seed)
		return idealBucket(forHashValue: hashValue)
	}
  @inlinable @inline(__always) internal func bucketIterator<Element>(for element: Element) -> DevicesCore._HashTable.UnsafeHandle.BucketIterator where Element : Swift.Hashable {
		let bucket = idealBucket(for: element)
		return bucketIterator(startingAt: bucket)
	}
  @inlinable @inline(__always) internal func bucketIterator(startingAt bucket: DevicesCore._HashTable.UnsafeHandle.Bucket) -> DevicesCore._HashTable.UnsafeHandle.BucketIterator {
		BucketIterator(hashTable: self, startingAt: bucket)
	}
  @usableFromInline
  @_effects(releasenone) internal func startFind(_ startBucket: DevicesCore._HashTable.UnsafeHandle.Bucket) -> (iterator: DevicesCore._HashTable.UnsafeHandle.BucketIterator, currentValue: Swift.Int?)
  @usableFromInline
  @_effects(readonly) internal func _startIterator(bucket: DevicesCore._HashTable.UnsafeHandle.Bucket) -> (currentBits: Swift.UInt64, nextBits: Swift.UInt64, remainingBitCount: Swift.Int)
}
extension DevicesCore._HashTable.BucketIterator {
  @inlinable @inline(__always) internal var currentBucket: DevicesCore._HashTable.BucketIterator.Bucket {
    get { _currentBucket }
  }
  @usableFromInline
  internal var isOccupied: Swift.Bool {
    @_effects(readonly) @inline(__always) get
  }
  @usableFromInline
  internal var currentValue: Swift.Int? {
    @inline(__always) @_effects(readonly) get
    @_effects(releasenone) set
  }
  @usableFromInline
  @_effects(releasenone) internal mutating func advance()
  @usableFromInline
  @_effects(releasenone) internal mutating func findNext() -> Swift.Int?
  @inlinable @_effects(releasenone) internal mutating func advance(until expected: Swift.Int) {
		while isOccupied, currentValue != expected {
			advance()
		}
	}
  @inlinable @_effects(releasenone) internal mutating func advanceToNextUnoccupiedBucket() {
		while isOccupied {
			advance()
		}
	}
}
extension DevicesCore._HashTable {
  @usableFromInline
  @inline(__always) internal static var minimumScale: Swift.Int {
    @_effects(readnone) get
  }
  @usableFromInline
  @inline(__always) internal static var maximumScale: Swift.Int {
    @_effects(readnone) get
  }
  @usableFromInline
  @inline(__always) internal static var maximumUnhashedCount: Swift.Int {
    @_effects(readnone) get
  }
  @usableFromInline
  @_effects(readnone) internal static func minimumCapacity(forScale scale: Swift.Int) -> Swift.Int
  @usableFromInline
  @_effects(readnone) internal static func maximumCapacity(forScale scale: Swift.Int) -> Swift.Int
  @usableFromInline
  @_effects(readnone) internal static func scale(forCapacity capacity: Swift.Int) -> Swift.Int
}
extension DevicesCore._HashTable.Header : Swift.CustomStringConvertible {
  @usableFromInline
  internal var _description: Swift.String {
    get
  }
  @usableFromInline
  internal var description: Swift.String {
    get
  }
}
extension DevicesCore._HashTable.UnsafeHandle : Swift.CustomStringConvertible {
  @usableFromInline
  internal var description: Swift.String {
    get
  }
}
extension DevicesCore._HashTable : Swift.CustomStringConvertible {
  @usableFromInline
  internal var description: Swift.String {
    get
  }
}
extension DevicesCore._HashTable.Storage : Swift.CustomStringConvertible {
  @usableFromInline
  final internal var description: Swift.String {
    get
  }
}
extension DevicesCore._HashTable.Bucket : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension DevicesCore._HashTable.BucketIterator : Swift.CustomStringConvertible {
  @usableFromInline
  internal var description: Swift.String {
    get
  }
}
@usableFromInline
internal typealias _UnsafeHashTable = DevicesCore._HashTable.UnsafeHandle
extension DevicesCore._HashTable {
  @usableFromInline
  @frozen internal struct UnsafeHandle {
    @usableFromInline
    internal typealias Bucket = DevicesCore._HashTable.Bucket
    @usableFromInline
    internal var _header: Swift.UnsafeMutablePointer<DevicesCore._HashTable.Header>
    @usableFromInline
    internal var _buckets: Swift.UnsafeMutablePointer<Swift.UInt64>
    @inlinable @inline(__always) internal init(header: Swift.UnsafeMutablePointer<DevicesCore._HashTable.Header>, buckets: Swift.UnsafeMutablePointer<Swift.UInt64>, readonly: Swift.Bool) {
			self._header = header
			self._buckets = buckets
		}
    @inlinable @inline(__always) internal func assertMutable() {
		}
  }
}
extension DevicesCore._HashTable.UnsafeHandle {
  @inlinable @inline(__always) internal var scale: Swift.Int {
    get { _header.pointee.scale }
  }
  @inlinable @inline(__always) internal var reservedScale: Swift.Int {
    get { _header.pointee.reservedScale }
  }
  @inlinable @inline(__always) internal var seed: Swift.Int {
    get { _header.pointee.seed }
  }
  @inlinable @inline(__always) internal var bias: Swift.Int {
    get { _header.pointee.bias }
    nonmutating set { _header.pointee.bias = newValue }
  }
  @inlinable @inline(__always) internal var bucketCount: Swift.Int {
    get { 1 &<< scale }
  }
  @inlinable @inline(__always) internal var bucketMask: Swift.UInt64 {
    get { UInt64(truncatingIfNeeded: bucketCount) - 1 }
  }
  @inlinable @inline(__always) internal var bitCount: Swift.Int {
    get { scale &<< scale }
  }
  @inlinable @inline(__always) internal var wordCount: Swift.Int {
    get { (bitCount + UInt64.bitWidth - 1) / UInt64.bitWidth }
  }
  @inlinable @inline(__always) internal var capacity: Swift.Int {
    get { _HashTable.maximumCapacity(forScale: scale) }
  }
  @inlinable @inline(__always) internal func bucket(after bucket: DevicesCore._HashTable.UnsafeHandle.Bucket) -> DevicesCore._HashTable.UnsafeHandle.Bucket {
		var offset = bucket.offset + 1
		if offset == bucketCount {
			offset = 0
		}
		return Bucket(offset: offset)
	}
  @inlinable @inline(__always) internal func bucket(before bucket: DevicesCore._HashTable.UnsafeHandle.Bucket) -> DevicesCore._HashTable.UnsafeHandle.Bucket {
		let offset = (bucket.offset == 0 ? bucketCount : bucket.offset) - 1
		return Bucket(offset: offset)
	}
  @inlinable @inline(__always) internal func word(after word: Swift.Int) -> Swift.Int {
		var result = word + 1
		if result == wordCount {
			result = 0
		}
		return result
	}
  @inlinable @inline(__always) internal func word(before word: Swift.Int) -> Swift.Int {
		if word == 0 {
			return wordCount - 1
		}
		return word - 1
	}
  @inlinable internal func position(of bucket: DevicesCore._HashTable.UnsafeHandle.Bucket) -> (word: Swift.Int, bit: Swift.Int) {
		let start = bucket.offset &* scale
		return (start &>> 6, start & 0x3F)
	}
}
extension DevicesCore._HashTable.UnsafeHandle {
  @inlinable internal func _value(forBucketContents bucketContents: Swift.UInt64) -> Swift.Int? {
		let mask = bucketMask
		assert(bucketContents <= mask)
		guard bucketContents != 0 else { return nil }
		let v = (bucketContents ^ mask) &+ UInt64(truncatingIfNeeded: bias)
		return Int(truncatingIfNeeded: v >= mask ? v - mask : v)
	}
  @inlinable internal func _bucketContents(for value: Swift.Int?) -> Swift.UInt64 {
		guard var value = value else { return 0 }
		let mask = Int(truncatingIfNeeded: bucketMask)
		assert(value >= 0 && value < mask)
		value &-= bias
		if value < 0 { value += mask }
		assert(value >= 0 && value < mask)
		return UInt64(truncatingIfNeeded: value ^ mask)
	}
  @inlinable internal subscript(word word: Swift.Int) -> Swift.UInt64 {
    @inline(__always) get {
			assert(word >= 0 && word < bucketCount)
			return _buckets[word]
		}
    @inline(__always) nonmutating set {
			assert(word >= 0 && word < bucketCount)
			assertMutable()
			_buckets[word] = newValue
		}
  }
  @inlinable internal subscript(raw bucket: DevicesCore._HashTable.UnsafeHandle.Bucket) -> Swift.UInt64 {
    get {
			assert(bucket.offset < bucketCount)
			let (word, bit) = position(of: bucket)
			var value = self[word: word] &>> bit
			let extractedBits = 64 - bit
			if extractedBits < scale {
				let word2 = self.word(after: word)
				value &= (1 &<< extractedBits) - 1
				value |= self[word: word2] &<< extractedBits
			}
			return value & bucketMask
		}
    nonmutating set {
			assertMutable()
			assert(bucket.offset < bucketCount)
			let mask = bucketMask
			assert(newValue <= mask)
			let (word, bit) = position(of: bucket)
			self[word: word] &= ~(mask &<< bit)
			self[word: word] |= newValue &<< bit
			let extractedBits = 64 - bit
			if extractedBits < scale {
				let word2 = self.word(after: word)
				self[word: word2] &= ~((1 &<< (scale - extractedBits)) - 1)
				self[word: word2] |= newValue &>> extractedBits
			}
		}
  }
  @inlinable @inline(__always) internal func isOccupied(_ bucket: DevicesCore._HashTable.UnsafeHandle.Bucket) -> Swift.Bool {
		self[raw: bucket] != 0
	}
  @inlinable internal subscript(bucket: DevicesCore._HashTable.UnsafeHandle.Bucket) -> Swift.Int? {
    get {
			let contents = self[raw: bucket]
			return _value(forBucketContents: contents)
		}
    nonmutating set {
			assertMutable()
			let v = _bucketContents(for: newValue)
			self[raw: bucket] = v
		}
  }
}
extension DevicesCore._HashTable.UnsafeHandle {
  @inlinable internal func _find<Base>(_ item: Base.Element, in elements: Base) -> (index: Swift.Int?, bucket: DevicesCore._HashTable.UnsafeHandle.Bucket) where Base : Swift.RandomAccessCollection, Base.Element : Swift.Hashable {
		let start = idealBucket(for: item)
		var (iterator, value) = startFind(start)
		while let index = value {
			if elements[_offset: index] == item {
				return (index, iterator.currentBucket)
			}
			value = iterator.findNext()
		}
		return (nil, iterator.currentBucket)
	}
}
extension DevicesCore._HashTable.UnsafeHandle {
  @usableFromInline
  internal func firstOccupiedBucketInChain(with bucket: DevicesCore._HashTable.UnsafeHandle.Bucket) -> DevicesCore._HashTable.UnsafeHandle.Bucket
  @inlinable internal func delete(bucket: DevicesCore._HashTable.UnsafeHandle.Bucket, hashValueGenerator: (Swift.Int, Swift.Int) -> Swift.Int) {
		assertMutable()
		var it = bucketIterator(startingAt: bucket)
		assert(it.isOccupied)
		it.advance()
		guard it.isOccupied else {
			// Fast path: Don't get the start bucket when there's nothing to do.
			self[bucket] = nil
			return
		}
		// If we've put a hole in the middle of a collision chain, some element after
		// the hole may belong where the new hole is.

		// Find the first bucket in the collision chain that contains the entry we've just deleted.
		let start = firstOccupiedBucketInChain(with: bucket)
		var hole = bucket

		while it.isOccupied {
			let hash = hashValueGenerator(it.currentValue!, seed)
			let candidate = idealBucket(forHashValue: hash)

			// Does this element belong between start and hole?  We need two
			// separate tests depending on whether [start, hole] wraps around the
			// end of the storage.
			let c0 = candidate.offset >= start.offset
			let c1 = candidate.offset <= hole.offset
			if start.offset <= hole.offset ? (c0 && c1) : (c0 || c1) {
				// Fill the hole. Here we are mutating table contents behind the back of
				// the iterator; this is okay since we know we are never going to revisit
				// `hole` with it.
				self[hole] = it.currentValue
				hole = it.currentBucket
			}
			it.advance()
		}
		self[hole] = nil
	}
}
extension DevicesCore._HashTable.UnsafeHandle {
  @inlinable internal func adjustContents<Base>(preparingForInsertionOfElementAtOffset offset: Swift.Int, in elements: Base) where Base : Swift.RandomAccessCollection, Base.Element : Swift.Hashable {
		assertMutable()
		let index = elements._index(at: offset)
		if offset < elements.count / 2 {
			self.bias += 1
			if offset <= capacity / 3 {
				var i = 1
				for item in elements[..<index] {
					var it = bucketIterator(for: item)
					it.advance(until: i)
					it.currentValue! -= 1
					i += 1
				}
			} else {
				var it = bucketIterator(startingAt: Bucket(offset: 0))
				repeat {
					if let value = it.currentValue, value <= offset {
						it.currentValue = value - 1
					}
					it.advance()
				} while it.currentBucket.offset != 0
			}
		} else {
			if elements.count - offset - 1 <= capacity / 3 {
				var i = offset
				for item in elements[index...] {
					var it = bucketIterator(for: item)
					it.advance(until: i)
					it.currentValue! += 1
					i += 1
				}
			} else {
				var it = bucketIterator(startingAt: Bucket(offset: 0))
				repeat {
					if let value = it.currentValue, value >= offset {
						it.currentValue = value + 1
					}
					it.advance()
				} while it.currentBucket.offset != 0
			}
		}
	}
}
extension DevicesCore._HashTable.UnsafeHandle {
  @inlinable @inline(__always) internal func adjustContents<Base>(preparingForRemovalOf index: Base.Index, in elements: Base) where Base : Swift.RandomAccessCollection, Base.Element : Swift.Hashable {
		let next = elements.index(after: index)
		adjustContents(preparingForRemovalOf: index ..< next, in: elements)
	}
  @inlinable internal func adjustContents<Base>(preparingForRemovalOf bounds: Swift.Range<Base.Index>, in elements: Base) where Base : Swift.RandomAccessCollection, Base.Element : Swift.Hashable {
		assertMutable()
		let startOffset = elements._offset(of: bounds.lowerBound)
		let endOffset = elements._offset(of: bounds.upperBound)
		let c = endOffset - startOffset
		guard c > 0 else { return }
		let remainingCount = elements.count - c

		if startOffset >= remainingCount / 2 {
			let tailCount = elements.count - endOffset
			if tailCount < capacity / 3 {
				var i = endOffset
				for item in elements[bounds.upperBound...] {
					var it = self.bucketIterator(for: item)
					it.advance(until: i)
					it.currentValue = i - c
					i += 1
				}
			} else {
				var it = bucketIterator(startingAt: Bucket(offset: 0))
				repeat {
					if let value = it.currentValue {
						if value >= endOffset {
							it.currentValue = value - c
						} else {
							assert(value < startOffset)
						}
					}
					it.advance()
				} while it.currentBucket.offset != 0
			}
		} else {
			if startOffset < capacity / 3 {
				var i = 0
				for item in elements[..<bounds.lowerBound] {
					var it = self.bucketIterator(for: item)
					it.advance(until: i)
					it.currentValue = i + c
					i += 1
				}
			} else {
				var it = bucketIterator(startingAt: Bucket(offset: 0))
				repeat {
					if let value = it.currentValue {
						if value < startOffset {
							it.currentValue = value + c
						} else {
							assert(value >= endOffset)
						}
					}
					it.advance()
				} while it.currentBucket.offset != 0
			}
			self.bias -= c
		}
	}
}
extension DevicesCore._HashTable.UnsafeHandle {
  @usableFromInline
  internal func clear()
}
extension DevicesCore._HashTable.UnsafeHandle {
  @inlinable internal func fill<C>(uncheckedUniqueElements elements: C) where C : Swift.RandomAccessCollection, C.Element : Swift.Hashable {
		assertMutable()
		assert(elements.count <= capacity)
		// Iterate over elements and insert their offset into the hash table.
		var offset = 0
		for index in elements.indices {
			// Find the insertion position. We know that we're inserting a new item,
			// so there is no need to compare it with any of the existing ones.
			var it = bucketIterator(for: elements[index])
			it.advanceToNextUnoccupiedBucket()
			it.currentValue = offset
			offset += 1
		}
	}
  @inlinable internal func fill<C>(untilFirstDuplicateIn elements: C) -> (success: Swift.Bool, end: C.Index) where C : Swift.RandomAccessCollection, C.Element : Swift.Hashable {
		assertMutable()
		assert(elements.count <= capacity)
		// Iterate over elements and insert their offset into the hash table.
		var offset = 0
		for index in elements.indices {
			// Find the insertion position. We know that we're inserting a new item,
			// so there is no need to compare it with any of the existing ones.
			var it = bucketIterator(for: elements[index])
			while let offset = it.currentValue {
				guard elements[_offset: offset] != elements[index] else {
					return (false, index)
				}
				it.advance()
			}
			it.currentValue = offset
			offset += 1
		}
		return (true, elements.endIndex)
	}
}
@usableFromInline
@frozen internal struct _HashTable {
  @usableFromInline
  internal var _storage: DevicesCore._HashTable.Storage
  @inlinable @inline(__always) internal init(_ storage: DevicesCore._HashTable.Storage) {
		_storage = storage
	}
}
extension DevicesCore._HashTable {
  @_inheritsConvenienceInitializers @usableFromInline
  final internal class Storage : Swift.ManagedBuffer<DevicesCore._HashTable.Header, Swift.UInt64> {
    @objc @usableFromInline
    deinit
  }
}
extension DevicesCore._HashTable {
  @usableFromInline
  @_effects(releasenone) internal init(scale: Swift.Int, reservedScale: Swift.Int = 0)
  @inlinable @inline(never) @_effects(releasenone) internal static func create<C>(uncheckedUniqueElements elements: C, scale: Swift.Int? = nil, reservedScale: Swift.Int = 0) -> DevicesCore._HashTable? where C : Swift.RandomAccessCollection, C.Element : Swift.Hashable {
		let minScale = Self.scale(forCapacity: elements.count)
		let scale = Swift.max(
			Swift.max(scale ?? 0, minScale),
			reservedScale
		)
		if scale < Self.minimumScale { return nil }
		let hashTable = Self(scale: scale, reservedScale: reservedScale)
		hashTable.update { handle in
			handle.fill(uncheckedUniqueElements: elements)
		}
		return hashTable
	}
  @inlinable @inline(never) @_effects(releasenone) internal static func create<C>(untilFirstDuplicateIn elements: C, scale: Swift.Int? = nil, reservedScale: Swift.Int = 0) -> (hashTable: DevicesCore._HashTable?, end: C.Index) where C : Swift.RandomAccessCollection, C.Element : Swift.Hashable {
		let minScale = Self.scale(forCapacity: elements.count)
		let scale = Swift.max(
			Swift.max(scale ?? 0, minScale),
			reservedScale
		)
		if scale < Self.minimumScale {
			// Don't hash anything.
			if elements.count < 2 { return (nil, elements.endIndex) }
			var temp: [C.Element] = []
			temp.reserveCapacity(elements.count)
			for i in elements.indices {
				let item = elements[i]
				guard !temp.contains(item) else { return (nil, i) }
				temp.append(item)
			}
			return (nil, elements.endIndex)
		}
		let hashTable = Self(scale: scale, reservedScale: reservedScale)
		let (_, index) = hashTable.update { handle in
			handle.fill(untilFirstDuplicateIn: elements)
		}
		return (hashTable, index)
	}
  @usableFromInline
  @_effects(releasenone) internal func copy() -> DevicesCore._HashTable
}
extension DevicesCore._HashTable {
  @inlinable @inline(__always) internal func read<R>(_ body: (DevicesCore._UnsafeHashTable) throws -> R) rethrows -> R {
		try _storage.withUnsafeMutablePointers { header, elements in
			let handle = _UnsafeHashTable(header: header, buckets: elements, readonly: true)
			return try body(handle)
		}
	}
  @inlinable @inline(__always) internal func update<R>(_ body: (DevicesCore._UnsafeHashTable) throws -> R) rethrows -> R {
		try _storage.withUnsafeMutablePointers { header, elements in
			let handle = _UnsafeHashTable(header: header, buckets: elements, readonly: false)
			return try body(handle)
		}
	}
}
extension DevicesCore._HashTable {
  @inlinable internal var header: DevicesCore._HashTable.Header {
    get { _storage.header }
    @inline(__always) nonmutating _modify { yield &_storage.header }
  }
  @inlinable internal var capacity: Swift.Int {
    get {
		_storage.header.capacity
	}
  }
  @inlinable internal var minimumCapacity: Swift.Int {
    get {
		if scale == reservedScale { return 0 }
		return Self.minimumCapacity(forScale: scale)
	}
  }
  @inlinable internal var scale: Swift.Int {
    get {
		_storage.header.scale
	}
  }
  @inlinable internal var reservedScale: Swift.Int {
    get {
		_storage.header.reservedScale
	}
  }
  @inlinable internal var bias: Swift.Int {
    get {
		_storage.header.bias
	}
  }
}
extension DevicesCore._HashTable {
  @usableFromInline
  internal struct Header {
    @usableFromInline
    internal var _scaleAndSeed: Swift.UInt64
    @usableFromInline
    internal var _reservedScaleAndBias: Swift.UInt64
    @inlinable @inline(__always) internal var scale: Swift.Int {
      get { Int(_scaleAndSeed & 0x3F) }
    }
    @inlinable internal var reservedScale: Swift.Int {
      @inline(__always) get { Int(_reservedScaleAndBias & 0x3F) }
      set {
				assert(newValue >= 0 && newValue < 64)
				_reservedScaleAndBias &= ~0x3F
				_reservedScaleAndBias |= UInt64(truncatingIfNeeded: newValue) & 0x3F
			}
    }
    @inlinable @inline(__always) internal var seed: Swift.Int {
      get {
			Int(truncatingIfNeeded: _scaleAndSeed)
		}
    }
    @inlinable internal var bias: Swift.Int {
      @inline(__always) get { Int(truncatingIfNeeded: _reservedScaleAndBias) &>> 6 }
      set {
				let limit = (1 &<< scale) - 1
				var bias = newValue
				if bias < 0 { bias += limit }
				if bias >= limit { bias -= limit }
				assert(bias >= 0 && bias < limit)
				_reservedScaleAndBias &= 0x3F
				_reservedScaleAndBias |= UInt64(truncatingIfNeeded: bias) &<< 6
				assert(self.bias >= 0 && self.bias < limit)
			}
    }
    @inlinable @inline(__always) internal var capacity: Swift.Int {
      get { _HashTable.maximumCapacity(forScale: scale) }
    }
  }
}
public protocol _SortedCollection {
}
extension Swift.Slice : DevicesCore._SortedCollection where Base : DevicesCore._SortedCollection {
}
public protocol _UniqueCollection {
}
extension Swift.Set : DevicesCore._UniqueCollection {
}
extension Swift.Dictionary.Keys : DevicesCore._UniqueCollection {
}
extension Swift.Slice : DevicesCore._UniqueCollection where Base : DevicesCore._UniqueCollection {
}
@usableFromInline
@frozen internal struct _UnsafeBitset {
  @usableFromInline
  internal let _words: Swift.UnsafeMutableBufferPointer<DevicesCore._UnsafeBitset.Word>
  @usableFromInline
  internal var _count: Swift.Int
  @inlinable @inline(__always) internal init(words: Swift.UnsafeMutableBufferPointer<DevicesCore._UnsafeBitset.Word>, count: Swift.Int) {
		self._words = words
		self._count = count
	}
  @inlinable @inline(__always) internal init(words: Swift.UnsafeMutablePointer<DevicesCore._UnsafeBitset.Word>, wordCount: Swift.Int, count: Swift.Int) {
		self._words = UnsafeMutableBufferPointer(start: words, count: wordCount)
		self._count = count
	}
  @inlinable @inline(__always) internal var count: Swift.Int {
    get {
		_count
	}
  }
  @inlinable @inline(__always) internal var isEmpty: Swift.Bool {
    get {
		_count == 0
	}
  }
}
extension DevicesCore._UnsafeBitset {
  @usableFromInline
  internal var _actualCount: Swift.Int {
    get
  }
}
extension DevicesCore._UnsafeBitset {
  @inlinable @inline(__always) internal static func withTemporaryBitset<R>(capacity: Swift.Int, run body: (inout DevicesCore._UnsafeBitset) throws -> R) rethrows -> R {
		var result: R?
		try _withTemporaryBitset(capacity: capacity) { bitset in
			result = try body(&bitset)
		}
		return result!
	}
  @usableFromInline
  @inline(never) internal static func _withTemporaryBitset(capacity: Swift.Int, run body: (inout DevicesCore._UnsafeBitset) throws -> Swift.Void) rethrows
}
extension DevicesCore._UnsafeBitset {
  @usableFromInline
  @_effects(readnone) @inline(__always) internal static func wordCount(forCapacity capacity: Swift.Int) -> Swift.Int
  @usableFromInline
  @discardableResult
  @_effects(releasenone) internal mutating func insert(_ element: Swift.Int) -> Swift.Bool
  @usableFromInline
  @discardableResult
  @_effects(releasenone) internal mutating func remove(_ element: Swift.Int) -> Swift.Bool
  @usableFromInline
  @_effects(releasenone) internal mutating func clear()
  @usableFromInline
  @_effects(releasenone) internal mutating func insertAll(upTo max: Swift.Int)
  @usableFromInline
  @_effects(releasenone) internal mutating func removeAll(upTo max: Swift.Int)
}
extension DevicesCore._UnsafeBitset : Swift.Sequence {
  @usableFromInline
  internal typealias Element = Swift.Int
  @inlinable @inline(__always) internal var underestimatedCount: Swift.Int {
    get {
		count
	}
  }
  @inlinable @inline(__always) internal func makeIterator() -> DevicesCore._UnsafeBitset.Iterator {
		Iterator(self)
	}
  @usableFromInline
  @frozen internal struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal let bitset: DevicesCore._UnsafeBitset
    @usableFromInline
    internal var index: Swift.Int
    @usableFromInline
    internal var word: DevicesCore._UnsafeBitset.Word
    @inlinable internal init(_ bitset: DevicesCore._UnsafeBitset) {
			self.bitset = bitset
			self.index = 0
			self.word = bitset._words.count > 0 ? bitset._words[0] : .empty
		}
    @usableFromInline
    @_effects(releasenone) internal mutating func next() -> Swift.Int?
    @usableFromInline
    internal typealias Element = Swift.Int
  }
}
extension DevicesCore._UnsafeBitset {
  @usableFromInline
  @frozen internal struct Word {
    @usableFromInline
    internal var value: Swift.UInt
    @inlinable @inline(__always) internal init(_ value: Swift.UInt) {
			self.value = value
		}
  }
}
extension DevicesCore._UnsafeBitset.Word {
  @inlinable @inline(__always) internal static var capacity: Swift.Int {
    get {
		UInt.bitWidth
	}
  }
  @inlinable @inline(__always) internal var count: Swift.Int {
    get {
		value.nonzeroBitCount
	}
  }
  @inlinable @inline(__always) internal var isEmpty: Swift.Bool {
    get {
		value == 0
	}
  }
  @inlinable @inline(__always) internal func contains(_ bit: Swift.Int) -> Swift.Bool {
		assert(bit >= 0 && bit < UInt.bitWidth)
		return value & (1 &<< bit) != 0
	}
  @discardableResult
  @inlinable @inline(__always) internal mutating func insert(_ bit: Swift.Int) -> Swift.Bool {
		assert(bit >= 0 && bit < UInt.bitWidth)
		let mask: UInt = 1 &<< bit
		let inserted = value & mask == 0
		value |= mask
		return inserted
	}
  @discardableResult
  @inlinable @inline(__always) internal mutating func remove(_ bit: Swift.Int) -> Swift.Bool {
		assert(bit >= 0 && bit < UInt.bitWidth)
		let mask: UInt = 1 &<< bit
		let removed = value & mask != 0
		value &= ~mask
		return removed
	}
}
extension DevicesCore._UnsafeBitset.Word {
  @inlinable @inline(__always) internal mutating func insert(bitsBelow bit: Swift.Int) -> Swift.Int {
		assert(bit >= 0 && bit < Self.capacity)
		let mask: UInt = (1 as UInt &<< bit) &- 1
		let inserted = bit - (value & mask).nonzeroBitCount
		value |= mask
		return inserted
	}
  @inlinable @inline(__always) internal mutating func remove(bitsBelow bit: Swift.Int) -> Swift.Int {
		assert(bit >= 0 && bit < Self.capacity)
		let mask = UInt.max &<< bit
		let removed = (value & ~mask).nonzeroBitCount
		value &= mask
		return removed
	}
}
extension DevicesCore._UnsafeBitset.Word {
  @inlinable @inline(__always) internal static var empty: DevicesCore._UnsafeBitset.Word {
    get {
		Self(0)
	}
  }
  @inlinable @inline(__always) internal static var allBits: DevicesCore._UnsafeBitset.Word {
    get {
		Self(UInt.max)
	}
  }
}
extension DevicesCore._UnsafeBitset.Word : Swift.Sequence, Swift.IteratorProtocol {
  @inlinable internal var underestimatedCount: Swift.Int {
    get {
		count
	}
  }
  @inlinable internal mutating func next() -> Swift.Int? {
		guard value != 0 else { return nil }
		let bit = value.trailingZeroBitCount
		value &= value &- 1 // Clear lowest nonzero bit.
		return bit
	}
  @usableFromInline
  internal typealias Element = Swift.Int
  @usableFromInline
  internal typealias Iterator = DevicesCore._UnsafeBitset.Word
}
public func partialApply<A, Output>(_ function: @escaping (A) -> Output, value: A) -> () -> Output
public func partialApply<A, B, Output>(_ function: @escaping (A, B) -> Output, value: A) -> (B) -> Output
public func partialApply<A, B, C, Output>(_ function: @escaping (A, B, C) -> Output, value: A) -> (B, C) -> Output
public func partialApply<A, B, C, Output>(_ function: @escaping (A, B, C) -> Output, value1: A, value2: B) -> (C) -> Output
public func partialApply<A, B, Output>(_ function: @escaping (A, B) -> Output, value1: A, value2: B) -> () -> Output
public func partialApply<A, B, C, D, Output>(_ function: @escaping (A, B, C, D) -> Output, value1: A, value2: B, value3: C) -> (D) -> Output
public func partialApply<A, B, C, D, E, Output>(_ function: @escaping (A, B, C, D, E) -> Output, value1: A, value2: B, value3: C, value4: D) -> (E) -> Output
public func partialApply<A, B>(_ function: @escaping (Swift.Result<(A, B), Swift.Error>) -> Swift.Void, value: A) -> (Swift.Result<B, Swift.Error>) -> Swift.Void
public func partialApply<A, B, C>(_ function: @escaping (Swift.Result<(A, B, C), Swift.Error>) -> Swift.Void, value: A) -> (Swift.Result<(B, C), Swift.Error>) -> Swift.Void
public func transform<A, B, C>(_ block: @escaping (A) -> C, using transform: @escaping (B) -> A) -> (B) -> C
@discardableResult
public func with<A>(_ a: A, _ f: (A) throws -> Swift.Void) rethrows -> A
public func with<A>(_ a: inout A, _ f: (A) throws -> Swift.Void) rethrows
extension DevicesCore.KeychainAttributes.Accessibility : Swift.Equatable {}
extension DevicesCore.KeychainAttributes.Accessibility : Swift.Hashable {}
extension DevicesCore.PhoneSettingsType : Swift.Hashable {}
extension DevicesCore.ApplicationState : Swift.Equatable {}
extension DevicesCore.ApplicationState : Swift.Hashable {}
extension DevicesCore.CompressionMethod : Swift.Equatable {}
extension DevicesCore.CompressionMethod : Swift.Hashable {}
extension DevicesCore.CompressionMethod : Swift.RawRepresentable {}
extension DevicesCore.Archive.ArchiveError : Swift.Equatable {}
extension DevicesCore.Archive.ArchiveError : Swift.Hashable {}
extension DevicesCore.Archive.AccessMode : Swift.Equatable {}
extension DevicesCore.Archive.AccessMode : Swift.Hashable {}
extension DevicesCore.Archive.AccessMode : Swift.RawRepresentable {}
extension DevicesCore.AudioFileFormat : Swift.Equatable {}
extension DevicesCore.AudioFileFormat : Swift.Hashable {}
extension DevicesCore.AudioFileFormat : Swift.RawRepresentable {}
extension DevicesCore.AudioPlaybackPlayerImpl.Error : Swift.Equatable {}
extension DevicesCore.AudioPlaybackPlayerImpl.Error : Swift.Hashable {}
extension DevicesCore.AudioRecorderImpl.AudioRecorderError : Swift.Equatable {}
extension DevicesCore.AudioRecorderImpl.AudioRecorderError : Swift.Hashable {}
extension DevicesCore.AudioSourceStopReason : Swift.Equatable {}
extension DevicesCore.AudioSourceStopReason : Swift.Hashable {}
extension DevicesCore.AudioRecorderStopReason : Swift.Equatable {}
extension DevicesCore.AudioRecorderStopReason : Swift.Hashable {}
extension DevicesCore.AudioSessionConfiguratorImpl.Error : Swift.Equatable {}
extension DevicesCore.AudioSessionConfiguratorImpl.Error : Swift.Hashable {}
extension DevicesCore.AudioSessionMediaServicesEvent : Swift.Equatable {}
extension DevicesCore.AudioSessionMediaServicesEvent : Swift.Hashable {}
extension DevicesCore.AudioSessionOutputDevicePortType : Swift.Equatable {}
extension DevicesCore.AudioSessionOutputDevicePortType : Swift.Hashable {}
extension DevicesCore.AudioSessionOutputDevicePortType : Swift.RawRepresentable {}
extension DevicesCore.AudioSessionSilenceSecondaryEvent : Swift.Equatable {}
extension DevicesCore.AudioSessionSilenceSecondaryEvent : Swift.Hashable {}
extension DevicesCore.CallEndReason : Swift.Equatable {}
extension DevicesCore.CallEndReason : Swift.Hashable {}
extension DevicesCore.IncomingCallEndReason : Swift.Equatable {}
extension DevicesCore.IncomingCallEndReason : Swift.Hashable {}
extension DevicesCore.CameraFlashState : Swift.Equatable {}
extension DevicesCore.CameraFlashState : Swift.Hashable {}
extension DevicesCore.Certificate.Extension : Swift.Equatable {}
extension DevicesCore.Certificate.Extension : Swift.Hashable {}
extension DevicesCore.Certificate.Extension : Swift.RawRepresentable {}
extension DevicesCore.CertificateTrustVerifier.Error : Swift.Equatable {}
extension DevicesCore.CertificateTrustVerifier.Error : Swift.Hashable {}
extension DevicesCore.CertificateTrustVerifier.Error : Swift.RawRepresentable {}
extension DevicesCore.WebSocket.CloseCode : Swift.Equatable {}
extension DevicesCore.WebSocket.CloseCode : Swift.Hashable {}
extension DevicesCore.WebSocket.CloseCode : Swift.RawRepresentable {}
extension DevicesCore.CompilationMode : Swift.Equatable {}
extension DevicesCore.CompilationMode : Swift.Hashable {}
extension DevicesCore.Reachability.Connection : Swift.Equatable {}
extension DevicesCore.Reachability.Connection : Swift.Hashable {}
extension DevicesCore.DataHashSumStrategy : Swift.Equatable {}
extension DevicesCore.DataHashSumStrategy : Swift.Hashable {}
extension DevicesCore.DownloadURLAnswer.Error : Swift.Equatable {}
extension DevicesCore.DownloadURLAnswer.Error : Swift.Hashable {}
extension DevicesCore.EncodedAudioRecorderFactoryError : Swift.Equatable {}
extension DevicesCore.EncodedAudioRecorderFactoryError : Swift.Hashable {}
extension DevicesCore.Entry.EntryType : Swift.Equatable {}
extension DevicesCore.Entry.EntryType : Swift.Hashable {}
extension DevicesCore.Entry.EntryType : Swift.RawRepresentable {}
extension DevicesCore.WebSocket.ErrorType : Swift.Equatable {}
extension DevicesCore.WebSocket.ErrorType : Swift.Hashable {}
extension DevicesCore.HTTPMethod : Swift.Hashable {}
extension DevicesCore.HTTPMethod : Swift.RawRepresentable {}
extension DevicesCore.HashStringEncoding : Swift.Equatable {}
extension DevicesCore.HashStringEncoding : Swift.Hashable {}
extension DevicesCore.HashTrustVerifierError : Swift.Hashable {}
extension DevicesCore.HeaderBuilders.ContentType : Swift.Equatable {}
extension DevicesCore.HeaderBuilders.ContentType : Swift.Hashable {}
extension DevicesCore.HeaderBuilders.ContentType : Swift.RawRepresentable {}
extension DevicesCore.KeychainOperationStatus : Swift.Equatable {}
extension DevicesCore.KeychainOperationStatus : Swift.Hashable {}
extension DevicesCore.LogLevel : Swift.RawRepresentable {}
extension DevicesCore.MailComposeViewControllerVisibility : Swift.Hashable {}
extension DevicesCore.NavigationBarAppearance.BarStyle : Swift.Equatable {}
extension DevicesCore.NavigationBarAppearance.BarStyle : Swift.Hashable {}
extension DevicesCore._HashTable.UnsafeHandle : Swift.Sendable {}
extension DevicesCore.Permission.Kind : Swift.Equatable {}
extension DevicesCore.Permission.Kind : Swift.Hashable {}
extension DevicesCore.Permission.Kind : Swift.RawRepresentable {}
extension DevicesCore.Permission.Status : Swift.Equatable {}
extension DevicesCore.Permission.Status : Swift.Hashable {}
extension DevicesCore.Permission.Status : Swift.RawRepresentable {}
extension DevicesCore.Plist.Error : Swift.Equatable {}
extension DevicesCore.Plist.Error : Swift.Hashable {}
extension DevicesCore.ReachabilityState : Swift.Equatable {}
extension DevicesCore.ReachabilityState : Swift.Hashable {}
extension DevicesCore.ReachabilityState.Error : Swift.Hashable {}
extension DevicesCore.RemoteFileLoaderEvent : Swift.Equatable {}
extension DevicesCore.RemoteFileLoaderEvent : Swift.Hashable {}
extension DevicesCore.RemoteImageProviderFake.ProviderError : Swift.Equatable {}
extension DevicesCore.RemoteImageProviderFake.ProviderError : Swift.Hashable {}
extension DevicesCore.RequestError.NSURLErrorDomainCode : Swift.Equatable {}
extension DevicesCore.RequestError.NSURLErrorDomainCode : Swift.Hashable {}
extension DevicesCore.RequestError.NSURLErrorDomainCode : Swift.RawRepresentable {}
extension DevicesCore.SequenceTrustVerifier.Error : Swift.Hashable {}
extension DevicesCore.SerializationError : Swift.Equatable {}
extension DevicesCore.SerializationError : Swift.Hashable {}
extension DevicesCore.SoundPlayerError : Swift.Equatable {}
extension DevicesCore.SoundPlayerError : Swift.Hashable {}
extension DevicesCore.StackPresentationMode : Swift.Equatable {}
extension DevicesCore.StackPresentationMode : Swift.Hashable {}
extension DevicesCore.StackScreenInteractivity.ActionSource : Swift.Hashable {}
extension DevicesCore.StackScreenInteractivity.PushCollisionBehaviour : Swift.Equatable {}
extension DevicesCore.StackScreenInteractivity.PushCollisionBehaviour : Swift.Hashable {}
extension DevicesCore.StackScreenPresentation : Swift.Equatable {}
extension DevicesCore.StackScreenPresentation : Swift.Hashable {}
extension DevicesCore.SystemDeeplinkSchemes : Swift.Equatable {}
extension DevicesCore.SystemDeeplinkSchemes : Swift.Hashable {}
extension DevicesCore.SystemDeeplinkSchemes : Swift.RawRepresentable {}
extension DevicesCore.TapticFeedback : Swift.Hashable {}
extension DevicesCore.URLAnswer.Error : Swift.Equatable {}
extension DevicesCore.URLAnswer.Error : Swift.Hashable {}
extension DevicesCore.URLHandlerResult : Swift.Equatable {}
extension DevicesCore.URLHandlerResult : Swift.Hashable {}
extension DevicesCore.UserNotificationResponse.ActionType : Swift.Equatable {}
extension DevicesCore.UserNotificationResponse.ActionType : Swift.Hashable {}
extension DevicesCore.UserNotificationResponse.ActionType : Swift.RawRepresentable {}
extension DevicesCore.VideoCaptureSessionState : Swift.Equatable {}
extension DevicesCore.VideoCaptureSessionState : Swift.Hashable {}
extension DevicesCore.WebNavigationAction.`Type` : Swift.Equatable {}
extension DevicesCore.WebNavigationAction.`Type` : Swift.Hashable {}
extension DevicesCore.WebNavigationControllerError : Swift.Hashable {}
extension DevicesCore._HashTable.Bucket : Swift.Sendable {}
extension DevicesCore._UnsafeBitset : Swift.Sendable {}
extension DevicesCore._UnsafeBitset.Iterator : Swift.Sendable {}
extension DevicesCore._UnsafeBitset.Word : Swift.Sendable {}
