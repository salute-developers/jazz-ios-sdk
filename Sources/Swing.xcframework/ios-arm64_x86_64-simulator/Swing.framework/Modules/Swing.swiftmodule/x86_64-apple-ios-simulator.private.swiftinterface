// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.1 (swiftlang-5.7.1.135.3 clang-1400.0.29.51)
// swift-module-flags: -target x86_64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Swing
// swift-module-flags-ignorable: -enable-bare-slash-regex
import DevicesCore
import DevicesUI
import Foundation
import Swift
import UIKit
import _Concurrency
import _StringProcessing
extension DevicesCore.Property {
  public func modelRenderable<Output>(_ key: Swift.KeyPath<Value, Output>, areDuplicates: @escaping (Output, Output) -> Swift.Bool = { $0 == $1 }, transform: @escaping (Output) -> DevicesUI.ViewRenderable, animate: @escaping DevicesUI.UpdatableRenderable.Animation = { _, action in action() }) -> DevicesUI.ViewRenderable where Output : Swift.Equatable
  public func modelRenderable<Output1, Output2>(_ key1: Swift.KeyPath<Value, Output1>, _ key2: Swift.KeyPath<Value, Output2>, areDuplicates: @escaping ((Output1, Output2), (Output1, Output2)) -> Swift.Bool = {
			$0.0 == $1.0 && $0.1 == $1.1
		}, transform: @escaping (Output1, Output2) -> DevicesUI.ViewRenderable, animate: @escaping DevicesUI.UpdatableRenderable.Animation = { _, action in action() }) -> DevicesUI.ViewRenderable where Output1 : Swift.Equatable, Output2 : Swift.Equatable
}
extension DevicesUI.UpdatableRenderable {
  public static var withoutAnimation: DevicesUI.UpdatableRenderable.Animation {
    get
  }
  public static var defaultAnimation: DevicesUI.UpdatableRenderable.Animation {
    get
  }
}
extension DevicesUI.RenderingScreen {
  @_Concurrency.MainActor(unsafe) convenience public init(dispatcher: Swing.SwingControllerLifeCycleDispatcher, model: DevicesUI.ViewRenderable, context: DevicesUI.ViewContext)
}
public protocol SwingBaseConfigurator : Swing.SwingBaseModuleFactory {
  associatedtype ServiceAction where Self.ServiceAction == Self.InputReducer.ServiceAction
  associatedtype ServiceReducer : Swing.SwingServiceReducer
  associatedtype InputReducer : Swing.SwingInputReducer where Self.InputAction == Self.InputReducer.Action, Self.State == Self.InputReducer.State, Self.InputReducer.ServiceAction == Self.ServiceReducer.ServiceAction, Self.InputReducer.State == Self.ServiceReducer.State
  func makeState(data: Self.ModuleData) -> Self.State
  func makeServiceReducer(data: Self.ModuleData, outputSignal: DevicesCore.DefaultSignal<Self.OutputAction>) -> Self.ServiceReducer
  func makeInputReducer(data: Self.ModuleData, outputSignal: DevicesCore.DefaultSignal<Self.OutputAction>) -> Self.InputReducer
}
extension Swing.SwingBaseConfigurator where Self.InputReducer == Swing.SwingVoidInputReducer<Self.State, Self.ServiceAction> {
  public func makeInputReducer(data _: Self.ModuleData, outputSignal _: DevicesCore.DefaultSignal<Self.OutputAction>) -> Self.InputReducer
}
extension Swing.SwingBaseConfigurator {
  public func makeModule(data: Self.ModuleData) -> Swing.SwingBaseModule<Self.State, Self.InputAction, Self.OutputAction>
}
final public class SwingBaseModule<State, InputAction, OutputAction> {
  final public let state: DevicesCore.Property<State>
  final public let interaction: Swing.SwingModuleInteraction<InputAction, OutputAction>
  public init(state: DevicesCore.Property<State>, interaction: Swing.SwingModuleInteraction<InputAction, OutputAction>, cancellableBag: DevicesCore.CancellableBag)
  @objc deinit
}
extension Swing.SwingBaseModule {
  @inlinable final public func dispatch(action: InputAction) {
		interaction.inputDispatcher.dispatch(action: action)
	}
  @inlinable final public func subscribeOutputAction(outputAction: @escaping (OutputAction) -> Swift.Void) -> DevicesCore.AnyCancellable {
		interaction.outputSignal.sink { action in
			outputAction(action)
		}
	}
}
extension Swing.SwingBaseModule where InputAction == () {
  @inlinable final internal func dispatch() {
		dispatch(action: ())
	}
}
public struct SwingBaseModuleComponents<State, ServiceReducer, InputReducer, OutputAction> where State == ServiceReducer.State, ServiceReducer : Swing.SwingServiceReducer, InputReducer : Swing.SwingInputReducer, ServiceReducer.ServiceAction == InputReducer.ServiceAction, ServiceReducer.State == InputReducer.State {
  public init(state: State, serviceReducer: ServiceReducer, inputReducer: InputReducer, outputSignal: DevicesCore.Signal<OutputAction>)
}
extension Swing.SwingBaseModuleComponents where OutputAction == () {
  public init(state: State, serviceReducer: ServiceReducer, inputReducer: InputReducer)
}
public protocol SwingBaseModuleFactory {
  associatedtype ModuleData
  associatedtype State
  associatedtype InputAction
  associatedtype OutputAction
  func makeModule(data: Self.ModuleData) -> Swing.SwingBaseModule<Self.State, Self.InputAction, Self.OutputAction>
}
extension Swing.SwingBaseModuleFactory {
  public func buildModule<SReducer, IReducer>(components: Swing.SwingBaseModuleComponents<Self.State, SReducer, IReducer, Self.OutputAction>) -> Swing.SwingBaseModule<Self.State, Self.InputAction, Self.OutputAction> where SReducer : Swing.SwingServiceReducer, IReducer : Swing.SwingInputReducer, Self.InputAction == IReducer.Action, Self.State == SReducer.State, SReducer.ServiceAction == IReducer.ServiceAction, SReducer.State == IReducer.State
}
extension Swing.SwingBaseModuleFactory where Self.ModuleData == () {
  public func makeModule() -> Swing.SwingBaseModule<Self.State, Self.InputAction, Self.OutputAction>
}
final public class SwingBaseStore<State, ServiceAction, ServiceReducer, InputReducer> where State == ServiceReducer.State, ServiceAction == ServiceReducer.ServiceAction, ServiceReducer : Swing.SwingServiceReducer, InputReducer : Swing.SwingInputReducer, ServiceReducer.ServiceAction == InputReducer.ServiceAction, ServiceReducer.State == InputReducer.State {
  final public var state: DevicesCore.Property<State> {
    get
  }
  public init(state: State, serviceReducer: ServiceReducer, inputReducer: InputReducer, cancellableBag: inout DevicesCore.CancellableBag, asyncPerformer: DevicesCore.AsyncPerformer = DispatchQueue.main)
  final public func performService(action: ServiceAction)
  final public func makeInputDispatcher() -> Swing.SwingDispatcher<InputReducer.Action>
  @objc deinit
}
public enum SwingControllerLifeCycleAction {
  case didLoad
  case willAppear
  case didAppear
  case willDissappear
  case didDissappear
  public static func == (a: Swing.SwingControllerLifeCycleAction, b: Swing.SwingControllerLifeCycleAction) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol SwingControllerLifeCycleDispatcher {
  func dispatchViewLifeCycle(action: Swing.SwingControllerLifeCycleAction)
}
final public class SwingDispatcher<Action> {
  public init(dispatch: @escaping (Action) -> Swift.Void)
  final public func dispatch(action: Action)
  @objc deinit
}
extension Swing.SwingDispatcher {
  final public func bind<T>(signal: DevicesCore.Signal<T>, action: @escaping (T) -> Action) -> DevicesCore.Cancellable
  final public func bind<T>(property: DevicesCore.Property<T>, startWithCurrent: Swift.Bool = true, action: @escaping (T) -> Action) -> DevicesCore.Cancellable
  final public func bind<T>(signal: DevicesCore.Signal<T>, action: Action) -> DevicesCore.Cancellable
  final public func bind<T>(property: DevicesCore.Property<T>, startWithCurrent: Swift.Bool = true, action: Action) -> DevicesCore.Cancellable
}
public protocol SwingInputReducer {
  associatedtype State
  associatedtype ServiceAction
  associatedtype Action
  func setup(state: Self.State, dispatcher: Swing.SwingDispatcher<Self.ServiceAction>, cancellableBag: inout DevicesCore.CancellableBag)
  func reduce(state: Self.State, action: Self.Action, dispatcher: Swing.SwingDispatcher<Self.ServiceAction>) -> Self.State
}
extension Swing.SwingInputReducer {
  public func setup(state _: Self.State, dispatcher _: Swing.SwingDispatcher<Self.ServiceAction>, cancellableBag _: inout DevicesCore.CancellableBag)
}
public struct SwingModuleInteraction<InputAction, OutputAction> {
  public let inputDispatcher: Swing.SwingDispatcher<InputAction>
  public let outputSignal: DevicesCore.Signal<OutputAction>
  public init(inputDispatcher: Swing.SwingDispatcher<InputAction>, outputSignal: DevicesCore.Signal<OutputAction>)
}
extension Swing.SwingModuleInteraction {
  public static func emptyInteraction<InputAction, OutputAction>() -> Swing.SwingModuleInteraction<InputAction, OutputAction>
}
public protocol SwingPresentableConfigurator : Swing.SwingBaseConfigurator, Swing.SwingPresentableModuleFactory {
  associatedtype UIReducer : Swing.SwingUIReducer where Self.ServiceAction == Self.UIReducer.ServiceAction
  associatedtype Presenter : Swing.SwingPresenter where Self.State == Self.Presenter.State, Self.Presenter.State == Self.UIReducer.State
  associatedtype Renderable : DevicesUI.ViewRenderable
  func makeUIReducer(data: Self.ModuleData, outputSignal: DevicesCore.DefaultSignal<Self.OutputAction>) -> Self.UIReducer
  func makePresenter(data: Self.ModuleData) -> Self.Presenter
  func makeViewRenderable(data: Self.ModuleData, model: DevicesCore.Property<Self.Presenter.Model>, dispatcher: Swing.SwingDispatcher<Self.UIReducer.Action>, context: DevicesUI.ViewContext) -> DevicesUI.ViewRenderable
}
extension Swing.SwingPresentableConfigurator {
  public func makePresentableModule(data: Self.ModuleData, context: DevicesUI.ViewContext) -> Swing.SwingPresentableModule<Self.InputAction, Self.OutputAction>
}
extension Swing.SwingPresentableConfigurator where Self.ServiceReducer == Swing.SwingVoidServiceReducer<Self.State> {
  public func makeServiceReducer(data _: Self.ModuleData, outputSignal _: DevicesCore.DefaultSignal<Self.OutputAction>) -> Self.ServiceReducer
}
extension Swing.SwingPresentableConfigurator where Self.Renderable : Swing.SwingViewRenderable, Self.Presenter.Model == Self.Renderable.PresentationModel, Self.Renderable.UIAction == Self.UIReducer.Action {
  public func makeViewRenderable(data _: Self.ModuleData, model: DevicesCore.Property<Self.Presenter.Model>, dispatcher: Swing.SwingDispatcher<Self.UIReducer.Action>, context: DevicesUI.ViewContext) -> DevicesUI.ViewRenderable
}
public struct SwingPresentableModule<InputAction, OutputAction> {
}
public struct SwingPresentableModuleComponents<State, ServiceReducer, UIReducer, InputReducer, Presenter, OutputAction> where State == ServiceReducer.State, ServiceReducer : Swing.SwingServiceReducer, UIReducer : Swing.SwingUIReducer, InputReducer : Swing.SwingInputReducer, Presenter : Swing.SwingPresenter, ServiceReducer.ServiceAction == UIReducer.ServiceAction, ServiceReducer.State == UIReducer.State, UIReducer.ServiceAction == InputReducer.ServiceAction, UIReducer.State == InputReducer.State, InputReducer.State == Presenter.State {
  public typealias ViewRenderableFactory = DevicesCore.Factory<(DevicesCore.Property<Presenter.Model>, Swing.SwingDispatcher<UIReducer.Action>), DevicesUI.ViewRenderable>
  public init(state: State, serviceReducer: ServiceReducer, uiReducer: UIReducer, inputReducer: InputReducer, outputSignal: DevicesCore.Signal<OutputAction>, presenter: Presenter, viewRenderableFactory: Swing.SwingPresentableModuleComponents<State, ServiceReducer, UIReducer, InputReducer, Presenter, OutputAction>.ViewRenderableFactory)
}
public protocol SwingPresentableModuleFactory : Swing.SwingBaseModuleFactory {
  func makePresentableModule(data: Self.ModuleData, context: DevicesUI.ViewContext) -> Swing.SwingPresentableModule<Self.InputAction, Self.OutputAction>
  func makeScreen(data: Self.ModuleData, dispatcher: Swing.SwingControllerLifeCycleDispatcher, renderable: DevicesUI.ViewRenderable, context: DevicesUI.ViewContext) -> DevicesCore.Screen
  func makeRenderableModule(data: Self.ModuleData, context: DevicesUI.ViewContext) -> (model: DevicesUI.ViewRenderable, interaction: Swing.SwingModuleInteraction<Self.InputAction, Self.OutputAction>)
  func makeScreenModule(data: Self.ModuleData, context: DevicesUI.ViewContext) -> (screen: DevicesCore.Screen, interaction: Swing.SwingModuleInteraction<Self.InputAction, Self.OutputAction>)
}
extension Swing.SwingPresentableModuleFactory {
  public func factory(context: DevicesUI.ViewContext) -> DevicesCore.Factory<Self.ModuleData, DevicesCore.Screen>
  public func makeScreen(data _: Self.ModuleData, dispatcher: Swing.SwingControllerLifeCycleDispatcher, renderable: DevicesUI.ViewRenderable, context: DevicesUI.ViewContext) -> DevicesCore.Screen
  public func makeRenderableModule(data: Self.ModuleData, context: DevicesUI.ViewContext) -> (model: DevicesUI.ViewRenderable, interaction: Swing.SwingModuleInteraction<Self.InputAction, Self.OutputAction>)
  public func makeScreenModule(data: Self.ModuleData, context: DevicesUI.ViewContext) -> (screen: DevicesCore.Screen, interaction: Swing.SwingModuleInteraction<Self.InputAction, Self.OutputAction>)
}
extension Swing.SwingPresentableModuleFactory {
  public func buildPresentableModule<SReducer, UIReducer, IReducer, Presenter>(components: Swing.SwingPresentableModuleComponents<Self.State, SReducer, UIReducer, IReducer, Presenter, Self.OutputAction>) -> Swing.SwingPresentableModule<Self.InputAction, Self.OutputAction> where SReducer : Swing.SwingServiceReducer, UIReducer : Swing.SwingUIReducer, IReducer : Swing.SwingInputReducer, Presenter : Swing.SwingPresenter, Self.InputAction == IReducer.Action, Self.State == SReducer.State, SReducer.ServiceAction == UIReducer.ServiceAction, SReducer.State == UIReducer.State, UIReducer.ServiceAction == IReducer.ServiceAction, UIReducer.State == IReducer.State, IReducer.State == Presenter.State
}
extension Swing.SwingPresentableModuleFactory where Self.ModuleData == () {
  public func makeRenderableModule(context: DevicesUI.ViewContext) -> (model: DevicesUI.ViewRenderable, interaction: Swing.SwingModuleInteraction<Self.InputAction, Self.OutputAction>)
  public func makeScreenModule(context: DevicesUI.ViewContext) -> (screen: DevicesCore.Screen, interaction: Swing.SwingModuleInteraction<Self.InputAction, Self.OutputAction>)
}
final public class SwingPresentableStore<State, ServiceAction, UIReducer, ServiceReducer, InputReducer> where State == UIReducer.State, ServiceAction == UIReducer.ServiceAction, UIReducer : Swing.SwingUIReducer, ServiceReducer : Swing.SwingServiceReducer, InputReducer : Swing.SwingInputReducer, UIReducer.ServiceAction == ServiceReducer.ServiceAction, UIReducer.State == ServiceReducer.State, ServiceReducer.ServiceAction == InputReducer.ServiceAction, ServiceReducer.State == InputReducer.State {
  final public var state: DevicesCore.Property<State> {
    get
  }
  public init(state: State, uiReducer: UIReducer, serviceReducer: ServiceReducer, inputReducer: InputReducer, asyncPerformer: DevicesCore.AsyncPerformer = DispatchQueue.main)
  final public func performUI(action: UIReducer.Action)
  final public func performService(action: ServiceReducer.ServiceAction)
  final public func makeInputDispatcher() -> Swing.SwingDispatcher<InputReducer.Action>
  @objc deinit
}
extension Swing.SwingPresentableStore : Swing.SwingControllerLifeCycleDispatcher {
  final public func dispatchViewLifeCycle(action: Swing.SwingControllerLifeCycleAction)
}
public protocol SwingPresenter {
  associatedtype State
  associatedtype Model
  func makeModel(state: Self.State) -> Self.Model
}
public protocol SwingServiceReducer {
  associatedtype State
  associatedtype ServiceAction
  func setup(state: Self.State, dispatcher: Swing.SwingDispatcher<Self.ServiceAction>, cancellableBag: inout DevicesCore.CancellableBag)
  func reduce(state: Self.State, action: Self.ServiceAction, dispatcher: Swing.SwingDispatcher<Self.ServiceAction>) -> Self.State
}
extension Swing.SwingServiceReducer {
  public func setup(state _: Self.State, dispatcher _: Swing.SwingDispatcher<Self.ServiceAction>, cancellableBag _: inout DevicesCore.CancellableBag)
}
public protocol SwingUIReducer : Swing.SwingInputReducer {
  func reduceViewLifeCycle(state: Self.State, action: Swing.SwingControllerLifeCycleAction, dispatcher: Swing.SwingDispatcher<Self.ServiceAction>) -> Self.State
}
extension Swing.SwingUIReducer {
  public func reduceViewLifeCycle(state: Self.State, action _: Swing.SwingControllerLifeCycleAction, dispatcher _: Swing.SwingDispatcher<Self.ServiceAction>) -> Self.State
}
public protocol SwingViewRenderable : DevicesUI.SingleSubjectRenderable {
  associatedtype PresentationModel
  associatedtype UIAction
  typealias Dispatcher = Swing.SwingDispatcher<Self.UIAction>
  init(model: DevicesCore.Property<Self.PresentationModel>, dispatcher: Self.Dispatcher, context: DevicesUI.ViewContext)
}
final public class SwingVoidInputReducer<State, ServiceAction> : Swing.SwingInputReducer {
  public typealias Action = Swift.Void
  public init()
  final public func reduce(state: State, action _: Swing.SwingVoidInputReducer<State, ServiceAction>.Action, dispatcher _: Swing.SwingDispatcher<ServiceAction>) -> State
  @objc deinit
}
final public class SwingVoidServiceReducer<State> : Swing.SwingServiceReducer {
  public typealias ServiceAction = Swift.Void
  public init()
  final public func reduce(state: State, action _: Swift.Void, dispatcher _: Swing.SwingDispatcher<Swift.Void>) -> State
  @objc deinit
}
extension Swing.SwingControllerLifeCycleAction : Swift.Equatable {}
extension Swing.SwingControllerLifeCycleAction : Swift.Hashable {}
