// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.1 (swiftlang-5.7.1.135.3 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name JazzImpl
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import AVKit
import Combine
import CompanionCore
import CoreGraphics
import DevicesCore
import DevicesDesignSystem
import DevicesUI
import Foundation
import JazzAPI
import JazzCore
import JazzServices
import JazzStrings
import LibSberCast
import ReplayKit
import SaluteDesignSystem
import StoreKit
import Swift
import SwiftUI
import Swing
import UIKit
import WebRTC
import _Concurrency
import _StringProcessing
public protocol AnalyticsParameter {
  var analyticsPrimitive: JazzImpl.AnalyticsParameterPrimitive { get }
}
public enum AnalyticsParameterPrimitive {
  case int(Swift.Int)
  case double(Swift.Double)
  case string(Swift.String)
  case bool(Swift.Bool)
}
extension DevicesCore.Tagged : JazzImpl.AnalyticsParameter where T : JazzImpl.AnalyticsParameter {
  public var analyticsPrimitive: JazzImpl.AnalyticsParameterPrimitive {
    get
  }
}
extension Swift.String : JazzImpl.AnalyticsParameter {
  public var analyticsPrimitive: JazzImpl.AnalyticsParameterPrimitive {
    get
  }
}
extension Swift.Int : JazzImpl.AnalyticsParameter {
  public var analyticsPrimitive: JazzImpl.AnalyticsParameterPrimitive {
    get
  }
}
extension Swift.Bool : JazzImpl.AnalyticsParameter {
  public var analyticsPrimitive: JazzImpl.AnalyticsParameterPrimitive {
    get
  }
}
extension Swift.Double : JazzImpl.AnalyticsParameter {
  public var analyticsPrimitive: JazzImpl.AnalyticsParameterPrimitive {
    get
  }
}
extension Swift.AnyCollection : Swift.Equatable where Element : Swift.Equatable {
  public static func == (lhs: Swift.AnyCollection<Element>, rhs: Swift.AnyCollection<Element>) -> Swift.Bool
}
public enum ApplinkError : Swift.Error, Foundation.LocalizedError, Swift.Equatable {
  case unsupportedUrlBase
  case noRoomID
  case noRoomPassword
  case incorrectPasswordFormat
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: JazzImpl.ApplinkError, b: JazzImpl.ApplinkError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum ApplinkTarget : Swift.Equatable {
  public typealias Result = Swift.Result<JazzImpl.ApplinkTarget, JazzImpl.ApplinkError>
  case joinConferenceRoom(JazzAPI.PublicRoom)
  case joinWebinar(room: JazzAPI.PublicRoom, userRole: JazzAPI.PrivateRoom.UserRole)
  case joinSaluteclassConference(room: JazzAPI.PublicRoom, token: JazzAPI.JazzAuthToken?)
  case createConferenceRoom
  case shareLink(JazzAPI.PublicRoom, JazzImpl.ShareLinkType)
  case joinSberStaffRoom(JazzAPI.PublicRoom)
  public static func == (a: JazzImpl.ApplinkTarget, b: JazzImpl.ApplinkTarget) -> Swift.Bool
}
public struct ApplinkTargetParser {
  public init(coder: JazzAPI.PasswordCoder)
  public func parse(applink: DevicesCore.Deeplink) -> JazzImpl.ApplinkTarget.Result
}
public struct CallAlert {
  public let appearance: CompanionCore.BannerSheetModel.Appearance
  public let content: CompanionCore.InfoScreenContent
  public let onOkPressed: () -> Swift.Void
  public init(appearance: CompanionCore.BannerSheetModel.Appearance, content: CompanionCore.InfoScreenContent, onOkPressed: @escaping () -> Swift.Void)
}
extension JazzImpl.CallAlert : Swift.Equatable {
  public static func == (lhs: JazzImpl.CallAlert, rhs: JazzImpl.CallAlert) -> Swift.Bool
}
public enum CallError : Swift.Equatable {
  case dropInCallStartFailed(reason: DevicesUI.StringContent)
  case joinConferenceProcessingError(reason: DevicesUI.StringContent)
  case joinConferenceCompletionError(reason: DevicesUI.StringContent)
  public static func == (lhs: JazzImpl.CallError, rhs: JazzImpl.CallError) -> Swift.Bool
}
public struct CodeInputModel {
  public let title: DevicesUI.StringContent
  public let description: DevicesUI.StringContent
  public let onCodeEntered: (DevicesDesignSystem.CodeEraser, Swift.String) -> Swift.Void
  public let onBack: () -> Swift.Void
}
public enum ConferenceAsrState {
  case enabled
  case disabled
  case loading
  public static func == (a: JazzImpl.ConferenceAsrState, b: JazzImpl.ConferenceAsrState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ConferenceDurationState : Swift.Equatable {
  public enum ExpireTime : Swift.Equatable {
    case unlimited
    case limited(timeLeft: Foundation.TimeInterval)
    case expired
    public static func == (a: JazzImpl.ConferenceDurationState.ExpireTime, b: JazzImpl.ConferenceDurationState.ExpireTime) -> Swift.Bool
  }
  public var duration: Foundation.TimeInterval
  public var expireTime: JazzImpl.ConferenceDurationState.ExpireTime
  public static func == (a: JazzImpl.ConferenceDurationState, b: JazzImpl.ConferenceDurationState) -> Swift.Bool
}
public enum ConferenceFeatureAllowanceState : Swift.Equatable {
  public enum LimitedState {
    case disabledRequestForbidden
    case disabledCanRequest
    case allowed
    public static func == (a: JazzImpl.ConferenceFeatureAllowanceState.LimitedState, b: JazzImpl.ConferenceFeatureAllowanceState.LimitedState) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  case limited(JazzImpl.ConferenceFeatureAllowanceState.LimitedState)
  case allowed
  public static func == (a: JazzImpl.ConferenceFeatureAllowanceState, b: JazzImpl.ConferenceFeatureAllowanceState) -> Swift.Bool
}
public struct ConferenceFeatureState<FeatureState> {
}
extension JazzImpl.ConferenceFeatureState : Swift.Equatable where FeatureState : Swift.Equatable {
  public static func == (a: JazzImpl.ConferenceFeatureState<FeatureState>, b: JazzImpl.ConferenceFeatureState<FeatureState>) -> Swift.Bool
}
public enum ConferenceJoinWaitingReason {
  case adminHasntJoined
  case needsAdminPermission
  public static func == (a: JazzImpl.ConferenceJoinWaitingReason, b: JazzImpl.ConferenceJoinWaitingReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ConferenceMediaFeatureState : Swift.Equatable {
  case on
  case off
  case offAndDisabled
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: JazzImpl.ConferenceMediaFeatureState, b: JazzImpl.ConferenceMediaFeatureState) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public typealias ConferenceMediaState = JazzImpl.ConferenceFeatureState<JazzImpl.ConferenceMediaFeatureState>
extension JazzImpl.ConferenceFeatureState where FeatureState == JazzImpl.ConferenceMediaFeatureState {
  public static var allowedOn: JazzImpl.ConferenceMediaState {
    get
  }
  public static var allowedOff: JazzImpl.ConferenceMediaState {
    get
  }
}
public struct ConferenceMenuPresentationModel {
}
public struct ConferenceMenuState : Swift.Equatable {
  public static func == (a: JazzImpl.ConferenceMenuState, b: JazzImpl.ConferenceMenuState) -> Swift.Bool
}
public struct ConferenceMeta : Swift.Equatable {
  public let conferenceType: JazzAPI.AnalyticsConferenceType
  public let userRole: Swift.String
  public let roomId: JazzAPI.PublicRoom.ID?
  public init(conferenceType: JazzAPI.AnalyticsConferenceType, userRole: Swift.String, roomId: JazzAPI.PublicRoom.ID?)
  public static func == (a: JazzImpl.ConferenceMeta, b: JazzImpl.ConferenceMeta) -> Swift.Bool
}
public enum ConferenceParticipantsLayout : Swift.String, Swift.CaseIterable, Swift.Equatable {
  case speaker
  case tile
  public init?(rawValue: Swift.String)
  public typealias AllCases = [JazzImpl.ConferenceParticipantsLayout]
  public typealias RawValue = Swift.String
  public static var allCases: [JazzImpl.ConferenceParticipantsLayout] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public typealias RequestReview = () -> Swift.Void
public struct ConferenceToastMeta {
  public struct LinkAlertData {
    public let text: Swift.String
    public let linkText: Swift.String
    public let url: Foundation.URL
    public let uprTapped: (Foundation.URL) -> Swift.Void
  }
  public enum ToastType {
    case alert(DevicesCore.ImageID?, DevicesUI.StringContent)
    case message(DevicesCore.ImageID?)
    case linkAlert(JazzImpl.ConferenceToastMeta.LinkAlertData)
  }
  public enum Priority : Swift.Int {
    case normal
    case high
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public let toastType: JazzImpl.ConferenceToastMeta.ToastType
  public let title: DevicesUI.StringContent
  public let duration: Foundation.TimeInterval
  public let priority: JazzImpl.ConferenceToastMeta.Priority
  public let gravity: DevicesDesignSystem.Toast.Gravity
  public let id: Foundation.UUID
  public init(toastType: JazzImpl.ConferenceToastMeta.ToastType, title: DevicesUI.StringContent, duration: Foundation.TimeInterval = 5, priority: JazzImpl.ConferenceToastMeta.Priority = .normal, gravity: DevicesDesignSystem.Toast.Gravity = .bottom, id: Foundation.UUID = UUID())
}
extension JazzImpl.ConferenceToastMeta : Swift.Equatable {
  public static func == (lhs: JazzImpl.ConferenceToastMeta, rhs: JazzImpl.ConferenceToastMeta) -> Swift.Bool
}
extension JazzImpl.ConferenceToastMeta.LinkAlertData : Swift.Equatable {
  public static func == (lhs: JazzImpl.ConferenceToastMeta.LinkAlertData, rhs: JazzImpl.ConferenceToastMeta.LinkAlertData) -> Swift.Bool
}
extension JazzImpl.ConferenceToastMeta.ToastType : Swift.Equatable {
  public static func == (lhs: JazzImpl.ConferenceToastMeta.ToastType, rhs: JazzImpl.ConferenceToastMeta.ToastType) -> Swift.Bool
}
public enum ConnectionStage : Swift.Equatable {
  public enum TerminationReason : Swift.Equatable, Swift.Error {
    case rejectedByRecipient
    case userCanceled
    case alreadyInCall
    case webinarUnsupported
    case kickedFromConference(JazzServices.ConferenceKickReason)
    case rejectedDueToConferenceError(JazzServices.ConferenceError)
    case network(JazzServices.ConferenceConnectionError)
    public static func == (a: JazzImpl.ConnectionStage.TerminationReason, b: JazzImpl.ConnectionStage.TerminationReason) -> Swift.Bool
  }
  case connecting
  case terminated(reason: JazzImpl.ConnectionStage.TerminationReason)
  public static func == (a: JazzImpl.ConnectionStage, b: JazzImpl.ConnectionStage) -> Swift.Bool
}
public struct DesignSpecs {
  public static let itemMaxWidth: CoreFoundation.CGFloat
  public static let itemMiddleWidth: CoreFoundation.CGFloat
  public static let thumbnailHeight: CoreFoundation.CGFloat
  public static let thumbnailWidth: CoreFoundation.CGFloat
  public static let thumbnailIpadHeight: CoreFoundation.CGFloat
  public static let thumbnailIpadWidth: CoreFoundation.CGFloat
}
extension DevicesUI.Gradient {
  public static var jazzBackground: DevicesUI.ViewRenderable {
    get
  }
}
extension JazzImpl.IncomingCallToastModel : DevicesUI.ViewRenderable {
  public func renderView(context: DevicesUI.ViewContext, reusing view: DevicesUI.View?) -> DevicesUI.View
}
public struct IncomingCallToastModel {
  public let initiatorName: Swift.String
  public let initiatorInitials: Swift.String
  public let description: Swift.String
  public let acceptAction: () -> Swift.Void
  public let declineAction: () -> Swift.Void
  public init(initiatorName: Swift.String, initiatorInitials: Swift.String, description: Swift.String, acceptAction: @escaping () -> Swift.Void, declineAction: @escaping () -> Swift.Void)
}
public struct InviteState {
  public enum Expiration : Swift.Equatable {
    case valid
    case expiring
    case expired
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: JazzImpl.InviteState.Expiration, b: JazzImpl.InviteState.Expiration) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public struct JazzAnalyticsFeature {
  public let analyticsService: DevicesCore.AnalyticsService
  public let surface: JazzServices.Surface
  public init(analyticsService: DevicesCore.AnalyticsService, surface: JazzServices.Surface)
}
final public class JazzAnalyticsManagerImpl : DevicesCore.AnalyticsService {
  final public var jazzMetaProvider: JazzServices.JazzMetaProvider?
  public init(analyticsService: DevicesCore.AnalyticsService, jazzAnalyticsService: JazzImpl.JazzAnalyticsService, timerScheduler: DevicesCore.TimerScheduler, jazzEventSignal: DevicesCore.Signal<JazzAPI.JazzEvent>)
  @objc deinit
  final public func send(_ event: DevicesCore.AnalyticsEvent)
}
public protocol JazzAnalyticsSendService {
  func send(_ parameters: JazzServices.AnalyticsRequestParameters, backendURL: JazzAPI.BackendURL)
}
final public class JazzAnalyticsSendServiceImpl : JazzImpl.JazzAnalyticsSendService {
  public init(analyticsRequestPerformer: JazzServices.AnalyticsRequestPerformer)
  final public func send(_ parameters: JazzServices.AnalyticsRequestParameters, backendURL: JazzAPI.BackendURL)
  @objc deinit
}
public protocol JazzAnalyticsService {
  func send(_ parameters: [JazzServices.SingleAnalyticsEventParameters], host: JazzAPI.JazzHost?)
}
final public class JazzAnalyticsServiceImpl : JazzImpl.JazzAnalyticsService {
  public init(backendURLResolver: JazzServices.BackendURLResolver, analyticsSendService: JazzImpl.JazzAnalyticsSendService)
  final public func send(_ parameters: [JazzServices.SingleAnalyticsEventParameters], host: JazzAPI.JazzHost?)
  @objc deinit
}
public typealias JazzAuthType = DevicesCore.Tagged<JazzImpl.JazzAuthTypeTag, Swift.String>
public enum JazzAuthTypeTag {
}
extension DevicesCore.Tagged where Tag == JazzImpl.JazzAuthTypeTag, T == Swift.String {
  public static let anonymous: JazzImpl.JazzAuthType
}
public struct JazzAuthorizationFeature {
  public let isAuthorized: DevicesCore.Property<Swift.Bool>
  public let authType: DevicesCore.Property<JazzImpl.JazzAuthType>
  public let isRequiredForProcessingLinks: Swift.Bool
  public let conferenceTokenProvider: JazzAPI.ConferenceTokenProvider
  public let authorizationLauncher: JazzAPI.AuthorizationLauncher?
  public init(isAuthorized: DevicesCore.Property<Swift.Bool>, isRequiredForLinks: Swift.Bool, conferenceTokenProvider: JazzAPI.ConferenceTokenProvider, authorizationLauncher: JazzAPI.AuthorizationLauncher?, authType: DevicesCore.Property<JazzImpl.JazzAuthType>)
}
extension JazzImpl.JazzAuthorizationFeature : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct JazzConferenceInviteFeature {
  public struct CustomInviteButton {
    public struct RoomDetails : Swift.Equatable {
      public let room: JazzAPI.PublicRoom
      public let url: Foundation.URL
      public init(room: JazzAPI.PublicRoom, url: Foundation.URL)
      public static func == (a: JazzImpl.JazzConferenceInviteFeature.CustomInviteButton.RoomDetails, b: JazzImpl.JazzConferenceInviteFeature.CustomInviteButton.RoomDetails) -> Swift.Bool
    }
    public let title: Swift.String
    public let action: (JazzImpl.JazzConferenceInviteFeature.CustomInviteButton.RoomDetails) -> Swift.Void
    public init(title: Swift.String, action: @escaping (JazzImpl.JazzConferenceInviteFeature.CustomInviteButton.RoomDetails) -> Swift.Void)
  }
  public let customInviteButton: JazzImpl.JazzConferenceInviteFeature.CustomInviteButton?
  public let shouldShowSharingScreenInNewConference: Swift.Bool
  public init(customInviteButton: JazzImpl.JazzConferenceInviteFeature.CustomInviteButton?, shouldShowSharingScreenInNewConference: Swift.Bool)
}
extension JazzImpl.JazzConferenceInviteFeature : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension JazzAPI.JazzConferenceVisibilitySettings {
  public static let allVisible: JazzAPI.JazzConferenceVisibilitySettings
}
extension JazzAPI.JazzConferenceVisibilitySettings {
  public static func allVisibleByDefault(isSettingsVisible: Swift.Bool = true, isToggleReactionsVisible: Swift.Bool = true, isOpenChatVisible: Swift.Bool = true, isBackVisible: Swift.Bool = true, isParticipantListVisible: Swift.Bool = true, isCreatePollVisible: Swift.Bool = true, isChangeLayoutVisible: Swift.Bool = true, isShareConferenceLinkVisible: Swift.Bool = true, isSwitchCameraVisible: Swift.Bool = true, isRaiseHandVisible: Swift.Bool = true, isTransitionToDeviceVisible: Swift.Bool = true, isPinUserVisible: Swift.Bool = true, isShareScreenVisible: Swift.Bool = true, isConferenceMenuVisible: Swift.Bool = true, isAsrVisible: Swift.Bool = true) -> JazzAPI.JazzConferenceVisibilitySettings
}
public enum JazzGraphFactory {
  public static func make(context: DevicesUI.ViewContext, notificationCenter: Foundation.NotificationCenter, darwinNotificationCenter: DevicesCore.DarwinNotificationCenter, storage: DevicesCore.KeyValueStorage, clientIDStorage: JazzServices.ClientIDStorage, screenOrientationController: DevicesUI.ScreenOrientationController, specs: JazzAPI.JazzSpecs, defaultVisibilitySettings: JazzAPI.JazzConferenceVisibilitySettings, settings: JazzImpl.JazzSettings, analyticsFeature: JazzImpl.JazzAnalyticsFeature, navigationFeature: JazzImpl.JazzNavigationFeature, networkFeature: JazzImpl.JazzNetworkFeature, mediaFeature: JazzImpl.JazzMediaFeature, inviteFeature: JazzImpl.JazzConferenceInviteFeature, authorizationFeature: JazzImpl.JazzAuthorizationFeature?, screenShareFeature: JazzImpl.JazzScreenShareFeature?, profileSyncFeature: JazzImpl.JazzProfileSyncFeature?, loggingFeature: JazzImpl.JazzLoggingFeature, assertionCaller: DevicesCore.AssertionCaller, license: DevicesCore.Property<JazzAPI.JazzLicense?>, conferenceRateService: JazzAPI.ConferenceRateService, surface: JazzServices.Surface, secretKey: Swift.String) -> JazzAPI.JazzGraph
}
public struct JazzInlineAlert {
  public enum Kind : Swift.Equatable {
    case failedToConnect
    case notConnectedToServer
    case deniedForNonSbStaffUser
    case unauthorized(domain: Swift.String?)
    case accessDenied(domain: Swift.String?)
    case conferneceTerminatedByAdmin
    case accessError
    case discoveryError
    case connectionError
    case webinarUnsupported
    case deviceCastError
    case maxParticipantsReached(Swift.Int)
    case conferenceNotFound
    public static func == (a: JazzImpl.JazzInlineAlert.Kind, b: JazzImpl.JazzInlineAlert.Kind) -> Swift.Bool
  }
  public let kind: JazzImpl.JazzInlineAlert.Kind
  public let description: DevicesUI.StringContent
  public let onRetry: () -> Swift.Void
  public let onContinue: () -> Swift.Void
  public let onOpen: () -> Swift.Void
  public let onBack: () -> Swift.Void
  public let shouldShowBackButton: Swift.Bool
  public init(kind: JazzImpl.JazzInlineAlert.Kind, description: DevicesUI.StringContent = ExternalString(value: ""), shouldShowBackButton: Swift.Bool = true, onRetry: @escaping () -> Swift.Void = {}, onContinue: @escaping () -> Swift.Void = {}, onOpen: @escaping () -> Swift.Void = {}, onBack: @escaping () -> Swift.Void)
}
extension JazzImpl.JazzInlineAlert : Swift.Equatable {
  public static func == (lhs: JazzImpl.JazzInlineAlert, rhs: JazzImpl.JazzInlineAlert) -> Swift.Bool
}
public protocol JazzLauncher {
  func launch()
}
public struct JazzLauncherImpl : JazzImpl.JazzLauncher {
  public init(profileUserNameStorage: CompanionCore.ProfileUserNameStorage)
  public func launch()
}
public struct JazzLoggingFeature {
  public let logger: DevicesCore.Logger
  public let videoPlayerLogLevel: JazzAPI.JazzVideoPlayerLogLevel
  public let jitsiLogLevel: DevicesCore.LogLevel
  public let logStorageService: JazzImpl.LogStorageService?
  public init(logger: DevicesCore.Logger, videoPlayerLogLevel: JazzAPI.JazzVideoPlayerLogLevel, jitsiLogLevel: DevicesCore.LogLevel, logStorageService: JazzImpl.LogStorageService?)
}
extension JazzImpl.JazzLoggingFeature : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct JazzMediaFeature {
  public let audioSessionController: DevicesCore.AudioSessionController
  public let audioSessionConfigurator: DevicesCore.AudioSessionConfigurator
  public let videoCaptureSessionFactory: DevicesCore.VideoCaptureSessionFactory
  public init(audioSessionController: DevicesCore.AudioSessionController, audioSessionConfigurator: DevicesCore.AudioSessionConfigurator, videoCaptureSessionFactory: DevicesCore.VideoCaptureSessionFactory)
}
extension JazzImpl.JazzMediaFeature : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct JazzNavigationFeature {
  public let stackScreenPresenter: DevicesCore.StackScreenPresenter
  public let bannerSheetUIBuilder: CompanionCore.BannerSheetUIBuilder
  public let toastRouter: DevicesDesignSystem.ToastRouter
  public let linkHandler: DevicesCore.URLHandler
  public init(stackScreenPresenter: DevicesCore.StackScreenPresenter, bannerSheetUIBuilder: CompanionCore.BannerSheetUIBuilder, toastRouter: DevicesDesignSystem.ToastRouter, linkHandler: DevicesCore.URLHandler)
}
public struct JazzNetworkFeature {
  public let defaultHostForJoiningConference: JazzAPI.JazzHost
  public let defaultConnectionHost: DevicesCore.Property<JazzAPI.JazzHost>
  public let deserializationContext: DevicesCore.DeserializationContext
  public let urlRequestPerformer: DevicesCore.URLRequestPerformer
  public let reachabilityState: DevicesCore.Property<DevicesCore.ReachabilityState>
  public let rtcRequestPinning: DevicesCore.SecurityChallengeReceiver?
  public init(defaultHostForJoiningConference: JazzAPI.JazzHost, defaultConnectionHost: DevicesCore.Property<JazzAPI.JazzHost>, deserializationContext: DevicesCore.DeserializationContext, urlRequestPerformer: DevicesCore.URLRequestPerformer, reachabilityState: DevicesCore.Property<DevicesCore.ReachabilityState>, rtcRequestPinning: DevicesCore.SecurityChallengeReceiver?)
}
extension JazzImpl.JazzNetworkFeature : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
final public class JazzNetworkPerformer : DevicesCore.URLRequestPerformer {
  public init(performer: DevicesCore.URLRequestPerformer, jazzAuthType: DevicesCore.Property<JazzImpl.JazzAuthType>, jazzUAParametersProvider: JazzImpl.JazzUAParametersProvider, clientId: JazzServices.ClientID)
  final public func perform(_ request: Foundation.URLRequest, cancelToken: DevicesCore.CancellationToken?, completion: @escaping (Swift.Result<DevicesCore.URLAnswer, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public struct JazzProfileSyncFeature {
  public let profileUserNameStorageDependency: CompanionCore.ProfileUserNameStorage
  public let shouldSyncUserNameWithStorage: DevicesCore.Property<Swift.Bool>
  public init(profileUserNameStorageDependency: CompanionCore.ProfileUserNameStorage, shouldSyncUserNameWithStorage: DevicesCore.Property<Swift.Bool>)
}
extension JazzImpl.JazzProfileSyncFeature : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct JazzScreenShareFeature {
  public let extensionIdentifier: Swift.String
  public init(extensionIdentifier: Swift.String)
}
extension JazzImpl.JazzScreenShareFeature : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct JazzSettings {
  public struct Ranges {
    public let userNameRange: Swift.ClosedRange<Swift.Int>
    public let conferenceNameRange: Swift.ClosedRange<Swift.Int>
    public let roomPasswordRange: Swift.ClosedRange<Swift.Int>
    public let roomNameRange: Swift.ClosedRange<Swift.Int>
    public let searchTextRange: Swift.ClosedRange<Swift.Int>
    public init(userNameRange: Swift.ClosedRange<Swift.Int> = 1 ... 200, conferenceNameRange: Swift.ClosedRange<Swift.Int> = 1 ... 200, roomPasswordRange: Swift.ClosedRange<Swift.Int> = 8 ... 8, roomNameRange: Swift.ClosedRange<Swift.Int> = 1 ... 200, searchTextRange: Swift.ClosedRange<Swift.Int> = 1 ... 200)
  }
  public struct CoreSettings {
    public let conferenceWillExpireSoonTimeInterval: Foundation.TimeInterval
    public let shouldCheckIfInActiveConference: Swift.Bool
    public let serverRecordInfoLimit: Swift.Int
    public init(conferenceWillExpireSoonTimeInterval: Foundation.TimeInterval = .fiveMinutes, shouldCheckIfInActiveConference: Swift.Bool = true, serverRecordInfoLimit: Swift.Int = 3)
  }
  public struct SupportURLS {
    public let internalSupportPhoneNumberURL: Foundation.URL
    public let externalSupportPhoneNumberURL: Foundation.URL
    public let technicalSupportFormURL: Foundation.URL
    public let isTechnicalSupportEnabled: Swift.Bool
    public let freeSupportFirstPhoneNumberURL: Foundation.URL
    public let freeSupportSecondPhoneNumberURL: Foundation.URL
    public let corporateSupportFirstPhoneNumberURL: Foundation.URL
    public let corporateSupportSecondPhoneNumberURL: Foundation.URL
    public let faqURL: Foundation.URL
    public let authorizedUserTelegramSupport: Foundation.URL
    public let unauthorizedUserTelegramSupport: Foundation.URL
    public init(internalSupportPhoneNumberURL: Foundation.URL = "tel://855711000", externalSupportPhoneNumberURL: Foundation.URL = "tel://88005559340", technicalSupportFormURL: Foundation.URL = "https://sberfriend.sbrf.ru/sberfriend/#/interaction/new?elementId=2700", isTechnicalSupportEnabled: Swift.Bool = false, freeSupportFirstPhoneNumberURL: Foundation.URL = "tel://900", freeSupportSecondPhoneNumberURL: Foundation.URL = "tel://+74955005550", corporateSupportFirstPhoneNumberURL: Foundation.URL = "tel://88003006556", corporateSupportSecondPhoneNumberURL: Foundation.URL = "tel://+74996738583", faqURL: Foundation.URL = "https://sberdevices.ru/help/jazz/", authorizedUserTelegramSupport: Foundation.URL = "https://t.me/jazz_support_bot", unauthorizedUserTelegramSupport: Foundation.URL = "https://t.me/sberdevices_support_bot")
  }
  public struct SigmaSettings {
    public let defaultSberbankHost: JazzAPI.JazzHost
    public let sbChatDeeplinkScheme: Swift.String
    public let sbChatSetupURL: Foundation.URL
    public init(defaultSberbankHost: JazzAPI.JazzHost = .defaultSberbankHost, sbChatDeeplinkScheme: Swift.String = "sberchat://", sbChatSetupURL: Foundation.URL = "https://sberchat.sberbank.ru/ios/")
  }
  public let ranges: JazzImpl.JazzSettings.Ranges
  public let core: JazzImpl.JazzSettings.CoreSettings
  public let support: JazzImpl.JazzSettings.SupportURLS
  public let sigma: JazzImpl.JazzSettings.SigmaSettings
  public init(ranges: JazzImpl.JazzSettings.Ranges = JazzSettings.Ranges(), coreSettings: JazzImpl.JazzSettings.CoreSettings = JazzSettings.CoreSettings(), supportURLs: JazzImpl.JazzSettings.SupportURLS = JazzSettings.SupportURLS(), sigmaSettings: JazzImpl.JazzSettings.SigmaSettings = SigmaSettings())
}
extension DevicesCore.Tagged where Tag == JazzAPI.JazzHostTag, T == JazzAPI.Host {
  public static let defaultSberbankHost: JazzAPI.JazzHost
}
extension JazzImpl.JazzSettings {
  public static let defaultSettings: JazzImpl.JazzSettings
}
public struct JazzSpaticalAudioFeature {
  public let sparticalAudioXShift: DevicesCore.Property<Swift.Int>
  public let sparticalAudioYShift: DevicesCore.Property<Swift.Int>
  public let sparticalAudioZShift: DevicesCore.Property<Swift.Int>
  public init(sparticalAudioXShift: DevicesCore.Property<Swift.Int>, sparticalAudioYShift: DevicesCore.Property<Swift.Int>, sparticalAudioZShift: DevicesCore.Property<Swift.Int>)
}
extension JazzImpl.JazzSpaticalAudioFeature : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol JazzUAParametersProvider {
  var uaValue: Swift.String { get }
}
final public class JazzUAParametersProviderImpl : JazzImpl.JazzUAParametersProvider {
  public init(bundle: Foundation.Bundle, surface: JazzServices.Surface)
  final public var uaValue: Swift.String {
    get
  }
  @objc deinit
}
public protocol LogFileManager {
  func createFile(logs: [DevicesCore.LogEntry], completion: @escaping (Swift.Result<Foundation.URL, JazzImpl.LogFileManagerError>) -> Swift.Void)
  func deleteFile(at url: Foundation.URL, completion: @escaping (Swift.Result<Swift.Void, JazzImpl.LogFileManagerError>) -> Swift.Void)
  func zippedFile(from url: Foundation.URL, completion: @escaping (Swift.Result<Foundation.URL, JazzImpl.LogFileManagerError>) -> Swift.Void)
  func getZipURLs(completion: @escaping (Swift.Result<[Foundation.URL], JazzImpl.LogFileManagerError>) -> Swift.Void)
  func checkIsFileEmpty(with url: Foundation.URL, completion: @escaping (Swift.Bool) -> Swift.Void)
}
public enum LogFileManagerError : Swift.Error {
  case create(Foundation.URL)
  case delete(Foundation.URL)
  case zip(Foundation.URL)
  case convertLogToData([DevicesCore.LogEntry])
  case getZipURLs(Foundation.URL)
}
final public class LogFileManagerImpl : JazzImpl.LogFileManager {
  public init(fileManager: DevicesCore.FileManagerTwin, timeFormatter: DevicesCore.DateFormatterTwin, logger: DevicesCore.Logger, logsDirectory: Foundation.URL, dateProvider: @escaping DevicesCore.DateProvider, asyncPerformer: DevicesCore.AsyncPerformer = DispatchSerialQueue(
			label: "ru.sberbank.sberdevices.jazz.logFileManager",
			qos: .background
		))
  final public func createFile(logs: [DevicesCore.LogEntry], completion: @escaping (Swift.Result<Foundation.URL, JazzImpl.LogFileManagerError>) -> Swift.Void)
  final public func deleteFile(at url: Foundation.URL, completion: @escaping (Swift.Result<Swift.Void, JazzImpl.LogFileManagerError>) -> Swift.Void)
  final public func zippedFile(from url: Foundation.URL, completion: @escaping (Swift.Result<Foundation.URL, JazzImpl.LogFileManagerError>) -> Swift.Void)
  final public func getZipURLs(completion: @escaping (Swift.Result<[Foundation.URL], JazzImpl.LogFileManagerError>) -> Swift.Void)
  final public func checkIsFileEmpty(with url: Foundation.URL, completion: @escaping (Swift.Bool) -> Swift.Void)
  @objc deinit
}
public typealias LogStorageService = DevicesCore.LogStorage & DevicesCore.Logger
public protocol MessagesCompressService {
  func compress(messages: [JazzServices.ChatMessageModel]) -> Foundation.URL
}
public typealias PollID = DevicesCore.Tagged<JazzImpl.PollIDTag, Swift.String>
public enum PollIDTag {
}
public struct Poll : Swift.Equatable {
  public let id: JazzImpl.PollID
  public let name: Swift.String
  public let questions: [JazzImpl.PollQuestion]
  public init(id: JazzImpl.PollID, name: Swift.String, questions: [JazzImpl.PollQuestion])
  public static func == (a: JazzImpl.Poll, b: JazzImpl.Poll) -> Swift.Bool
}
public struct PollAnswer : Swift.Equatable {
  public var answer: Swift.String
  public var isSelected: Swift.Bool
  public init(answer: Swift.String, isSelected: Swift.Bool)
  public static func == (a: JazzImpl.PollAnswer, b: JazzImpl.PollAnswer) -> Swift.Bool
}
public struct PollQuestion : Swift.Equatable {
  public var question: Swift.String
  public var answers: [JazzImpl.PollAnswer]
  public var isMultiSelectionAllowed: Swift.Bool
  public init(question: Swift.String, answers: [JazzImpl.PollAnswer], isMultiSelectionAllowed: Swift.Bool)
  public static func == (a: JazzImpl.PollQuestion, b: JazzImpl.PollQuestion) -> Swift.Bool
}
public enum PollState : Swift.Equatable {
  public enum ActivePollState : Swift.Equatable {
    case inProgress(votedUsers: Swift.Int, totalVotedUsers: Swift.Int)
    case polling
    case resultCollected(votedUsers: Swift.Int, totalVotedUsers: Swift.Int)
    case showingResult(votedUsers: Swift.Int, totalVotedUsers: Swift.Int)
    case observingResult(votedUsers: Swift.Int, totalVotedUsers: Swift.Int)
    case finishing
    public static func == (a: JazzImpl.PollState.ActivePollState, b: JazzImpl.PollState.ActivePollState) -> Swift.Bool
  }
  case notStarted
  case stated(JazzImpl.Poll, JazzImpl.PollState.ActivePollState)
  public static func == (a: JazzImpl.PollState, b: JazzImpl.PollState) -> Swift.Bool
}
public struct PollVoitedAnswer : Swift.Equatable {
  public var answer: Swift.String
  public var percent: Swift.Float
  public var isSelected: Swift.Bool
  public init(answer: Swift.String, percent: Swift.Float, isSelected: Swift.Bool)
  public static func == (a: JazzImpl.PollVoitedAnswer, b: JazzImpl.PollVoitedAnswer) -> Swift.Bool
}
public struct PollVoitedQuestion : Swift.Equatable {
  public var question: Swift.String
  public var answers: [JazzImpl.PollVoitedAnswer]
  public init(question: Swift.String, answers: [JazzImpl.PollVoitedAnswer])
  public static func == (a: JazzImpl.PollVoitedQuestion, b: JazzImpl.PollVoitedQuestion) -> Swift.Bool
}
extension DevicesCore.Tagged where Tag == DevicesCore.PrefixedKeyValueStorage.PrefixTag, T == Swift.String {
  public static let jazz: DevicesCore.Tagged<DevicesCore.PrefixedKeyValueStorage.PrefixTag, Swift.String>
}
extension DevicesCore.Property {
  public func combineLatest<T, U>(startWithCurrent: Swift.Bool = true, with: DevicesCore.Property<T>, transform: @escaping (Value, T) -> U) -> DevicesCore.Property<U>
  public func combineLatest<T>(startWithCurrent: Swift.Bool = true, with: DevicesCore.Property<T>) -> DevicesCore.Property<(Value, T)>
}
extension DevicesCore.MutableProperty {
  public func combineLatest<T, U>(startWithCurrent: Swift.Bool = true, with: DevicesCore.Property<T>, transform: @escaping (Value, T) -> U) -> DevicesCore.Property<U>
  public func combineLatest<T>(startWithCurrent: Swift.Bool = true, with: DevicesCore.Property<T>) -> DevicesCore.Property<(Value, T)>
}
public enum RecipientAvatar : DevicesUI.SingleSubjectRenderable {
  case nameInitials(DevicesUI.StringContent, _: DevicesDesignSystem.Typeface = .headline2)
  case photo(DevicesUI.ImageContent)
  public var subject: DevicesUI.ViewRenderable {
    get
  }
}
public struct RenderableContent : Swift.Equatable {
  public static func == (_: JazzImpl.RenderableContent, _: JazzImpl.RenderableContent) -> Swift.Bool
}
public enum RoomLinkingState : Swift.Equatable {
  case inProgress
  case linked(JazzAPI.PublicRoom, JazzAPI.PrivateRoom.ID)
  public static func == (a: JazzImpl.RoomLinkingState, b: JazzImpl.RoomLinkingState) -> Swift.Bool
}
extension Swift.Sequence {
  public func sorted(using descriptors: [JazzImpl.SortDescriptor<Self.Element>], order: JazzImpl.SortOrder = .ascending) -> [Self.Element]
  public func sorted(using descriptors: JazzImpl.SortDescriptor<Self.Element>..., order: JazzImpl.SortOrder = .ascending) -> [Self.Element]
}
public protocol ServerRecordInfoCountStorage {
  func serverRecordInfoToastShown()
  func shouldShowRecordsLocationInfo() -> Swift.Bool
}
final public class ServerRecordStopCountStorageImpl : JazzImpl.ServerRecordInfoCountStorage {
  public init(storage: DevicesCore.KeyValueStorage, settings: JazzImpl.JazzSettings)
  @objc deinit
}
extension JazzImpl.ServerRecordStopCountStorageImpl {
  final public func serverRecordInfoToastShown()
  final public func shouldShowRecordsLocationInfo() -> Swift.Bool
}
public enum ShareLinkType : Swift.Equatable {
  case `default`
  case device(settings: JazzImpl.ShareLinkType.Settings)
  case webinar(_: JazzImpl.ShareLinkType.WebinarRole)
  public static func == (a: JazzImpl.ShareLinkType, b: JazzImpl.ShareLinkType) -> Swift.Bool
}
extension JazzImpl.ShareLinkType {
  public struct Settings : Swift.Equatable {
    public static func == (a: JazzImpl.ShareLinkType.Settings, b: JazzImpl.ShareLinkType.Settings) -> Swift.Bool
  }
  public enum WebinarRole : Swift.String, Swift.Equatable {
    case viewer
    case speaker
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
public protocol OptionalProtocol {
  associatedtype Wrapped
  var value: Self.Wrapped? { get }
  init(nilLiteral: ())
  init(_ some: Self.Wrapped)
}
extension Swift.Optional : JazzImpl.OptionalProtocol {
  public var value: Wrapped? {
    get
  }
}
extension JazzImpl.SortDescriptor {
  public static func keyPath<T>(_ keyPath: Swift.KeyPath<Value, T>) -> JazzImpl.SortDescriptor<Value> where T : Swift.Comparable
}
extension JazzImpl.SortDescriptor {
  public static func keyPath<T>(_ keyPath: Swift.KeyPath<Value, T>, orderDecider: @escaping (T, T) -> Foundation.ComparisonResult) -> JazzImpl.SortDescriptor<Value>
  public static func boolKeyPath(_ keyPath: Swift.KeyPath<Value, Swift.Bool>, prioritize: Swift.Bool = true) -> JazzImpl.SortDescriptor<Value>
}
extension JazzImpl.SortDescriptor where Value : Swift.Equatable {
  public static func equal(_ object: Value?) -> JazzImpl.SortDescriptor<Value>
}
public struct SortDescriptor<Value> {
  public var comparator: (Value, Value) -> Foundation.ComparisonResult
}
public enum SortOrder {
  case ascending
  case descending
  public static func == (a: JazzImpl.SortOrder, b: JazzImpl.SortOrder) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ToastImageID : Swift.String, DevicesCore.ImageID, Swift.CaseIterable {
  case done
  case close
  public func hash(into hasher: inout Swift.Hasher)
  public init?(rawValue: Swift.String)
  public typealias AllCases = [JazzImpl.ToastImageID]
  public typealias RawValue = Swift.String
  public static var allCases: [JazzImpl.ToastImageID] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension JazzImpl.ToastImageID {
  public var name: Swift.String {
    get
  }
}
public protocol UIAccessibilityTwin {
  static var isVoiceOverRunning: Swift.Bool { get }
  static var voiceOverStatusDidChangeNotification: Foundation.Notification.Name { get }
}
extension UIKit.UIAccessibility : JazzImpl.UIAccessibilityTwin {
}
final public class VoiceOverObserver {
  final public var isVoiceOverRunning: DevicesCore.Property<Swift.Bool> {
    get
  }
  public init(accessibility: JazzImpl.UIAccessibilityTwin.Type = UIAccessibility.self, notificationCenter: Foundation.NotificationCenter = .default)
  @objc deinit
}
extension JazzImpl.ApplinkError : Swift.Hashable {}
extension JazzImpl.ConferenceAsrState : Swift.Equatable {}
extension JazzImpl.ConferenceAsrState : Swift.Hashable {}
extension JazzImpl.ConferenceFeatureAllowanceState.LimitedState : Swift.Equatable {}
extension JazzImpl.ConferenceFeatureAllowanceState.LimitedState : Swift.Hashable {}
extension JazzImpl.ConferenceJoinWaitingReason : Swift.Equatable {}
extension JazzImpl.ConferenceJoinWaitingReason : Swift.Hashable {}
extension JazzImpl.ConferenceMediaFeatureState : Swift.Hashable {}
extension JazzImpl.ConferenceParticipantsLayout : Swift.Hashable {}
extension JazzImpl.ConferenceParticipantsLayout : Swift.RawRepresentable {}
extension JazzImpl.ConferenceToastMeta.Priority : Swift.Equatable {}
extension JazzImpl.ConferenceToastMeta.Priority : Swift.Hashable {}
extension JazzImpl.ConferenceToastMeta.Priority : Swift.RawRepresentable {}
extension JazzImpl.InviteState.Expiration : Swift.Hashable {}
extension JazzImpl.ShareLinkType.WebinarRole : Swift.Hashable {}
extension JazzImpl.ShareLinkType.WebinarRole : Swift.RawRepresentable {}
extension JazzImpl.SortOrder : Swift.Equatable {}
extension JazzImpl.SortOrder : Swift.Hashable {}
extension JazzImpl.ToastImageID : Swift.Equatable {}
extension JazzImpl.ToastImageID : Swift.Hashable {}
extension JazzImpl.ToastImageID : Swift.RawRepresentable {}
