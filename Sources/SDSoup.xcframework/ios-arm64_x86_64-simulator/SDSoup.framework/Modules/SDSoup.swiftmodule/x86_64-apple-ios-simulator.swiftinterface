// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.2 (swiftlang-6.0.2.1.2 clang-1600.0.26.4)
// swift-module-flags: -target x86_64-apple-ios15.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 6 -enforce-exclusivity=checked -O -module-name SDSoup
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import Accelerate
import Combine
import Compression
import CoreFoundation
import CoreGraphics
import Darwin
import Foundation
import Network
import Photos
import QuartzCore
@_exported import SDSoup
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
import UserNotifications
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os
public struct ABTest {
  public let groups: [SDSoup.ABTestGroup]
  public let segments: [SDSoup.ABTestSegment]
  public var groupsList: Swift.String {
    get
  }
  public var segmentsList: Swift.String {
    get
  }
  public init(groups: [SDSoup.ABTestGroup], segments: [SDSoup.ABTestSegment])
  public func hasGroup(_ group: SDSoup.ABTestGroup) -> Swift.Bool
  public func hasSegment(_ segment: SDSoup.ABTestSegment) -> Swift.Bool
}
extension SDSoup.ABTest {
  public static func groupsFromString(_ string: Swift.String) -> [SDSoup.ABTestGroup]
  public static func segmentsFromString(_ string: Swift.String) -> [SDSoup.ABTestSegment]
  public static func stringFromGroups(_ groups: [SDSoup.ABTestGroup]) -> Swift.String
  public static func stringFromSegments(_ segments: [SDSoup.ABTestSegment]) -> Swift.String
}
public typealias ABTestGroup = SDSoup.Tagged<SDSoup.ABTestGroupTag, Swift.String>
public enum ABTestGroupTag {
}
public typealias ABTestSegment = SDSoup.Tagged<SDSoup.ABTestSegmentTag, Swift.String>
public enum ABTestSegmentTag {
}
public typealias AccessToken = SDSoup.Tagged<SDSoup.AccessTokenTag, Swift.String>
public enum AccessTokenTag {
}
public typealias AdvertisingID = SDSoup.Tagged<SDSoup.AdvertisingIDTag, Swift.String>
extension SDSoup.Tagged where Tag == SDSoup.AdvertisingIDTag, T == Swift.String {
  public init?(_ uuid: Foundation.UUID)
}
public enum AdvertisingIDTag {
}
extension SDSoup.StagedChangeset where Collection : Swift.RangeReplaceableCollection, Collection.Element : SDSoup.ContentEquatable, Collection.Element : SDSoup.ContentIdentifiable {
  @inlinable public init(source: Collection, target: Collection) {
        self.init(source: source, target: target, section: 0)
    }
  @inlinable public init(source: Collection, target: Collection, section: Swift.Int) {
        let sourceElements = ContiguousArray(source)
        let targetElements = ContiguousArray(target)

         
        if sourceElements.isEmpty && targetElements.isEmpty {
            self.init()
            return
        }

         
        if !sourceElements.isEmpty && targetElements.isEmpty {
            self.init(
                [
                    Changeset(
                        data: target,
                        elementDeleted: sourceElements.indices.map { ElementPath(element: $0, section: section) }
                    ),
                ]
            )
            return
        }

         
        if sourceElements.isEmpty && !targetElements.isEmpty {
            self.init(
                [
                    Changeset(
                        data: target,
                        elementInserted: targetElements.indices.map { ElementPath(element: $0, section: section) }
                    ),
                ]
            )
            return
        }

        var firstStageElements = ContiguousArray<Collection.Element>()
        var secondStageElements = ContiguousArray<Collection.Element>()

        let result = diff(
            source: sourceElements,
            target: targetElements,
            useTargetIndexForUpdated: false,
            mapIndex: { ElementPath(element: $0, section: section) },
            updatedElementsPointer: &firstStageElements,
            notDeletedElementsPointer: &secondStageElements
        )

        var changesets = ContiguousArray<Changeset<Collection>>()

         
         
         
        if !result.updated.isEmpty {
            changesets.append(
                Changeset(
                    data: Collection(firstStageElements),
                    elementUpdated: result.updated
                )
            )
        }

         
         
         
        if !result.deleted.isEmpty {
            changesets.append(
                Changeset(
                    data: Collection(secondStageElements),
                    elementDeleted: result.deleted
                )
            )
        }

         
         
         
         
        if !result.inserted.isEmpty || !result.moved.isEmpty {
            changesets.append(
                Changeset(
                    data: target,
                    elementInserted: result.inserted,
                    elementMoved: result.moved
                )
            )
        }

         
        if !changesets.isEmpty {
            let index = changesets.index(before: changesets.endIndex)
            changesets[index].data = target
        }

        self.init(changesets)
    }
}
extension SDSoup.StagedChangeset where Collection : Swift.RangeReplaceableCollection, Collection.Element : SDSoup.DifferentiableSection {
  @inlinable public init(source: Collection, target: Collection) {
        typealias Section = Collection.Element
        typealias SectionIdentifier = Collection.Element.DifferenceIdentifier
        typealias Element = Collection.Element.Collection.Element
        typealias ElementIdentifier = Collection.Element.Collection.Element.DifferenceIdentifier

        let sourceSections = ContiguousArray(source)
        let targetSections = ContiguousArray(target)

        let contiguousSourceSections = ContiguousArray(sourceSections.map { ContiguousArray($0.elements) })
        let contiguousTargetSections = ContiguousArray(targetSections.map { ContiguousArray($0.elements) })

        var firstStageSections = sourceSections
        var secondStageSections = ContiguousArray<Section>()
        var thirdStageSections = ContiguousArray<Section>()
        var fourthStageSections = ContiguousArray<Section>()

        var sourceElementTraces = contiguousSourceSections.map { section in
            ContiguousArray(repeating: Trace<ElementPath>(), count: section.count)
        }
        var targetElementReferences = contiguousTargetSections.map { section in
            ContiguousArray<ElementPath?>(repeating: nil, count: section.count)
        }

        let flattenSourceCount = contiguousSourceSections.reduce(into: 0) { $0 += $1.count }
        var flattenSourceIdentifiers = ContiguousArray<ElementIdentifier>()
        var flattenSourceElementPaths = ContiguousArray<ElementPath>()

        thirdStageSections.reserveCapacity(contiguousTargetSections.count)
        fourthStageSections.reserveCapacity(contiguousTargetSections.count)

        flattenSourceIdentifiers.reserveCapacity(flattenSourceCount)
        flattenSourceElementPaths.reserveCapacity(flattenSourceCount)

         

        let sectionResult = diff(
            source: sourceSections,
            target: targetSections,
            useTargetIndexForUpdated: true,
            mapIndex: { $0 }
        )

         

        var elementDeleted = [ElementPath]()
        var elementInserted = [ElementPath]()
        var elementUpdated = [ElementPath]()
        var elementMoved = [(source: ElementPath, target: ElementPath)]()

        for sourceSectionIndex in contiguousSourceSections.indices {
            for sourceElementIndex in contiguousSourceSections[sourceSectionIndex].indices {
                let sourceElementPath = ElementPath(element: sourceElementIndex, section: sourceSectionIndex)
                let sourceElement = contiguousSourceSections[sourceElementPath]
                flattenSourceIdentifiers.append(sourceElement.differenceIdentifier)
                flattenSourceElementPaths.append(sourceElementPath)
            }
        }

        flattenSourceIdentifiers.withUnsafeBufferPointer { bufferPointer in
             
            var sourceOccurrencesTable = [TableKey<ElementIdentifier>: Occurrence](minimumCapacity: flattenSourceCount)

             
            for flattenSourceIndex in flattenSourceIdentifiers.indices {
                let pointer = bufferPointer.baseAddress!.advanced(by: flattenSourceIndex)
                let key = TableKey(pointer: pointer)

                switch sourceOccurrencesTable[key] {
                case .none:
                    sourceOccurrencesTable[key] = .unique(index: flattenSourceIndex)

                case let .unique(otherIndex)?:
                    let reference = IndicesReference([otherIndex, flattenSourceIndex])
                    sourceOccurrencesTable[key] = .duplicate(reference: reference)

                case let .duplicate(reference)?:
                    reference.push(flattenSourceIndex)
                }
            }

             
            for targetSectionIndex in contiguousTargetSections.indices {
                let targetElements = contiguousTargetSections[targetSectionIndex]

                for targetElementIndex in targetElements.indices {
                    var targetIdentifier = targetElements[targetElementIndex].differenceIdentifier
                    let key = TableKey(pointer: &targetIdentifier)

                    switch sourceOccurrencesTable[key] {
                    case .none:
                        break

                    case let .unique(flattenSourceIndex)?:
                        let sourceElementPath = flattenSourceElementPaths[flattenSourceIndex]
                        let targetElementPath = ElementPath(element: targetElementIndex, section: targetSectionIndex)

                        if case .none = sourceElementTraces[sourceElementPath].reference {
                            targetElementReferences[targetElementPath] = sourceElementPath
                            sourceElementTraces[sourceElementPath].reference = targetElementPath
                        }

                    case let .duplicate(reference)?:
                        if let flattenSourceIndex = reference.next() {
                            let sourceElementPath = flattenSourceElementPaths[flattenSourceIndex]
                            let targetElementPath = ElementPath(element: targetElementIndex, section: targetSectionIndex)
                            targetElementReferences[targetElementPath] = sourceElementPath
                            sourceElementTraces[sourceElementPath].reference = targetElementPath
                        }
                    }
                }
            }
        }

         
        for sourceSectionIndex in contiguousSourceSections.indices {
            let sourceSection = sourceSections[sourceSectionIndex]
            let sourceElements = contiguousSourceSections[sourceSectionIndex]
            var firstStageElements = sourceElements

             
            if case .some = sectionResult.sourceTraces[sourceSectionIndex].reference {
                var offsetByDelete = 0

                var secondStageElements = ContiguousArray<Element>()

                for sourceElementIndex in sourceElements.indices {
                    let sourceElementPath = ElementPath(element: sourceElementIndex, section: sourceSectionIndex)

                    sourceElementTraces[sourceElementPath].deleteOffset = offsetByDelete

                     
                    if let targetElementPath = sourceElementTraces[sourceElementPath].reference,
                       case .some = sectionResult.targetReferences[targetElementPath.section] {
                        let targetElement = contiguousTargetSections[targetElementPath]
                        firstStageElements[sourceElementIndex] = targetElement
                        secondStageElements.append(targetElement)
                        continue
                    }

                    elementDeleted.append(sourceElementPath)
                    sourceElementTraces[sourceElementPath].isTracked = true
                    offsetByDelete += 1
                }

                let secondStageSection = Section(source: sourceSection, elements: secondStageElements)
                secondStageSections.append(secondStageSection)
            }

            let firstStageSection = Section(source: sourceSection, elements: firstStageElements)
            firstStageSections[sourceSectionIndex] = firstStageSection
        }

         
        for targetSectionIndex in contiguousTargetSections.indices {
             
            guard let sourceSectionIndex = sectionResult.targetReferences[targetSectionIndex] else {
                thirdStageSections.append(targetSections[targetSectionIndex])
                fourthStageSections.append(targetSections[targetSectionIndex])
                continue
            }

            var untrackedSourceIndex: Int? = 0
            let targetElements = contiguousTargetSections[targetSectionIndex]

            let sectionDeleteOffset = sectionResult.sourceTraces[sourceSectionIndex].deleteOffset

            let thirdStageSection = secondStageSections[sourceSectionIndex - sectionDeleteOffset]
            thirdStageSections.append(thirdStageSection)

            var fourthStageElements = ContiguousArray<Element>()
            fourthStageElements.reserveCapacity(targetElements.count)

            for targetElementIndex in targetElements.indices {
                untrackedSourceIndex = untrackedSourceIndex.flatMap { index in
                    sourceElementTraces[sourceSectionIndex].suffix(from: index).firstIndex { !$0.isTracked }
                }

                let targetElementPath = ElementPath(element: targetElementIndex, section: targetSectionIndex)
                let targetElement = contiguousTargetSections[targetElementPath]

                 
                guard let sourceElementPath = targetElementReferences[targetElementPath],
                      let movedSourceSectionIndex = sectionResult.sourceTraces[sourceElementPath.section].reference
                else {
                    fourthStageElements.append(targetElement)
                    elementInserted.append(targetElementPath)
                    continue
                }

                sourceElementTraces[sourceElementPath].isTracked = true

                let sourceElement = contiguousSourceSections[sourceElementPath]
                fourthStageElements.append(targetElement)

                if !targetElement.isContentEqual(to: sourceElement) {
                    elementUpdated.append(sourceElementPath)
                }

                if sourceElementPath.section != sourceSectionIndex || sourceElementPath.element != untrackedSourceIndex {
                    let deleteOffset = sourceElementTraces[sourceElementPath].deleteOffset
                    let moveSourceElementPath = ElementPath(
                        element: sourceElementPath.element - deleteOffset,
                        section: movedSourceSectionIndex
                    )
                    elementMoved.append((source: moveSourceElementPath, target: targetElementPath))
                }
            }

            let fourthStageSection = Section(source: thirdStageSection, elements: fourthStageElements)
            fourthStageSections.append(fourthStageSection)
        }

        var changesets = ContiguousArray<Changeset<Collection>>()

         
         
         
        if !elementUpdated.isEmpty {
            changesets.append(
                Changeset(
                    data: Collection(firstStageSections),
                    elementUpdated: elementUpdated
                )
            )
        }

         
         
         
         
        if !sectionResult.deleted.isEmpty || !elementDeleted.isEmpty {
            changesets.append(
                Changeset(
                    data: Collection(secondStageSections),
                    sectionDeleted: sectionResult.deleted,
                    elementDeleted: elementDeleted
                )
            )
        }

         
         
         
         
        if !sectionResult.inserted.isEmpty || !sectionResult.moved.isEmpty {
            changesets.append(
                Changeset(
                    data: Collection(thirdStageSections),
                    sectionInserted: sectionResult.inserted,
                    sectionMoved: sectionResult.moved
                )
            )
        }

         
         
         
         
        if !elementInserted.isEmpty || !elementMoved.isEmpty {
            changesets.append(
                Changeset(
                    data: Collection(fourthStageSections),
                    elementInserted: elementInserted,
                    elementMoved: elementMoved
                )
            )
        }

         
         
         
        if !sectionResult.updated.isEmpty {
            changesets.append(
                Changeset(
                    data: target,
                    sectionUpdated: sectionResult.updated
                )
            )
        }

         
        if !changesets.isEmpty {
            let index = changesets.index(before: changesets.endIndex)
            changesets[index].data = target
        }

        self.init(changesets)
    }
}
@discardableResult
@inlinable internal func diff<E, I>(source: Swift.ContiguousArray<E>, target: Swift.ContiguousArray<E>, useTargetIndexForUpdated: Swift.Bool, mapIndex: (Swift.Int) -> I, updatedElementsPointer: Swift.UnsafeMutablePointer<Swift.ContiguousArray<E>>? = nil, notDeletedElementsPointer: Swift.UnsafeMutablePointer<Swift.ContiguousArray<E>>? = nil) -> SDSoup.DiffResult<I> where E : SDSoup.ContentEquatable, E : SDSoup.ContentIdentifiable {
    var deleted = [I]()
    var inserted = [I]()
    var updated = [I]()
    var moved = [(source: I, target: I)]()

    var sourceTraces = ContiguousArray<Trace<Int>>()
    var sourceIdentifiers = ContiguousArray<E.DifferenceIdentifier>()
    var targetReferences = ContiguousArray<Int?>(repeating: nil, count: target.count)

    sourceTraces.reserveCapacity(source.count)
    sourceIdentifiers.reserveCapacity(source.count)

    for sourceElement in source {
        sourceTraces.append(Trace())
        sourceIdentifiers.append(sourceElement.differenceIdentifier)
    }

    sourceIdentifiers.withUnsafeBufferPointer { bufferPointer in
         
        var sourceOccurrencesTable = [TableKey<E.DifferenceIdentifier>: Occurrence](minimumCapacity: source.count)

         
        for sourceIndex in sourceIdentifiers.indices {
            let pointer = bufferPointer.baseAddress!.advanced(by: sourceIndex)
            let key = TableKey(pointer: pointer)

            switch sourceOccurrencesTable[key] {
            case .none:
                sourceOccurrencesTable[key] = .unique(index: sourceIndex)

            case let .unique(otherIndex)?:
                let reference = IndicesReference([otherIndex, sourceIndex])
                sourceOccurrencesTable[key] = .duplicate(reference: reference)

            case let .duplicate(reference)?:
                reference.push(sourceIndex)
            }
        }

         
        for targetIndex in target.indices {
            var targetIdentifier = target[targetIndex].differenceIdentifier
            let key = TableKey(pointer: &targetIdentifier)

            switch sourceOccurrencesTable[key] {
            case .none:
                break

            case let .unique(sourceIndex)?:
                if case .none = sourceTraces[sourceIndex].reference {
                    targetReferences[targetIndex] = sourceIndex
                    sourceTraces[sourceIndex].reference = targetIndex
                }

            case let .duplicate(reference)?:
                if let sourceIndex = reference.next() {
                    targetReferences[targetIndex] = sourceIndex
                    sourceTraces[sourceIndex].reference = targetIndex
                }
            }
        }
    }

    var offsetByDelete = 0
    var untrackedSourceIndex: Int? = 0

     
    for sourceIndex in source.indices {
        sourceTraces[sourceIndex].deleteOffset = offsetByDelete

        if let targetIndex = sourceTraces[sourceIndex].reference {
            let targetElement = target[targetIndex]
            updatedElementsPointer?.pointee.append(targetElement)
            notDeletedElementsPointer?.pointee.append(targetElement)
        } else {
            let sourceElement = source[sourceIndex]
            deleted.append(mapIndex(sourceIndex))
            sourceTraces[sourceIndex].isTracked = true
            offsetByDelete += 1
            updatedElementsPointer?.pointee.append(sourceElement)
        }
    }

     
    for targetIndex in target.indices {
        untrackedSourceIndex = untrackedSourceIndex.flatMap { index in
            sourceTraces.suffix(from: index).firstIndex { !$0.isTracked }
        }

        if let sourceIndex = targetReferences[targetIndex] {
            sourceTraces[sourceIndex].isTracked = true

            let sourceElement = source[sourceIndex]
            let targetElement = target[targetIndex]

            if !targetElement.isContentEqual(to: sourceElement) {
                updated.append(mapIndex(useTargetIndexForUpdated ? targetIndex : sourceIndex))
            }

            if sourceIndex != untrackedSourceIndex {
                let deleteOffset = sourceTraces[sourceIndex].deleteOffset
                moved.append((source: mapIndex(sourceIndex - deleteOffset), target: mapIndex(targetIndex)))
            }
        } else {
            inserted.append(mapIndex(targetIndex))
        }
    }

    return DiffResult(
        deleted: deleted,
        inserted: inserted,
        updated: updated,
        moved: moved,
        sourceTraces: sourceTraces,
        targetReferences: targetReferences
    )
}
@usableFromInline
internal struct DiffResult<Index> {
  @usableFromInline
  internal let deleted: [Index]
  @usableFromInline
  internal let inserted: [Index]
  @usableFromInline
  internal let updated: [Index]
  @usableFromInline
  internal let moved: [(source: Index, target: Index)]
  @usableFromInline
  internal let sourceTraces: Swift.ContiguousArray<SDSoup.Trace<Swift.Int>>
  @usableFromInline
  internal let targetReferences: Swift.ContiguousArray<Swift.Int?>
  @usableFromInline
  internal init(deleted: [Index] = [], inserted: [Index] = [], updated: [Index] = [], moved: [(source: Index, target: Index)] = [], sourceTraces: Swift.ContiguousArray<SDSoup.Trace<Swift.Int>>, targetReferences: Swift.ContiguousArray<Swift.Int?>)
}
@usableFromInline
internal struct Trace<Index> {
  @usableFromInline
  internal var reference: Index?
  @usableFromInline
  internal var deleteOffset: Swift.Int
  @usableFromInline
  internal var isTracked: Swift.Bool
  @usableFromInline
  internal init()
}
@usableFromInline
@frozen internal enum Occurrence {
  case unique(index: Swift.Int)
  case duplicate(reference: SDSoup.IndicesReference)
}
@usableFromInline
final internal class IndicesReference {
  @usableFromInline
  final internal var indices: Swift.ContiguousArray<Swift.Int>
  @usableFromInline
  final internal var position: Swift.Int
  @usableFromInline
  internal init(_ indices: Swift.ContiguousArray<Swift.Int>)
  @inlinable final internal func push(_ index: Swift.Int) {
        indices.append(index)
    }
  @inlinable final internal func next() -> Swift.Int? {
        guard position < indices.endIndex else {
            return nil
        }
        defer { position += 1 }
        return indices[position]
    }
  @objc @usableFromInline
  deinit
}
@usableFromInline
internal struct TableKey<T> : Swift.Hashable where T : Swift.Hashable {
  @usableFromInline
  internal let pointeeHashValue: Swift.Int
  @usableFromInline
  internal let pointer: Swift.UnsafePointer<T>
  @usableFromInline
  internal init(pointer: Swift.UnsafePointer<T>)
  @inlinable internal static func == (lhs: SDSoup.TableKey<T>, rhs: SDSoup.TableKey<T>) -> Swift.Bool {
        lhs.pointeeHashValue == rhs.pointeeHashValue
            && (lhs.pointer.distance(to: rhs.pointer) == 0 || lhs.pointer.pointee == rhs.pointer.pointee)
    }
  @inlinable internal func hash(into hasher: inout Swift.Hasher) {
        hasher.combine(pointeeHashValue)
    }
  @usableFromInline
  internal var hashValue: Swift.Int {
    @usableFromInline
    get
  }
}
extension Swift.MutableCollection where Self.Element : Swift.MutableCollection, Self.Index == Swift.Int, Self.Element.Index == Swift.Int {
  @inlinable internal subscript(path: SDSoup.ElementPath) -> Self.Element.Element {
    get { self[path.section][path.element] }
    set { self[path.section][path.element] = newValue }
  }
}
public struct Allowlist : SDSoup.WhiteList, Swift.Equatable, Swift.Codable, SDSoup.PrettyConvertible {
  public var storage: [Foundation.URL]
  public init(_ storage: [Foundation.URL])
  public init(_ storage: Swift.Set<Foundation.URL>)
  public init(value: Swift.Set<Foundation.URL>)
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        storage.prettyElement
    }
  }
  public typealias ArrayLiteralElement = Foundation.URL
  public typealias Element = Foundation.URL
  public typealias RawValue = Swift.String
}
public struct AnyDifferentiable : SDSoup.Differentiable {
  @inlinable public var base: Any {
    get {
        box.base
    }
  }
  @inlinable public var differenceIdentifier: Swift.AnyHashable {
    get {
        box.differenceIdentifier
    }
  }
  @usableFromInline
  internal let box: any SDSoup.AnyDifferentiableBox
  public init<D>(_ base: D) where D : SDSoup.ContentEquatable, D : SDSoup.ContentIdentifiable
  @inlinable public func isContentEqual(to source: SDSoup.AnyDifferentiable) -> Swift.Bool {
        box.isContentEqual(to: source.box)
    }
  public typealias DifferenceIdentifier = Swift.AnyHashable
}
extension SDSoup.AnyDifferentiable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@usableFromInline
internal protocol AnyDifferentiableBox {
  var base: Any { get }
  var differenceIdentifier: Swift.AnyHashable { get }
  func isContentEqual(to source: any SDSoup.AnyDifferentiableBox) -> Swift.Bool
}
@usableFromInline
internal struct DifferentiableBox<Base> : SDSoup.AnyDifferentiableBox where Base : SDSoup.ContentEquatable, Base : SDSoup.ContentIdentifiable {
  @usableFromInline
  internal let baseComponent: Base
  @inlinable internal var base: Any {
    get {
        baseComponent
    }
  }
  @inlinable internal var differenceIdentifier: Swift.AnyHashable {
    get {
        baseComponent.differenceIdentifier
    }
  }
  @usableFromInline
  internal init(_ base: Base)
  @inlinable internal func isContentEqual(to source: any SDSoup.AnyDifferentiableBox) -> Swift.Bool {
        guard let sourceBase = source.base as? Base else {
            return false
        }
        return baseComponent.isContentEqual(to: sourceBase)
    }
}
public struct AnyFailureHandler : SDSoup.CodingFailureHandler {
  public init(_ block: @escaping (any Swift.Error) -> Swift.Void)
  public func handle(_ error: any Swift.Error)
}
public typealias AppGroup = SDSoup.Tagged<SDSoup.AppGroupTag, Swift.String>
@available(*, deprecated, message: "Use AppGroup")
public typealias ApplicationGroup = SDSoup.AppGroup
public enum ApplicationGroupError : Foundation.LocalizedError {
  case missingContainer(SDSoup.AppGroup)
  public var errorDescription: Swift.String? {
    get
  }
}
extension SDSoup.FileManagerTwin {
  public func url(for path: Swift.String, in appGroup: SDSoup.AppGroup) throws -> Foundation.URL
}
public enum AppGroupTag {
}
extension SDSoup.Archive {
  final public var data: Foundation.Data? {
    get
  }
}
extension SDSoup.Archive {
  final public func extract(_ entry: SDSoup.Entry, to url: Foundation.URL, bufferSize: Swift.UInt32 = defaultReadChunkSize, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil) throws -> SDSoup.CRC32
  final public func extract(_ entry: SDSoup.Entry, bufferSize: Swift.UInt32 = defaultReadChunkSize, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> SDSoup.CRC32
}
extension SDSoup.Archive {
  final public func addEntry(with path: Swift.String, relativeTo baseURL: Foundation.URL, compressionMethod: SDSoup.CompressionMethod = .none, bufferSize: Swift.UInt32 = defaultWriteChunkSize, progress: Foundation.Progress? = nil) throws
  final public func addEntry(with path: Swift.String, type: SDSoup.Entry.EntryType, uncompressedSize: Swift.UInt32, modificationDate: Foundation.Date = Date(), permissions: Swift.UInt16? = nil, compressionMethod: SDSoup.CompressionMethod = .none, bufferSize: Swift.UInt32 = defaultWriteChunkSize, progress: Foundation.Progress? = nil, provider: (_ position: Swift.Int, _ size: Swift.Int) throws -> Foundation.Data) throws
  final public func remove(_ entry: SDSoup.Entry, bufferSize: Swift.UInt32 = defaultReadChunkSize, progress: Foundation.Progress? = nil) throws
}
public let defaultReadChunkSize: Swift.UInt32
public let defaultWriteChunkSize: Swift.UInt32
public let defaultFilePermissions: Swift.UInt16
public let defaultDirectoryPermissions: Swift.UInt16
public enum CompressionMethod : Swift.UInt16 {
  case none
  case deflate
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
final public class Archive : Swift.Sequence {
  public enum ArchiveError : Swift.Error {
    case unreadableArchive
    case unwritableArchive
    case invalidEntryPath
    case invalidCompressionMethod
    case invalidStartOfCentralDirectoryOffset
    case missingEndOfCentralDirectoryRecord
    case cancelledOperation
    public static func == (a: SDSoup.Archive.ArchiveError, b: SDSoup.Archive.ArchiveError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum AccessMode : Swift.UInt {
    case create
    case read
    case update
    public init?(rawValue: Swift.UInt)
    public typealias RawValue = Swift.UInt
    public var rawValue: Swift.UInt {
      get
    }
  }
  final public let url: Foundation.URL
  final public let accessMode: SDSoup.Archive.AccessMode
  public init?(url: Foundation.URL, accessMode mode: SDSoup.Archive.AccessMode, preferredEncoding: Swift.String.Encoding? = nil)
  public init?(data: Foundation.Data = Data(), accessMode mode: SDSoup.Archive.AccessMode, preferredEncoding: Swift.String.Encoding? = nil)
  @objc deinit
  final public func makeIterator() -> Swift.AnyIterator<SDSoup.Entry>
  final public subscript(path: Swift.String) -> SDSoup.Entry? {
    get
  }
  public typealias Element = SDSoup.Entry
  public typealias Iterator = Swift.AnyIterator<SDSoup.Entry>
}
extension SDSoup.Archive {
  final public func totalUnitCountForRemoving(_ entry: SDSoup.Entry) -> Swift.Int64
  final public func totalUnitCountForReading(_ entry: SDSoup.Entry) -> Swift.Int64
  final public func totalUnitCountForAddingItem(at url: Foundation.URL) -> Swift.Int64
}
public struct ArgumentsStringID : SDSoup.StringID, Swift.Hashable {
  public enum Argument : Swift.Equatable, Swift.Hashable, Swift.CustomStringConvertible {
    case id(any SDSoup.StringID)
    case int(Swift.Int)
    case double(Swift.Double)
    case string(Swift.String)
    public var description: Swift.String {
      get
    }
    public static func == (lhs: SDSoup.ArgumentsStringID.Argument, rhs: SDSoup.ArgumentsStringID.Argument) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public init?(_ arg: any Swift.CVarArg)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let base: any SDSoup.StringID
  public let args: [SDSoup.ArgumentsStringID.Argument]
  public init(_ base: any SDSoup.StringID, args: [any Swift.CVarArg])
  public init(_ base: any SDSoup.StringID, args: [SDSoup.ArgumentsStringID.Argument])
  public var key: Swift.String {
    get
  }
  public func string(in stringProvider: any SDSoup.StringProvider) -> Swift.String
  public static func == (lhs: SDSoup.ArgumentsStringID, rhs: SDSoup.ArgumentsStringID) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SDSoup.StringID {
  @inlinable public func argument(_ args: [any Swift.CVarArg]) -> SDSoup.ArgumentsStringID {
        ArgumentsStringID(self, args: args)
    }
}
extension Swift.Array {
  @available(*, deprecated, message: "Используйте split")
  public func chunked(by chunkCount: Swift.Int) -> [Swift.ArraySlice<Element>]
  public func split(by maxSplits: Swift.Int) -> [Swift.ArraySlice<Element>]
  public func splitIntoArrays(maxSplits: Swift.Int) -> [[Element]]
}
extension Swift.Array where Element : Swift.Identifiable {
  public struct ChunkedGroup : Swift.Identifiable {
    public struct ID : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Swift.Array<Element>.ChunkedGroup.ID, b: Swift.Array<Element>.ChunkedGroup.ID) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public var id: Swift.Array<Element>.ChunkedGroup.ID {
      get
    }
    public let elements: [Element]
  }
  public func grouped(byChunkCount chunkCount: Swift.Int) -> [Swift.Array<Element>.ChunkedGroup]
}
extension Swift.Array where Element == Swift.Int {
  public func greatestCommonDivisor() -> Swift.Int?
}
extension Swift.Array {
  public func interleaved(by element: Element) -> [Element]
}
extension Swift.Array {
  @inlinable public func replacingFirst(with element: Element) -> Swift.Array<Element> {
        [element] + dropFirst(1)
    }
  @inlinable public func replacingLast(with element: Element) -> Swift.Array<Element> {
        droppingLast() + [element]
    }
  @inlinable public func appending(_ element: Element) -> Swift.Array<Element> {
        self + [element]
    }
  @inlinable public func droppingLast() -> Swift.Array<Element> {
        Array(prefix(count - 1))
    }
}
extension Swift.Array {
  public typealias Permutation = [Swift.Int]
  public func permuted(permutation: Swift.Array<Element>.Permutation) -> [Element]
}
extension Swift.Array {
  public mutating func safeRemoveFirst() -> Element?
}
extension Swift.Array {
  public func separated(by arrayCount: Swift.Int) -> [[Element]]
}
extension Swift.Array {
  public static func >> (left: Swift.Array<Element>, right: Swift.UInt) -> Swift.Array<Element>
  public static func << (left: Swift.Array<Element>, right: Swift.UInt) -> Swift.Array<Element>
}
extension Swift.Array {
  @inlinable internal static func _isWCSIABroken() -> Swift.Bool {
        guard _isBridgedVerbatimToObjectiveC(Element.self) else {
             
             
             
            return false
        }

     
     

         
         
         
        if #available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *) {
             
            return false
        }
         
         
         
         
        return true

    }
}
extension Swift.Sequence {
  @inlinable @inline(__always) public func _withContiguousStorageIfAvailable_SR14663<R>(_ body: (Swift.UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R? {
        if Self.self == [Element].self, Array<Element>._isWCSIABroken() {
            return nil
        }

        return try self.withContiguousStorageIfAvailable(body)
    }
}
public struct ArraySection<Model, Element> : SDSoup.DifferentiableSection where Model : SDSoup.ContentEquatable, Model : SDSoup.ContentIdentifiable, Element : SDSoup.ContentEquatable, Element : SDSoup.ContentIdentifiable {
  public var model: Model
  public var elements: [Element]
  @inlinable public var differenceIdentifier: Model.DifferenceIdentifier {
    get {
        model.differenceIdentifier
    }
  }
  public init<C>(model: Model, elements: C) where Element == C.Element, C : Swift.Collection
  @inlinable public init<C>(source: SDSoup.ArraySection<Model, Element>, elements: C) where Element == C.Element, C : Swift.Collection {
        self.init(model: source.model, elements: elements)
    }
  @inlinable public func isContentEqual(to source: SDSoup.ArraySection<Model, Element>) -> Swift.Bool {
        model.isContentEqual(to: source.model)
    }
  public typealias Collection = [Element]
  public typealias DifferenceIdentifier = Model.DifferenceIdentifier
}
extension SDSoup.ArraySection : Swift.Equatable where Model : Swift.Equatable, Element : Swift.Equatable {
  public static func == (lhs: SDSoup.ArraySection<Model, Element>, rhs: SDSoup.ArraySection<Model, Element>) -> Swift.Bool
}
public enum Assertion {
  @inlinable public static func assert(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = S(""), file: Swift.StaticString = #filePath, line: Swift.UInt = #line) {
        global.assert(condition(), message(), file: file, line: line)
    }
  @inlinable public static func fatalError(_ message: @autoclosure () -> Swift.String = S(""), file: Swift.StaticString = #filePath, line: Swift.UInt = #line) -> Swift.Never {
        global.fatalError(message(), file: file, line: line)
    }
  @inlinable public static func assertionFailure(_ message: @autoclosure () -> Swift.String = S(""), file: Swift.StaticString = #filePath, line: Swift.UInt = #line) {
        global.assertionFailure(message(), file: file, line: line)
    }
  @inlinable public static func assertionFailure(_ error: @autoclosure () -> any Swift.Error, file: Swift.StaticString = #filePath, line: Swift.UInt = #line) {
        global.assertionFailure(Pretty.string(error()), file: file, line: line)
    }
  @inlinable public static func setGlobalAssertionCaller(_ subject: any SDSoup.AssertionCaller) {
        global.set(subject)
    }
  @usableFromInline
  internal static let global: SDSoup.GlobalAssertionCaller
}
extension SDSoup.AssertionCaller {
  public func assertIsMain(file: Swift.StaticString = #filePath, line: Swift.UInt = #line)
  public func assertIsCurrent(thread: Foundation.Thread, file: Swift.StaticString = #filePath, line: Swift.UInt = #line)
  public func assertIsNotMain(file: Swift.StaticString = #filePath, line: Swift.UInt = #line)
}
public protocol AssertionCaller : Swift.Sendable {
  func assert(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt)
  func fatalError(_ message: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt) -> Swift.Never
  func assertionFailure(_ message: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt)
}
extension SDSoup.AssertionCaller {
  @inlinable public func assert(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = S(""), file: Swift.StaticString = #filePath, line: Swift.UInt = #line) {
        assert(condition(), message(), file: file, line: line)
    }
  @inlinable public func fatalError(_ message: @autoclosure () -> Swift.String = S(""), file: Swift.StaticString = #filePath, line: Swift.UInt = #line) -> Swift.Never {
        fatalError(message(), file: file, line: line)
    }
  @inlinable public func assertionFailure(_ message: @autoclosure () -> Swift.String = S(""), file: Swift.StaticString = #filePath, line: Swift.UInt = #line) {
        assertionFailure(message(), file: file, line: line)
    }
}
@available(*, deprecated, message: "Use assertion caller injection")
public var assertionCallerShared: any SDSoup.AssertionCaller {
  get
}
public enum AssertionCallers {
}
public struct AssertionFailureHandler : SDSoup.CodingFailureHandler {
  public init(assertionCaller: any SDSoup.AssertionCaller)
  public func handle(_ error: any Swift.Error)
}
@propertyWrapper final public class Atomic<Value> : Swift.Sendable {
  @inlinable final public var value: Value {
    get {
        wrappedValue
    }
  }
  final public var wrappedValue: Value {
    get
    set
  }
  public init(_ value: Value)
  convenience public init(wrappedValue: Value)
  final public func withLock<T>(_ transform: (inout Value) throws -> T) rethrows -> T
  @objc deinit
}
public typealias BizoneData = SDSoup.Tagged<SDSoup.BizoneDataTag, Swift.String>
public enum BizoneDataTag {
}
public typealias BizoneProvider = @Sendable () async throws -> SDSoup.BizoneData
public typealias BonjourServiceType = SDSoup.Tagged<SDSoup.BonjourServiceTypeTag, Swift.String>
extension SDSoup.Tagged where Tag == SDSoup.BonjourServiceTypeTag, T == Swift.String {
  public static let permission: SDSoup.BonjourServiceType
}
public enum BonjourServiceTypeTag {
}
extension Swift.Bool {
  @inlinable public var toggled: Swift.Bool {
    get { !self }
  }
}
extension Swift.Bool {
  public var string: Swift.String {
    get
  }
}
public protocol BuildTypeProtocol : Swift.CaseIterable {
  var isInternal: Swift.Bool { get }
  static var current: Self { get }
  func map<T>(_ body: (Self) throws -> T) rethrows -> T
}
extension SDSoup.BuildTypeProtocol {
  @inlinable public func map<T>(_ body: (Self) throws -> T) rethrows -> T {
        try body(self)
    }
}
extension Foundation.Bundle {
  public func tryChild(_ name: Swift.String) -> Foundation.Bundle?
  public func childBundle(_ name: Swift.String) -> Foundation.Bundle
}
public enum BundleIDTag {
}
public typealias BundleID = SDSoup.Tagged<SDSoup.BundleIDTag, Swift.String>
extension Foundation.Bundle {
  public var bundleID: SDSoup.BundleID {
    get
  }
  public var shortVersion: Swift.String {
    get
  }
  public var version: Swift.String {
    get
  }
  public var marketingVersion: Swift.String {
    get
  }
  public var appName: Swift.String {
    get
  }
}
extension Foundation.Bundle {
  public var appVersion: Foundation.Bundle.Version {
    get
  }
  public struct Version : Swift.RawRepresentable, Swift.Comparable, Swift.ExpressibleByStringLiteral {
    public let rawValue: Swift.String
    public var components: [Swift.String] {
      get
    }
    public init(rawValue: Swift.String)
    public init(stringLiteral value: Swift.StringLiteralType)
    public static func < (lhs: Foundation.Bundle.Version, rhs: Foundation.Bundle.Version) -> Swift.Bool
    public func compareVersion(with other: Foundation.Bundle.Version) -> Foundation.ComparisonResult
    public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
    public typealias RawValue = Swift.String
    public typealias StringLiteralType = Swift.StringLiteralType
    public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
  }
}
public protocol BundleTwin {
  var bundlePath: Swift.String { get }
}
extension Foundation.Bundle : SDSoup.BundleTwin {
}
extension QuartzCore.CALayer {
  public func setNeedsUpdate()
  public func storeAnimations(toPause: Swift.Bool = true)
  public func restoreAnimations(toResume: Swift.Bool = true)
}
extension CoreGraphics.CGColor {
  public static func make(hex: Swift.Int64) -> CoreGraphics.CGColor
}
extension CoreFoundation.CGFloat {
  public func roundedUpToScreenScale() -> CoreFoundation.CGFloat
  public func roundedDownToScreenScale() -> CoreFoundation.CGFloat
  public func roundedUp(to step: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  public func roundedDown(to step: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
}
extension CoreFoundation.CGPoint {
  public static func + (left: CoreFoundation.CGPoint, right: CoreFoundation.CGPoint) -> CoreFoundation.CGPoint
}
extension CoreFoundation.CGRect {
  public var center: CoreFoundation.CGPoint {
    get
    set
  }
  public var isFinite: Swift.Bool {
    get
  }
  public init(x: CoreFoundation.CGFloat, y: CoreFoundation.CGFloat, size: CoreFoundation.CGSize)
  public init(origin: CoreFoundation.CGPoint, width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat)
  public init(center: CoreFoundation.CGPoint, size: CoreFoundation.CGSize)
  public init(minX: CoreFoundation.CGFloat, minY: CoreFoundation.CGFloat, maxX: CoreFoundation.CGFloat, maxY: CoreFoundation.CGFloat)
  public func relative(in bounds: CoreFoundation.CGRect) -> CoreFoundation.CGRect
  public func relative(in bounds: CoreFoundation.CGSize) -> CoreFoundation.CGRect
}
extension CoreFoundation.CGSize {
  public init(square: CoreFoundation.CGFloat)
  public static var infinity: CoreFoundation.CGSize {
    get
  }
  @inlinable public var minDimension: CoreFoundation.CGFloat {
    get {
        min(width, height)
    }
  }
  @inlinable public var maxDimension: CoreFoundation.CGFloat {
    get {
        max(width, height)
    }
  }
  @inlinable public var area: CoreFoundation.CGFloat {
    get {
        width * height
    }
  }
  @inlinable public var absolute: CoreFoundation.CGSize {
    get {
        CGSize(
            width: abs(width),
            height: abs(height)
        )
    }
  }
  public static func + (left: CoreFoundation.CGSize, right: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public static func ceil(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public var ceiled: CoreFoundation.CGSize {
    get
  }
  public static func + (left: CoreFoundation.CGSize, right: UIKit.UIEdgeInsets) -> CoreFoundation.CGSize
  public static func * (size: CoreFoundation.CGSize, scalar: CoreFoundation.CGFloat) -> CoreFoundation.CGSize
  public func inset(by insets: UIKit.UIEdgeInsets) -> CoreFoundation.CGSize
  public func centered(in rect: CoreFoundation.CGRect) -> CoreFoundation.CGRect
  public func aspectFit(in size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func aspectFill(size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func isAlmostGreater(_ size: CoreFoundation.CGSize) -> Swift.Bool
  public func isAlmostEqual(_ size: CoreFoundation.CGSize) -> Swift.Bool
  public func clamp(to size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
}
#if compiler(>=5.3) && $RetroactiveAttribute
extension CoreFoundation.CGSize : @retroactive Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
}
#else
extension CoreFoundation.CGSize : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
}
#endif
public struct Changeset<Collection> where Collection : Swift.Collection {
  public var data: Collection
  public var sectionDeleted: [Swift.Int]
  public var sectionInserted: [Swift.Int]
  public var sectionUpdated: [Swift.Int]
  public var sectionMoved: [(source: Swift.Int, target: Swift.Int)]
  public var elementDeleted: [SDSoup.ElementPath]
  public var elementInserted: [SDSoup.ElementPath]
  public var elementUpdated: [SDSoup.ElementPath]
  public var elementMoved: [(source: SDSoup.ElementPath, target: SDSoup.ElementPath)]
  public init(data: Collection, sectionDeleted: [Swift.Int] = [], sectionInserted: [Swift.Int] = [], sectionUpdated: [Swift.Int] = [], sectionMoved: [(source: Swift.Int, target: Swift.Int)] = [], elementDeleted: [SDSoup.ElementPath] = [], elementInserted: [SDSoup.ElementPath] = [], elementUpdated: [SDSoup.ElementPath] = [], elementMoved: [(source: SDSoup.ElementPath, target: SDSoup.ElementPath)] = [])
}
extension SDSoup.Changeset {
  @inlinable public var sectionChangeCount: Swift.Int {
    get {
        sectionDeleted.count
            + sectionInserted.count
            + sectionUpdated.count
            + sectionMoved.count
    }
  }
  @inlinable public var elementChangeCount: Swift.Int {
    get {
        elementDeleted.count
            + elementInserted.count
            + elementUpdated.count
            + elementMoved.count
    }
  }
  @inlinable public var changeCount: Swift.Int {
    get {
        sectionChangeCount + elementChangeCount
    }
  }
  @inlinable public var hasSectionChanges: Swift.Bool {
    get {
        sectionChangeCount > 0
    }
  }
  @inlinable public var hasElementChanges: Swift.Bool {
    get {
        elementChangeCount > 0
    }
  }
  @inlinable public var hasChanges: Swift.Bool {
    get {
        changeCount > 0
    }
  }
}
extension SDSoup.Changeset : Swift.Equatable where Collection : Swift.Equatable {
  public static func == (lhs: SDSoup.Changeset<Collection>, rhs: SDSoup.Changeset<Collection>) -> Swift.Bool
}
extension SDSoup.Changeset : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.ClosedRange {
  public func clamp(_ value: Bound) -> Bound
}
extension Swift.ClosedRange where Bound : Swift.FloatingPoint {
  public var isFinite: Swift.Bool {
    get
  }
  public var center: Bound {
    get
  }
  public var length: Bound {
    get
  }
}
public struct PartialDecodableArray<Element> : Swift.Decodable where Element : Swift.Decodable {
  public let elements: [Element]
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.UnkeyedDecodingContainer {
  public mutating func decodePartialArray<T>(_: T.Type) throws -> [T] where T : Swift.Decodable
}
extension Swift.SingleValueDecodingContainer {
  public func decodePartialArray<T>(_: T.Type) throws -> [T] where T : Swift.Decodable
}
extension Swift.KeyedDecodingContainerProtocol {
  public func decodePartialArray<T>(_: T.Type, forKey key: Self.Key) throws -> [T] where T : Swift.Decodable
  public func decodeOptionalPartialArray<T>(_: T.Type, forKey key: Self.Key) throws -> [T]? where T : Swift.Decodable
  public func decodeOptional<T>(_: T.Type, forKey key: Self.Key) -> T? where T : Swift.Decodable
}
extension Foundation.JSONEncoder {
  public static let storage: Foundation.JSONEncoder
  @discardableResult
  public func configureForStorage() -> Self
}
extension Foundation.JSONDecoder {
  public static let storage: Foundation.JSONDecoder
  @discardableResult
  public func configureForStorage() -> Self
}
extension Swift.Dictionary where Key == Swift.CodingUserInfoKey, Value == Any {
  public var timeZone: Foundation.TimeZone? {
    get
    set
  }
}
public protocol CodingFailureHandler {
  func handle(_ error: any Swift.Error)
}
extension Swift.Dictionary where Key == Swift.CodingUserInfoKey, Value == Any {
  public var failureHandler: any SDSoup.CodingFailureHandler {
    get
    set
  }
}
extension Swift.Collection {
  @inlinable public func nonEmpty() -> Self? {
        isEmpty ? nil : self
    }
}
extension Swift.Collection where Self.Element : UIKit.UIView {
  @_Concurrency.MainActor public func maxWidth() -> CoreFoundation.CGFloat?
  @_Concurrency.MainActor public func maxHeight() -> CoreFoundation.CGFloat?
}
extension Swift.Collection {
  public func dictionary<Key>(key keyPath: Swift.KeyPath<Self.Element, Key>, uniquingKeysWith uniquing: (Self.Element, Self.Element) -> Self.Element = { $1 }) -> [Key : Self.Element] where Key : Swift.Hashable
  public func dictionary<Key>(optionalKey keyPath: Swift.KeyPath<Self.Element, Key?>, uniquingKeysWith uniquing: (Self.Element, Self.Element) -> Self.Element = { $1 }) -> [Key : Self.Element] where Key : Swift.Hashable
}
extension Swift.Collection {
  public func prettyJson() -> Swift.String
  public func sortedJson() -> Swift.String
}
extension Swift.Collection {
  public subscript(safe index: Self.Index) -> Self.Element? {
    get
  }
}
extension Swift.Error {
  public var isCancel: Swift.Bool {
    get
  }
}
#if compiler(>=5.3) && $RetroactiveAttribute
extension _Concurrency.CancellationError : @retroactive Swift.Equatable {
  public static func == (_: _Concurrency.CancellationError, _: _Concurrency.CancellationError) -> Swift.Bool
}
#else
extension _Concurrency.CancellationError : Swift.Equatable {
  public static func == (_: _Concurrency.CancellationError, _: _Concurrency.CancellationError) -> Swift.Bool
}
#endif
extension Combine.CurrentValueSubject : SDSoup.PrettyUnconvertible {
}
extension Combine.PassthroughSubject : SDSoup.PrettyUnconvertible {
}
extension Combine.AnyCancellable : SDSoup.PrettyUnconvertible {
}
public enum CompilationBuildType : SDSoup.BuildTypeProtocol {
  case `internal`
  case `public`
  public var isInternal: Swift.Bool {
    get
  }
  public static var current: SDSoup.CompilationBuildType {
    get
  }
  public static func == (a: SDSoup.CompilationBuildType, b: SDSoup.CompilationBuildType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SDSoup.CompilationBuildType]
  nonisolated public static var allCases: [SDSoup.CompilationBuildType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum CompilationMode : Swift.Sendable {
  case debug
  case adhoc
  case release
  public static func == (a: SDSoup.CompilationMode, b: SDSoup.CompilationMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CompilationModePerformer : Swift.Sendable {
  var mode: SDSoup.CompilationMode { get }
  @discardableResult
  func perform<T>(inDebug: () -> T, inAdhoc: () -> T, inRelease: () -> T) -> T
  func perform(inDebug: () -> Swift.Void, inAdhoc: () -> Swift.Void, inRelease: () -> Swift.Void)
}
extension SDSoup.CompilationModePerformer {
  @discardableResult
  public func performInDebug<T>(_ action: () -> T) -> T where T : Swift.ExpressibleByNilLiteral
  @discardableResult
  public func performInAdhoc<T>(_ action: () -> T) -> T where T : Swift.ExpressibleByNilLiteral
  @discardableResult
  public func performInRelease<T>(_ action: () -> T) -> T where T : Swift.ExpressibleByNilLiteral
}
public let compilationModePerformerShared: any SDSoup.CompilationModePerformer
extension SDSoup.CompilationModePerformer {
  @inlinable public var isRelease: Swift.Bool {
    get {
        switch mode {
        case .adhoc,
             .debug:
            return false
        case .release:
            return true
        }
    }
  }
}
public protocol Configurable {
}
extension SDSoup.Configurable {
  @discardableResult
  public func configure(_ block: (inout Self) throws -> Swift.Void) rethrows -> Self
}
extension Swift.Array : SDSoup.Configurable {
}
public protocol ContentEquatable {
  func isContentEqual(to source: Self) -> Swift.Bool
}
extension SDSoup.ContentEquatable where Self : Swift.Equatable {
  @inlinable public func isContentEqual(to source: Self) -> Swift.Bool {
        self == source
    }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional : SDSoup.ContentEquatable where Wrapped : SDSoup.ContentEquatable {
  @inlinable public func isContentEqual(to source: Wrapped?) -> Swift.Bool {
        switch (self, source) {
        case let (lhs?, rhs?):
            return lhs.isContentEqual(to: rhs)

        case (.none, .none):
            return true

        case (.none, .some),
             (.some, .none):
            return false
        }
    }
}
#else
extension Swift.Optional : SDSoup.ContentEquatable where Wrapped : SDSoup.ContentEquatable {
  @inlinable public func isContentEqual(to source: Wrapped?) -> Swift.Bool {
        switch (self, source) {
        case let (lhs?, rhs?):
            return lhs.isContentEqual(to: rhs)

        case (.none, .none):
            return true

        case (.none, .some),
             (.some, .none):
            return false
        }
    }
}
#endif
extension Swift.Array : SDSoup.ContentEquatable where Element : SDSoup.ContentEquatable {
  @inlinable public func isContentEqual(to source: [Element]) -> Swift.Bool {
        count == source.count
            && zip(self, source).allSatisfy { $0.isContentEqual(to: $1) }
    }
}
public protocol ContentIdentifiable {
  associatedtype DifferenceIdentifier : Swift.Hashable
  var differenceIdentifier: Self.DifferenceIdentifier { get }
}
extension SDSoup.ContentIdentifiable where Self : Swift.Hashable {
  @inlinable public var differenceIdentifier: Self {
    get {
        self
    }
  }
}
extension CoreFoundation.CGPoint : SDSoup.Configurable {
}
extension CoreFoundation.CGSize : SDSoup.Configurable {
}
extension CoreFoundation.CGRect : SDSoup.Configurable {
}
extension CoreFoundation.CGVector : SDSoup.Configurable {
}
extension CoreFoundation.CGRectEdge : SDSoup.Configurable {
}
public typealias CustomCharacterName = SDSoup.Tagged<SDSoup.CharacterNameTag, Swift.String>
public enum CharacterNameTag {
}
extension Foundation.Data {
  public func chunked(size: Swift.Int) -> [Foundation.Data]
}
public typealias CRC32 = Swift.UInt32
public typealias Consumer = (_ data: Foundation.Data) throws -> Swift.Void
public typealias Provider = (_ position: Swift.Int, _ size: Swift.Int) throws -> Foundation.Data
public let crcTable: [Swift.UInt32]
extension Foundation.Data {
  public func crc32(checksum: SDSoup.CRC32) -> SDSoup.CRC32
  public static func compress(size: Swift.Int, bufferSize: Swift.Int, provider: (_ position: Swift.Int, _ size: Swift.Int) throws -> Foundation.Data, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> SDSoup.CRC32
  public static func decompress(size: Swift.Int, bufferSize: Swift.Int, skipCRC32: Swift.Bool, provider: (_ position: Swift.Int, _ size: Swift.Int) throws -> Foundation.Data, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> SDSoup.CRC32
}
extension Foundation.Data {
  @inlinable public var utf8String: Swift.String {
    get {
        String(decoding: self, as: UTF8.self)
    }
  }
  @inlinable public var hexString: Swift.String {
    get {
        map { String(format: S("%02.2hhx"), $0) }.joined()
    }
  }
  public init?(base64urlEncoded: Swift.String)
}
extension Foundation.Date {
  @inlinable public func isAlmostEqual(_ another: Foundation.Date) -> Swift.Bool {
        timeIntervalSince1970.isAlmostEqual(another.timeIntervalSince1970)
    }
  @inlinable public init(year: Swift.Int, month: Swift.Int, day: Swift.Int, hour: Swift.Int = 0, minute: Swift.Int = 0, timezone: Foundation.TimeZone = .current) {
        var dateComponents = DateComponents()
        dateComponents.year = year
        dateComponents.month = month
        dateComponents.day = day
        dateComponents.hour = hour
        dateComponents.minute = minute
        dateComponents.timeZone = timezone

        let value = Calendar.current.date(from: dateComponents) ?? Date()

        self.init(timeIntervalSince1970: value.timeIntervalSince1970)
    }
  @inlinable public func time() -> (hour: Swift.Int, minute: Swift.Int) {
        let calendar = Calendar.current.dateComponents([.hour, .minute], from: self)
        return (hour: calendar.hour ?? 25, minute: calendar.minute ?? 60)
    }
}
extension Swift.Dictionary where Key == Foundation.Date {
  public var today: Value? {
    get
  }
}
extension Foundation.JSONDecoder.DateDecodingStrategy {
  public static func sequence(_ formatters: [any SDSoup.DateFormatterTwin]) -> Foundation.JSONDecoder.DateDecodingStrategy
}
public protocol DateFormatterTwin : Swift.Sendable {
  var locale: Foundation.Locale! { get set }
  func date(from: Swift.String) -> Foundation.Date?
  func string(from: Foundation.Date) -> Swift.String
}
extension Foundation.DateFormatter : SDSoup.DateFormatterTwin {
}
#if compiler(>=5.3) && $RetroactiveAttribute
extension Foundation.ISO8601DateFormatter : @unchecked @retroactive Swift.Sendable {
}
#else
extension Foundation.ISO8601DateFormatter : @unchecked Swift.Sendable {
}
#endif
extension Foundation.ISO8601DateFormatter : SDSoup.DateFormatterTwin {
  public var locale: Foundation.Locale! {
    get
    set
  }
}
public typealias DateProvider = @Sendable () -> Foundation.Date
extension Foundation.Date {
  @Sendable public static func now() -> Foundation.Date
}
@inlinable @inline(__always) public var _isCollectionsInternalCheckingEnabled: Swift.Bool {
  get {
    return false
}
}
extension Swift.DecodingError : SDSoup.PrettyConvertible, SDSoup.PrettyError {
  public var errorCode: Swift.Int {
    get
  }
  public var errorName: Swift.String {
    get
  }
  public var errorUserInfo: [Swift.String : any Swift.Sendable] {
    get
  }
  public var prettyElement: SDSoup.PrettyElement {
    get
  }
}
extension SDSoup.Tagged where Tag == SDSoup.DeeplinkSchemeTag, T == Swift.String {
  public static let homuz: SDSoup.DeeplinkScheme
  public static let cmpn: SDSoup.DeeplinkScheme
}
public typealias DeeplinkScheme = SDSoup.Tagged<SDSoup.DeeplinkSchemeTag, Swift.String>
extension Foundation.URL {
  public init(_ scheme: SDSoup.DeeplinkScheme, part: Swift.String)
}
public enum DeeplinkSchemeTag {
}
public struct DependencyContext<Tag> : SDSoup.Configurable {
  public let label: Swift.String
  public var isEmpty: Swift.Bool {
    get
  }
  public init(label: Swift.String, configurator: (inout SDSoup.DependencyContext<Tag>) -> Swift.Void)
  public func contains<Value>(_ key: SDSoup.DependencyKey<Value, Tag>) -> Swift.Bool
  public func compactValuesMap<NewValue>(_ transform: (Any) -> NewValue?) -> [NewValue]
  public subscript<Value>(key: SDSoup.DependencyKey<Value, Tag>) -> Value {
    get
    set
  }
  public subscript<Wrapped>(required key: SDSoup.DependencyKey<Wrapped?, Tag>) -> Wrapped {
    get
  }
  public static func + (lhs: SDSoup.DependencyContext<Tag>, rhs: SDSoup.DependencyContext<Tag>) -> SDSoup.DependencyContext<Tag>
}
extension SDSoup.DependencyContext : @unchecked Swift.Sendable where Tag : Swift.Sendable {
}
public struct DependencyKey<Value, Tag> {
  public enum MissingPolicy {
    case `default`(@autoclosure () -> Value)
    case required
  }
  public let id: Swift.String
  public let missingPolicy: SDSoup.DependencyKey<Value, Tag>.MissingPolicy
  public init(id: Swift.String, whenMissing missingPolicy: SDSoup.DependencyKey<Value, Tag>.MissingPolicy)
}
extension SDSoup.DependencyKey {
  public init(id: Swift.String) where Value : Swift.ExpressibleByNilLiteral
  public init(id: Swift.String, default: @autoclosure @escaping () -> Value)
  public static func required(id: Swift.String) -> SDSoup.DependencyKey<Value, Tag>
}
extension SDSoup.DependencyKey : Swift.Hashable, Swift.Equatable {
  public static func == (lhs: SDSoup.DependencyKey<Value, Tag>, rhs: SDSoup.DependencyKey<Value, Tag>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public func _addressString(for pointer: Swift.UnsafeRawPointer) -> Swift.String
public func _addressString(for object: Swift.AnyObject) -> Swift.String
@inlinable public func _addressString<T>(for object: Swift.Unmanaged<T>) -> Swift.String where T : AnyObject {
    _addressString(for: object.toOpaque())
}
@inlinable public func _arrayDescription<C>(for elements: C, debug: Swift.Bool = false, typeName: Swift.String? = nil) -> Swift.String where C : Swift.Collection {
    var result = S("")
    if let typeName {
        result += typeName + S("(")
    }
    result += S("[")
    var first = true
    for item in elements {
        if first {
            first = false
        } else {
            result += S(", ")
        }
        if debug {
            debugPrint(item, terminator: S(""), to: &result)
        } else {
            print(item, terminator: S(""), to: &result)
        }
    }
    result += S("]")
    if typeName != nil { result += S(")") }
    return result
}
@inlinable public func _dictionaryDescription<Key, Value, C>(for elements: C, debug: Swift.Bool = false, typeName: Swift.String? = nil) -> Swift.String where C : Swift.Collection, C.Element == (key: Key, value: Value) {
    var result = S("")
    if let typeName {
        result += typeName + S("(")
    }

    if elements.isEmpty {
        result += S("[:]")
    } else {
        result += S("[")
        var first = true
        for (key, value) in elements {
            if first {
                first = false
            } else {
                result += S(", ")
            }
            if debug {
                debugPrint(key, terminator: S(""), to: &result)
                result += S(": ")
                debugPrint(value, terminator: S(""), to: &result)
            } else {
                result += String(describing: key) + S(": ") + String(describing: value)
            }
        }
        result += S("]")
    }

    if typeName != nil {
        result += S(")")
    }
    return result
}
public struct DetectionStyle {
}
extension SDSoup.DetectionStyle {
  public static func defaultStyle() -> SDSoup.DetectionStyle
  public static func customStyle(withColor color: UIKit.UIColor) -> SDSoup.DetectionStyle
}
extension Swift.Dictionary {
  public static func + (lhs: Swift.Dictionary<Key, Value>, rhs: Swift.Dictionary<Key, Value>) -> Swift.Dictionary<Key, Value>
  public static func += (lhs: inout Swift.Dictionary<Key, Value>, rhs: Swift.Dictionary<Key, Value>)
  public func mapKeys<T>(_ transform: (Key) throws -> T) rethrows -> [T : Value] where T : Swift.Hashable
  @inlinable public func nonnull<T>() -> [Key : T] where Value == T? {
        compactMapValues { $0 }
    }
  @inlinable public init<S>(uniquing values: S) where Key == Value.ID, Value : Swift.Identifiable, Value == S.Element, S : Swift.Sequence {
        self.init(values.map { ($0.id, $0) }, uniquingKeysWith: { _, rhs in rhs })
    }
}
public func mergingOptional<K, V>(_ lhs: [K : V]?, _ rhs: [K : V]?, uniquingKeysWith: (V, V) throws -> V) rethrows -> [K : V]? where K : Swift.Hashable
extension Swift.Dictionary where Value == Any {
  @inlinable public func nonnullAndFlat() -> [Key : Value] {
        reduce(into: [Key: Value]()) { result, item in
            switch item.value as Any {
             
             
            case Optional<Any>.none:
                return
            case let wrapped as Any?:
                 
                if let value = wrapped.flatMap({ $0 }) {
                    result[item.key] = value
                }
            default:
                result[item.key] = item.value
            }
        }
    }
}
public typealias Differentiable = SDSoup.ContentEquatable & SDSoup.ContentIdentifiable
public protocol DifferentiableSection : SDSoup.ContentEquatable, SDSoup.ContentIdentifiable {
  associatedtype Collection : Swift.Collection where Self.Collection.Element : SDSoup.ContentEquatable, Self.Collection.Element : SDSoup.ContentIdentifiable
  var elements: Self.Collection { get }
  init<C>(source: Self, elements: C) where C : Swift.Collection, C.Element == Self.Collection.Element
}
final public class DisposableHandle {
  public init(closure: @escaping () -> Swift.Void)
  final public func invoke()
  @objc deinit
}
extension Swift.Double {
  public func string(_ fractionDigits: Swift.Int = 1) -> Swift.String
}
public struct ElementPath : Swift.Hashable {
  public var element: Swift.Int
  public var section: Swift.Int
  public init(element: Swift.Int, section: Swift.Int)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SDSoup.ElementPath, b: SDSoup.ElementPath) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension SDSoup.ElementPath : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct EmptyFailureHandler : SDSoup.CodingFailureHandler {
  public init()
  public func handle(_: any Swift.Error)
}
extension SDSoup.CodingFailureHandler where Self == SDSoup.EmptyFailureHandler {
  public static var empty: SDSoup.EmptyFailureHandler {
    get
  }
}
public struct Entry : Swift.Equatable {
  public enum EntryType : Swift.Int {
    case file
    case directory
    case symlink
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public func path(using encoding: Swift.String.Encoding) -> Swift.String
  public var path: Swift.String {
    get
  }
  public var fileAttributes: [Foundation.FileAttributeKey : Any] {
    get
  }
  public var checksum: SDSoup.CRC32 {
    get
  }
  public var type: SDSoup.Entry.EntryType {
    get
  }
  public var compressedSize: Swift.Int {
    get
  }
  public var uncompressedSize: Swift.Int {
    get
  }
  public static func == (lhs: SDSoup.Entry, rhs: SDSoup.Entry) -> Swift.Bool
}
extension Swift.Equatable {
  public func overwrite(values: [Self], with replaceValue: Self?) -> Self?
}
extension Swift.Error {
  @available(*, deprecated, message: "Используйте Pretty.string(_:)")
  public var localizedErrorDescription: Swift.String {
    get
  }
  public var nsCode: Swift.Int {
    get
  }
  public var nsDomain: Swift.String {
    get
  }
}
final public class FPSCounter {
  final public var fps: Combine.AnyPublisher<Swift.Int, Swift.Never> {
    get
  }
  final public let maxFps: Swift.Int
  @_Concurrency.MainActor public init(measureFrequency: Foundation.TimeInterval)
  @objc deinit
  final public func start()
  final public func stop()
}
public struct Factory<Arg, Item> : SDSoup.PrettyUnconvertible {
  @usableFromInline
  internal let block: (Arg) -> Item
  public init(constant: Item)
  public init(block: @escaping (Arg) -> Item)
  @inlinable public func make(_ parameters: Arg) -> Item {
        block(parameters)
    }
  @inlinable public func callAsFunction(_ args: Arg) -> Item {
        make(args)
    }
}
extension SDSoup.Factory where Arg == () {
  @inlinable public func make() -> Item {
        block(())
    }
  @inlinable public func callAsFunction() -> Item {
        make()
    }
}
public typealias FeatureFlags = SDSoup.DependencyContext<SDSoup.FeatureFlagTag>
public typealias FeatureFlag<T> = SDSoup.DependencyKey<SDSoup.Property<T>, SDSoup.FeatureFlagTag>
extension SDSoup.DependencyKey {
  public static func featureFlag<T>(id: Swift.String, default: @autoclosure @escaping () -> T) -> SDSoup.DependencyKey<Value, Tag> where Value == SDSoup.Property<T>
}
extension SDSoup.DependencyContext where Tag == SDSoup.FeatureFlagTag {
  public init(label: Swift.String = #fileID)
  public func value<T>(_ key: SDSoup.FeatureFlag<T>) -> T
  public func allSatisfy(_ keys: SDSoup.FeatureFlag<Swift.Bool>...) -> Swift.Bool
}
extension SDSoup.DependencyKey {
  public static var featureFlags: SDSoup.ViewContextKey<SDSoup.FeatureFlags> {
    get
  }
}
public enum FeatureFlagTag {
}
public protocol FeedbackGeneratorTwin {
  @_Concurrency.MainActor func feedback(_ feedback: SDSoup.TapticFeedback)
}
final public class FeedbackGeneratorTwinImpl : SDSoup.FeedbackGeneratorTwin {
  public init()
  @_Concurrency.MainActor final public func feedback(_ feedback: SDSoup.TapticFeedback)
  @objc deinit
}
public struct FileHandleAdapter : SDSoup.FileHandleTwin {
  public init(forReadingFrom url: Foundation.URL) throws
  public init(forWritingTo url: Foundation.URL) throws
  public init(forUpdating url: Foundation.URL) throws
  public func readToEnd() throws -> Foundation.Data?
  public func read(upToCount count: Swift.Int) throws -> Foundation.Data?
  public func offset() throws -> Swift.UInt64
  public func seekToEnd() throws -> Swift.UInt64
  public func write(contentsOf data: Foundation.Data) throws
  public func close() throws
}
public protocol FileHandleTwin {
  func readToEnd() throws -> Foundation.Data?
  func read(upToCount count: Swift.Int) throws -> Foundation.Data?
  func offset() throws -> Swift.UInt64
  func seekToEnd() throws -> Swift.UInt64
  func write(contentsOf data: Foundation.Data) throws
  func close() throws
}
extension Foundation.FileManager {
  public func zipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL, shouldKeepParent: Swift.Bool = true, compressionMethod: SDSoup.CompressionMethod = .none, progress: Foundation.Progress? = nil) throws
  public func unzipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil, preferredEncoding: Swift.String.Encoding? = nil) throws
}
extension Foundation.URL {
  public func isContained(in parentDirectoryURL: Foundation.URL) -> Swift.Bool
}
public protocol FileManagerTwin : Swift.Sendable {
  func contentsOfDirectory(atPath path: Swift.String) throws -> [Swift.String]
  func contentsOfDirectory(at url: Foundation.URL, includingPropertiesForKeys keys: [Foundation.URLResourceKey]?, options mask: Foundation.FileManager.DirectoryEnumerationOptions) throws -> [Foundation.URL]
  func fileExists(atPath path: Swift.String, isDirectory: Swift.UnsafeMutablePointer<ObjectiveC.ObjCBool>?) -> Swift.Bool
  func fileExists(atPath path: Swift.String) -> Swift.Bool
  func contents(atPath path: Swift.String) -> Foundation.Data?
  func createFile(atPath path: Swift.String, contents data: Foundation.Data?, attributes: [Foundation.FileAttributeKey : Any]?) -> Swift.Bool
  func createDirectory(at url: Foundation.URL, withIntermediateDirectories createIntermediates: Swift.Bool, attributes: [Foundation.FileAttributeKey : Any]?) throws
  func isDeletableFile(atPath path: Swift.String) -> Swift.Bool
  func isReadableFile(atPath path: Swift.String) -> Swift.Bool
  func removeItem(at URL: Foundation.URL) throws
  func moveItem(at srcURL: Foundation.URL, to dstURL: Foundation.URL) throws
  func zipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL, shouldKeepParent: Swift.Bool, compressionMethod: SDSoup.CompressionMethod, progress: Foundation.Progress?) throws
  func unzipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL, skipCRC32: Swift.Bool, progress: Foundation.Progress?, preferredEncoding: Swift.String.Encoding?) throws
  func url(for directory: Foundation.FileManager.SearchPathDirectory, in domain: Foundation.FileManager.SearchPathDomainMask, appropriateFor url: Foundation.URL?, create shouldCreate: Swift.Bool) throws -> Foundation.URL
  func urls(for directory: Foundation.FileManager.SearchPathDirectory, in domainMask: Foundation.FileManager.SearchPathDomainMask) -> [Foundation.URL]
  func attributesOfItem(atPath path: Swift.String) throws -> [Foundation.FileAttributeKey : Any]
  func containerURL(forSecurityApplicationGroupIdentifier groupIdentifier: Swift.String) -> Foundation.URL?
  func subpaths(atPath path: Swift.String) -> [Swift.String]?
  func getTotalAllocatedSize(for url: Foundation.URL) throws -> Swift.Int
  func save(data: Foundation.Data, to location: Foundation.URL, options: Foundation.Data.WritingOptions) throws
  func data(at url: Foundation.URL) throws -> Foundation.Data
}
extension SDSoup.FileManagerTwin {
  public func createDirectory(at url: Foundation.URL) throws
  public func contentsOfDirectory(at url: Foundation.URL) throws -> [Foundation.URL]
  public func contentsOfDirectory(at url: Foundation.URL, options mask: Foundation.FileManager.DirectoryEnumerationOptions) throws -> [Foundation.URL]
  public func createDirectory(at url: Foundation.URL, withIntermediateDirectories: Swift.Bool) throws
  public func zipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL) throws
  public func unzipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL, progress: Foundation.Progress?) throws
  public func getSize(for url: Foundation.URL) -> Swift.Int?
  public func getCreationDate(for url: Foundation.URL) -> Foundation.Date?
}
#if compiler(>=5.3) && $RetroactiveAttribute
extension Foundation.FileManager : SDSoup.FileManagerTwin, @unchecked @retroactive Swift.Sendable {
  public func getTotalAllocatedSize(for url: Foundation.URL) throws -> Swift.Int
  public func save(data: Foundation.Data, to location: Foundation.URL, options: Foundation.Data.WritingOptions) throws
  public func data(at url: Foundation.URL) throws -> Foundation.Data
}
#else
extension Foundation.FileManager : SDSoup.FileManagerTwin, @unchecked Swift.Sendable {
  public func getTotalAllocatedSize(for url: Foundation.URL) throws -> Swift.Int
  public func save(data: Foundation.Data, to location: Foundation.URL, options: Foundation.Data.WritingOptions) throws
  public func data(at url: Foundation.URL) throws -> Foundation.Data
}
#endif
extension Swift.FixedWidthInteger {
  @inlinable public func _roundUpToPowerOfTwo() -> Self {
        guard self > 0 else { return 0 }
        let l = Self.bitWidth - (self &- 1).leadingZeroBitCount
        return 1 << l
    }
}
extension Swift.FloatingPoint where Self.Stride : Swift.ExpressibleByFloatLiteral {
  public static var accuracy: Self.Stride {
    get
  }
  @inlinable public func isAlmostGreater(_ number: Self, accuracy: Self.Stride = Self.accuracy) -> Swift.Bool {
        number.distance(to: self) > accuracy
    }
  @inlinable public func isAlmostGreaterOrEqual(_ number: Self, accuracy: Self.Stride = Self.accuracy) -> Swift.Bool {
        isAlmostEqual(number, accuracy: accuracy) || isAlmostGreater(number, accuracy: accuracy)
    }
  @inlinable public func isAlmostLess(_ number: Self, accuracy: Self.Stride = Self.accuracy) -> Swift.Bool {
        number.distance(to: self) < -accuracy
    }
  @inlinable public func isAlmostLessOrEqual(_ number: Self, accuracy: Self.Stride = Self.accuracy) -> Swift.Bool {
        isAlmostEqual(number, accuracy: accuracy) || isAlmostLess(number, accuracy: accuracy)
    }
  @inlinable public func isAlmostEqual(_ number: Self, accuracy: Self.Stride = Self.accuracy) -> Swift.Bool {
        abs(number.distance(to: self)) <= accuracy
    }
}
extension ObjectiveC.NSObject : SDSoup.Configurable {
}
extension Foundation.URL : SDSoup.Configurable {
}
extension Foundation.JSONDecoder : SDSoup.Configurable {
}
extension Foundation.Data : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
         
        guard let string = String(data: self, encoding: .utf8) else {
            let string = S("<") + String(describing: count) + S(">")
            return .string(string)
        }

        return .string(string)
    }
  }
}
extension Foundation.Date : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        let string = String(describing: self)
        return .string(string)
    }
  }
}
extension Foundation.URL : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        .string(absoluteString)
    }
  }
}
extension Foundation.Bundle : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        .string(bundlePath)
    }
  }
}
extension Foundation.URLRequest : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        let fields = [
            S("method"): httpMethod,
            S("url"): url,
            S("headers"): allHTTPHeaderFields,
            S("body"): httpBody,
        ] as [String: Any?]

        return Pretty.convert(fields.compactMapValues { $0 })
    }
  }
}
final public class GestureActionAdapter<Gesture> where Gesture : UIKit.UIGestureRecognizer {
  public init(assertionCaller: any SDSoup.AssertionCaller, action: @escaping (Gesture) -> Swift.Void)
  @objc final public func handleGesture(_ sender: UIKit.UIGestureRecognizer)
  @objc deinit
}
final public class GlobalAssertionCaller : SDSoup.AssertionCaller, @unchecked Swift.Sendable {
  @inlinable final public func fatalError(_ message: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt) -> Swift.Never {
        subject.fatalError(message(), file: file, line: line)
    }
  @inlinable final public func assert(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt) {
        subject.assert(condition(), message(), file: file, line: line)
    }
  @inlinable final public func assertionFailure(_ message: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt) {
        subject.assertionFailure(message(), file: file, line: line)
    }
  final public func set(_ subject: any SDSoup.AssertionCaller)
  public init()
  @usableFromInline
  @SDSoup.Atomic final internal var subject: any SDSoup.AssertionCaller {
    get
    set
    _modify
  }
  @objc deinit
}
public protocol HTTPCookieStorageTwin {
  var cookies: [Foundation.HTTPCookie]? { get }
  func deleteCookie(_ cookie: Foundation.HTTPCookie)
}
extension Foundation.HTTPCookieStorage : SDSoup.HTTPCookieStorageTwin {
}
@propertyWrapper public struct HTTPHeaderName {
  public let wrappedValue: Swift.String
  public var projectedValue: SDSoup.HTTPHeaderName {
    get
  }
  public init(wrappedValue: Swift.String)
  @inlinable public init(_ value: Swift.String) {
        self.init(wrappedValue: value)
    }
}
extension SDSoup.HTTPHeaderName : Swift.Hashable, Swift.Codable, Swift.Sendable, Swift.Comparable, Swift.ExpressibleByStringLiteral, Swift.ExpressibleByUnicodeScalarLiteral, Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  public init(stringLiteral value: Swift.String)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(unicodeScalarLiteral value: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func < (lhs: SDSoup.HTTPHeaderName, rhs: SDSoup.HTTPHeaderName) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SDSoup.HTTPHeaderName, b: SDSoup.HTTPHeaderName) -> Swift.Bool
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}
extension SDSoup.HTTPHeaderName {
  public static let accept: SDSoup.HTTPHeaderName
  public static let authorization: SDSoup.HTTPHeaderName
  public static let userAgent: SDSoup.HTTPHeaderName
  public static let contentLength: SDSoup.HTTPHeaderName
  public static let contentType: SDSoup.HTTPHeaderName
  public static let contentDisposition: SDSoup.HTTPHeaderName
  public static let setCookie: SDSoup.HTTPHeaderName
  public static let cacheControl: SDSoup.HTTPHeaderName
}
extension SDSoup.HTTPHeaderName {
  public static let xOS: SDSoup.HTTPHeaderName
  public static let xOSVersion: SDSoup.HTTPHeaderName
  public static let xSurface: SDSoup.HTTPHeaderName
  public static let xSurfaceVersion: SDSoup.HTTPHeaderName
  public static let xDevice: SDSoup.HTTPHeaderName
  public static let xBundleID: SDSoup.HTTPHeaderName
  public static let xRequestID: SDSoup.HTTPHeaderName
  public static let xServiceID: SDSoup.HTTPHeaderName
  public static let xNameSpace: SDSoup.HTTPHeaderName
}
public enum ImageFormat : Swift.String, Swift.RawRepresentable {
  case bmp
  case gif
  case ico
  case jpeg
  case png
  case svg
  case tiff
  case webp
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
extension SDSoup.ImageFormat {
  public static func isGif(contentType: Swift.String?) -> Swift.Bool?
}
public protocol ImageID : Swift.Sendable {
  var name: Swift.String { get }
  func image(in imageProvider: any SDSoup.ImageProvider) -> UIKit.UIImage
}
extension SDSoup.ImageID where Self : Swift.RawRepresentable, Self.RawValue == Swift.String {
  public var name: Swift.String {
    get
  }
}
extension SDSoup.ImageID {
  public func isImageEqual(to imageID: any SDSoup.ImageID) -> Swift.Bool
  public func image(in imageProvider: any SDSoup.ImageProvider) -> UIKit.UIImage
}
extension SDSoup.ImageID {
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional where Wrapped == any SDSoup.ImageID {
  public func isImageEqual(to imageID: (any SDSoup.ImageID)?) -> Swift.Bool
}
#else
extension Swift.Optional where Wrapped == any SDSoup.ImageID {
  public func isImageEqual(to imageID: (any SDSoup.ImageID)?) -> Swift.Bool
}
#endif
extension Foundation.URL : SDSoup.ImageID {
  @inlinable public var name: Swift.String {
    get {
        absoluteString
    }
  }
}
extension UIKit.UIImage : SDSoup.ImageID {
  @inlinable public var name: Swift.String {
    get {
        S("image")
    }
  }
  @inlinable public func image(in _: any SDSoup.ImageProvider) -> UIKit.UIImage {
        self
    }
}
public func areImagesEqual(_ lhs: (any SDSoup.ImageID)?, _ rhs: (any SDSoup.ImageID)?) -> Swift.Bool
public struct EmptyImageID : SDSoup.ImageID {
  public var name: Swift.String
  public init()
}
extension SDSoup.ImageProvider {
  public func prefixed(by prefix: Swift.String) -> any SDSoup.ImageProvider
}
public protocol ImageProvider : Swift.Sendable {
  func getImage(for id: any SDSoup.ImageID) -> UIKit.UIImage?
}
extension SDSoup.ImageProvider {
  public func image(for id: any SDSoup.ImageID) -> UIKit.UIImage
}
extension SDSoup.DependencyKey {
  public static var imageProvider: SDSoup.ViewContextKey<any SDSoup.ImageProvider> {
    get
  }
}
public enum ImageProviders {
  public static func `default`() -> any SDSoup.ImageProvider
  public static func closure(_ block: @escaping @Sendable (any SDSoup.ImageID) -> UIKit.UIImage?) -> any SDSoup.ImageProvider
  public static func bundle(_ bundle: Foundation.Bundle) -> any SDSoup.ImageProvider
  public static func sequence(_ providers: [any SDSoup.ImageProvider]) -> any SDSoup.ImageProvider
}
public typealias InstallID = SDSoup.Tagged<SDSoup.InstallIDTag, Swift.String>
public enum InstallIDTag {
}
extension Swift.FixedWidthInteger {
  @inlinable @inline(__always) internal var _nonzeroBitCount: Self {
    get {
        Self(truncatingIfNeeded: nonzeroBitCount)
    }
  }
  @inlinable @inline(__always) public func _rank(ofBit bit: Swift.UInt) -> Swift.Int {
        assert(bit < Self.bitWidth)
        let mask: Self = (1 &<< bit) &- 1
        return (self & mask).nonzeroBitCount
    }
}
extension Swift.UInt {
  @_effects(releasenone) public func _bit(ranked n: Swift.Int) -> Swift.UInt?
}
extension Swift.UInt32 {
  @_effects(releasenone) public func _bit(ranked n: Swift.Int) -> Swift.UInt?
}
extension Swift.UInt16 {
  @_effects(releasenone) public func _bit(ranked n: Swift.Int) -> Swift.UInt?
}
public typealias JSON = Swift.Sendable
extension Foundation.JSONSerialization {
  public static func jsonData(with object: any Swift.Sendable, options: Foundation.JSONSerialization.WritingOptions = []) throws -> Foundation.Data
  @inlinable public static func jsonString(with object: any Swift.Sendable, options: Foundation.JSONSerialization.WritingOptions = []) throws -> Swift.String {
        let data = try jsonData(with: object, options: options)
        return String(decoding: data, as: UTF8.self)
    }
  public static func jsonObject<T>(_: T.Type, with data: Foundation.Data, options: Foundation.JSONSerialization.ReadingOptions = []) throws -> T where T : Swift.Sendable
  @inlinable public static func jsonObject<T>(_: T.Type, with string: Swift.String, options: Foundation.JSONSerialization.ReadingOptions = []) throws -> T where T : Swift.Sendable {
        try jsonObject(T.self, with: string.utf8Data(), options: options)
    }
}
extension Foundation.JSONSerialization.WritingOptions {
  public static var prettyAndStable: Foundation.JSONSerialization.WritingOptions {
    get
  }
  @available(*, deprecated, message: "Используйте опции напрямую")
  public static func sortedKeys(_ isSortedKeys: Swift.Bool) -> Foundation.JSONSerialization.WritingOptions
  @available(*, deprecated, message: "Используйте опции напрямую")
  public static func prettyAndStable(_ isPrettyAndStable: Swift.Bool) -> Foundation.JSONSerialization.WritingOptions
}
extension Swift.Decodable {
  @inlinable public init(jsonObject: any Swift.Sendable, decoder: Foundation.JSONDecoder = JSONDecoder()) throws {
        let data = try JSONSerialization.jsonData(with: jsonObject)
        self = try decoder.decode(Self.self, from: data)
    }
}
public struct JWT : Swift.Sendable {
  public enum JWTError : Foundation.LocalizedError, Swift.CustomDebugStringConvertible, Swift.Equatable {
    case invalidBase64URL(Swift.String)
    case invalidJSON(Swift.String)
    case invalidPartCount(Swift.String, Swift.Int)
    public var localizedDescription: Swift.String {
      get
    }
    public var errorDescription: Swift.String? {
      get
    }
    public var debugDescription: Swift.String {
      get
    }
    public static func == (a: SDSoup.JWT.JWTError, b: SDSoup.JWT.JWTError) -> Swift.Bool
  }
  public let header: [Swift.String : any Swift.Sendable]
  public let body: [Swift.String : any Swift.Sendable]
  public let signature: Swift.String?
  public var expiresAt: Foundation.Date? {
    get
  }
  public var issuer: Swift.String? {
    get
  }
  public var subject: Swift.String? {
    get
  }
  public var audience: [Swift.String]? {
    get
  }
  public var tokenID: Swift.String? {
    get
  }
  public var issuedAt: Foundation.Date? {
    get
  }
  public var notBefore: Foundation.Date? {
    get
  }
  public var identifier: Swift.String? {
    get
  }
  public init(header: [Swift.String : any Swift.Sendable], body: [Swift.String : any Swift.Sendable], signature: Swift.String? = nil)
  public init(string: Swift.String) throws
}
extension SDSoup.JWT {
  public func string(_ name: Swift.String) -> Swift.String?
}
public func == <T, V>(lhs: Swift.KeyPath<T, V>, rhs: V) -> (T) -> Swift.Bool where V : Swift.Equatable
public func != <T, V>(lhs: Swift.KeyPath<T, V>, rhs: V) -> (T) -> Swift.Bool where V : Swift.Equatable
extension Swift.KeyedDecodingContainerProtocol {
  public func decodeStringErasingWords(forKey key: Self.Key) throws -> Swift.String
  public func decodeStringErasingWords(forKey key: Self.Key) -> Swift.String?
}
public struct KeyedStringProvider<Key> where Key : SDSoup.StringID {
  public init(provider: any SDSoup.StringProvider)
  public func string(for id: Key) -> Swift.String
}
extension SDSoup.StringProvider {
  public func keyed<Key>() -> SDSoup.KeyedStringProvider<Key> where Key : SDSoup.StringID
  public func keyedBy<Key>(_: Key.Type) -> SDSoup.KeyedStringProvider<Key> where Key : SDSoup.StringID
}
extension QuartzCore.CACornerMask {
  public static let topLeftCorner: QuartzCore.CACornerMask
  public static let topRightCorner: QuartzCore.CACornerMask
  public static let bottomLeftCorner: QuartzCore.CACornerMask
  public static let bottomRightCorner: QuartzCore.CACornerMask
}
public class LimitedLinkedList<T> {
  public var isEmpty: Swift.Bool {
    get
  }
  public var size: Swift.Int {
    get
  }
  public var values: [T] {
    get
  }
  public init(capacity: Swift.Int)
  public func append(_ value: T)
  public func clean()
  public func flush() -> [T]
  @objc deinit
}
extension SDSoup.LinkedList : Swift.Collection {
  public typealias Index = SDSoup.LinkedListIndex<ElementType>
  final public var startIndex: SDSoup.LinkedList<ElementType>.Index {
    get
  }
  final public var endIndex: SDSoup.LinkedList<ElementType>.Index {
    get
  }
  final public subscript(position: SDSoup.LinkedList<ElementType>.Index) -> ElementType {
    get
  }
  final public func index(after idx: SDSoup.LinkedList<ElementType>.Index) -> SDSoup.LinkedList<ElementType>.Index
  public typealias Element = ElementType
  public typealias Indices = Swift.DefaultIndices<SDSoup.LinkedList<ElementType>>
  public typealias Iterator = Swift.IndexingIterator<SDSoup.LinkedList<ElementType>>
  public typealias SubSequence = Swift.Slice<SDSoup.LinkedList<ElementType>>
}
public struct LinkedListIndex<T> : Swift.Comparable {
  public static func == (lhs: SDSoup.LinkedListIndex<T>, rhs: SDSoup.LinkedListIndex<T>) -> Swift.Bool
  public static func < (lhs: SDSoup.LinkedListIndex<T>, rhs: SDSoup.LinkedListIndex<T>) -> Swift.Bool
}
extension SDSoup.LinkedList : Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
}
extension SDSoup.LinkedList : Swift.ExpressibleByArrayLiteral {
  convenience public init(arrayLiteral elements: ElementType...)
  public typealias ArrayLiteralElement = ElementType
}
@_hasMissingDesignatedInitializers final public class LinkedList<ElementType> {
  @_hasMissingDesignatedInitializers public class LinkedListNode {
    public var value: ElementType
    public var next: SDSoup.LinkedList<ElementType>.LinkedListNode? {
      get
    }
    weak public var previous: SDSoup.LinkedList<ElementType>.LinkedListNode? {
      get
    }
    @objc deinit
  }
  public typealias Node = SDSoup.LinkedList<ElementType>.LinkedListNode
  final public var head: SDSoup.LinkedList<ElementType>.Node? {
    get
  }
  convenience public init(disposalQueue: Dispatch.DispatchQueue = DispatchQueue.global())
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var count: Swift.Int {
    get
  }
  final public subscript(index: Swift.Int) -> ElementType {
    get
  }
  final public func append(_ value: ElementType)
  final public func append(_ values: [ElementType])
  final public func append(_ list: SDSoup.LinkedList<ElementType>)
  final public func insert(_ value: ElementType, at index: Swift.Int)
  final public func insert(_ list: SDSoup.LinkedList<ElementType>, at index: Swift.Int)
  final public func removeAll()
  @discardableResult
  final public func removeLast() -> ElementType
  @discardableResult
  final public func removeFirst() -> ElementType?
  @discardableResult
  final public func remove(at index: Swift.Int) -> ElementType
  @objc deinit
}
final public class LiveTimeProvider {
  final public var time: Combine.AnyPublisher<Foundation.Date, Swift.Never> {
    get
  }
  public init()
  @objc deinit
  final public func start()
  final public func stop()
}
extension Foundation.Locale {
  public static let ru: Foundation.Locale
}
extension _Concurrency.MainActor {
  public static func syncOnMain<T>(_ block: @_Concurrency.MainActor @Sendable () throws -> T) rethrows -> T where T : Swift.Sendable
}
public typealias Milliseconds = SDSoup.Tagged<Foundation.TimeInterval, Swift.Int>
extension Swift.Double {
  public var milliseconds: SDSoup.Milliseconds {
    get
  }
  public var nanoseconds: Swift.UInt64 {
    get
  }
}
extension SDSoup.Tagged where Tag == Swift.Double, T == Swift.Int {
  public var seconds: Foundation.TimeInterval {
    get
  }
  public var nanoseconds: Swift.UInt64 {
    get
  }
}
public enum MimeTypeTag {
}
public typealias MimeType = SDSoup.Tagged<SDSoup.MimeTypeTag, Swift.String>
extension SDSoup.Tagged where Tag == SDSoup.MimeTypeTag, T == Swift.String {
  public static let audioOgg: SDSoup.MimeType
  public static let videoMP4: SDSoup.MimeType
  public static let videoMOV: SDSoup.MimeType
  public static let pdf: SDSoup.MimeType
  public static let text: SDSoup.MimeType
  public static let bmp: SDSoup.MimeType
  public static let png: SDSoup.MimeType
  public static let gif: SDSoup.MimeType
  public static let vnd: SDSoup.MimeType
  public static let jpeg: SDSoup.MimeType
  public static let pjpeg: SDSoup.MimeType
  public static let svg: SDSoup.MimeType
  public static let tif: SDSoup.MimeType
  public static let tiff: SDSoup.MimeType
  public static let webp: SDSoup.MimeType
  public var fileExtension: Swift.String {
    get
  }
  public static func mimeType(ext: Swift.String?) -> SDSoup.MimeType
}
extension Foundation.URL {
  public func mimeType() -> SDSoup.MimeType
}
extension Swift.String {
  public func mimeType() -> SDSoup.MimeType
}
public enum MonorepoVersion {
  public static let value: Swift.String
  public static let buildNumber: Swift.String
}
@propertyWrapper @dynamicMemberLookup public struct MutableProperty<Value> : SDSoup.PropertyType {
  @usableFromInline
  internal let getter: () -> Value
  @usableFromInline
  internal let setter: (Value) -> Swift.Void
  @inlinable public var value: Value {
    get { getter() }
    nonmutating set { setter(newValue) }
  }
  public let signal: Combine.AnyPublisher<Swift.Void, Swift.Never>
  @inlinable public var wrappedValue: Value {
    get { value }
    nonmutating set { value = newValue }
  }
  @inlinable public var projectedValue: SDSoup.MutableProperty<Value> {
    get { self }
  }
  public init(signal: Combine.AnyPublisher<Swift.Void, Swift.Never>, getter: @escaping () -> Value, setter: @escaping (Value) -> Swift.Void)
  @inlinable public subscript<T>(dynamicMember keyPath: Swift.WritableKeyPath<Value, T>) -> SDSoup.MutableProperty<T> {
    get {
        map(
            to: { value in
                value[keyPath: keyPath]
            },
            from: { part in
                var newValue = value
                newValue[keyPath: keyPath] = part
                return newValue
            }
        )
    }
  }
}
extension SDSoup.MutableProperty {
  final public class Storage {
    final public func get() -> Value
    final public func set(_ newValue: Value)
    public init(_ value: Value)
    @objc deinit
  }
  @inlinable public init(getter: @escaping () -> Value, setter: @escaping (Value) -> Swift.Void) {
        let signal = PassthroughSubject<Void, Never>()
        let lock = NSRecursiveLock()

        self.init(
            signal: signal.eraseToAnyPublisher(),
            getter: {
                lock.lock()
                defer { lock.unlock() }
                return getter()
            },
            setter: {
                lock.lock()
                defer { lock.unlock() }
                setter($0)
                signal.send()
            }
        )
    }
  @inlinable public func asProperty() -> SDSoup.Property<Value> {
        Property(
            signal: signal,
            getter: getter
        )
    }
  @inlinable public init(wrappedValue: Value) {
        let storage = Storage(wrappedValue)

        self.init(
            getter: storage.get,
            setter: storage.set
        )
    }
  @inlinable public init(_ wrappedValue: Value) {
        self.init(wrappedValue: wrappedValue)
    }
}
extension SDSoup.MutableProperty {
  @inlinable public func map<U>(to transform: @escaping (Value) -> U, from reverseTransform: @escaping (U) -> Value?) -> SDSoup.MutableProperty<U> {
        MutableProperty<U>(
            signal: signal,
            getter: {
                transform(self.value)
            },
            setter: {
                guard let newValue = reverseTransform($0) else {
                    return
                }
                self.setter(newValue)
            }
        )
    }
  @available(*, deprecated, message: "Используйте @dynamicMemberLookup")
  @inlinable internal func map<U>(_ keyPath: Swift.WritableKeyPath<Value, U>) -> SDSoup.MutableProperty<U> {
        map(
            to: { value in
                value[keyPath: keyPath]
            },
            from: { part in
                var newValue = value
                newValue[keyPath: keyPath] = part
                return newValue
            }
        )
    }
  @inlinable public func nonnull<U>(default: U) -> SDSoup.MutableProperty<U> where Value == U? {
        map(
            to: { value in
                value ?? `default`
            },
            from: { $0 }
        )
    }
}
extension SDSoup.MutableProperty : Swift.Equatable where Value : Swift.Equatable {
  @inlinable public static func == (lhs: SDSoup.MutableProperty<Value>, rhs: SDSoup.MutableProperty<Value>) -> Swift.Bool {
        lhs.value == rhs.value
    }
}
extension SDSoup.MutableProperty where Value : Swift.ExpressibleByNilLiteral {
  @inlinable public init() {
        self.init(wrappedValue: nil)
    }
}
extension SDSoup.MutableProperty where Value == Swift.Bool {
  @inlinable public func toggle() {
        value.toggle()
    }
}
extension Foundation.NSAttributedString {
  public typealias Attributes = [Foundation.NSAttributedString.Key : Any]
  public var wholeRange: Foundation.NSRange {
    get
  }
  public func ranges(of key: Foundation.NSAttributedString.Key) -> [Foundation.NSRange]
  public func ranges(of key: Foundation.NSAttributedString.Key, in range: Foundation.NSRange) -> [Foundation.NSRange]
  public func rangesMissingAttribute(for key: Foundation.NSAttributedString.Key) -> [Foundation.NSRange]
  public func rangesMissingAttribute(for key: Foundation.NSAttributedString.Key, in range: Foundation.NSRange) -> [Foundation.NSRange]
  public func paragraphRanges() -> [Foundation.NSRange]
  public func enumerateAttributes<A>(for key: Foundation.NSAttributedString.Key, block: (_ attr: A, _ range: Foundation.NSRange) -> Swift.Void)
  public func enumerateAttributes<A>(for key: Foundation.NSAttributedString.Key, in range: Foundation.NSRange, block: (_ attr: A, _ range: Foundation.NSRange) -> Swift.Void)
}
public protocol NWBrowserTwin : AnyObject {
  var stateUpdateHandler: (@Sendable (Network.NWBrowser.State) -> Swift.Void)? { get set }
  func start(queue: Dispatch.DispatchQueue)
  func cancel()
}
extension Network.NWBrowser : SDSoup.NWBrowserTwin {
}
public protocol NamedType {
  static var typeName: Swift.String { get }
  var typeName: Swift.String { get }
}
extension SDSoup.NamedType {
  public static var typeName: Swift.String {
    get
  }
  public var typeName: Swift.String {
    get
  }
}
public protocol NetServiceTwin : AnyObject {
  var delegate: (any Foundation.NetServiceDelegate)? { get set }
  func publish()
  func stop()
}
extension Foundation.NetService : SDSoup.NetServiceTwin {
}
public struct NullAssertionCaller : SDSoup.AssertionCaller {
  public init()
  public func assert(_: @autoclosure () -> Swift.Bool, _: @autoclosure () -> Swift.String, file _: Swift.StaticString, line _: Swift.UInt)
  public func fatalError(_ message: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt) -> Swift.Never
  public func assertionFailure(_: @autoclosure () -> Swift.String, file _: Swift.StaticString, line _: Swift.UInt)
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional {
  public func asArray() -> [Wrapped]
}
#else
extension Swift.Optional {
  public func asArray() -> [Wrapped]
}
#endif
public enum OptionalError : Foundation.LocalizedError, Swift.Equatable {
  case noValue(Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: SDSoup.OptionalError, b: SDSoup.OptionalError) -> Swift.Bool
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional {
  @inlinable public var isSome: Swift.Bool {
    get { self != nil }
  }
  @inlinable public var isNone: Swift.Bool {
    get { self == nil }
  }
}
#else
extension Swift.Optional {
  @inlinable public var isSome: Swift.Bool {
    get { self != nil }
  }
  @inlinable public var isNone: Swift.Bool {
    get { self == nil }
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional where Wrapped == Swift.Bool {
  @inlinable prefix public static func ! (optional: Swift.Bool?) -> Swift.Bool? {
        optional?.toggled
    }
}
#else
extension Swift.Optional where Wrapped == Swift.Bool {
  @inlinable prefix public static func ! (optional: Swift.Bool?) -> Swift.Bool? {
        optional?.toggled
    }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional where Wrapped : Swift.Collection {
  public var isNullOrEmpty: Swift.Bool {
    get
  }
}
#else
extension Swift.Optional where Wrapped : Swift.Collection {
  public var isNullOrEmpty: Swift.Bool {
    get
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional {
  @inlinable public func get(elseThrow error: @autoclosure () -> any Swift.Error) throws -> Wrapped {
        guard let value = self else {
            throw error()
        }
        return value
    }
  @inlinable public func get(elseThrow key: @autoclosure () -> Swift.String) throws -> Wrapped {
        guard let value = self else {
            throw OptionalError.noValue(key())
        }
        return value
    }
  @inlinable public func asResult(throwing key: @autoclosure () -> Swift.String) -> Swift.Result<Wrapped, any Swift.Error> {
        guard let value = self else {
            return .failure(OptionalError.noValue(key()))
        }
        return .success(value)
    }
  @inlinable public func get(file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line) throws -> Wrapped {
        let fileName = URL(fileURLWithPath: file).lastPathComponent
        return try get(elseThrow: OptionalError.noValue(fileName + S(":") + String(describing: line) + S(":") + function))
    }
}
#else
extension Swift.Optional {
  @inlinable public func get(elseThrow error: @autoclosure () -> any Swift.Error) throws -> Wrapped {
        guard let value = self else {
            throw error()
        }
        return value
    }
  @inlinable public func get(elseThrow key: @autoclosure () -> Swift.String) throws -> Wrapped {
        guard let value = self else {
            throw OptionalError.noValue(key())
        }
        return value
    }
  @inlinable public func asResult(throwing key: @autoclosure () -> Swift.String) -> Swift.Result<Wrapped, any Swift.Error> {
        guard let value = self else {
            return .failure(OptionalError.noValue(key()))
        }
        return .success(value)
    }
  @inlinable public func get(file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line) throws -> Wrapped {
        let fileName = URL(fileURLWithPath: file).lastPathComponent
        return try get(elseThrow: OptionalError.noValue(fileName + S(":") + String(describing: line) + S(":") + function))
    }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional {
  @inlinable public func ifSome(_ perform: (Wrapped) throws -> Swift.Void) rethrows {
        if let wrapped = self {
            try perform(wrapped)
        }
    }
}
#else
extension Swift.Optional {
  @inlinable public func ifSome(_ perform: (Wrapped) throws -> Swift.Void) rethrows {
        if let wrapped = self {
            try perform(wrapped)
        }
    }
}
#endif
extension SDSoup.OrderedDictionary : Swift.Encodable where Key : Swift.Encodable, Value : Swift.Encodable {
  @inlinable public func encode(to encoder: any Swift.Encoder) throws {
         
        var container = encoder.unkeyedContainer()
        for (key, value) in self {
            try container.encode(key)
            try container.encode(value)
        }
    }
}
extension SDSoup.OrderedDictionary : Swift.Decodable where Key : Swift.Decodable, Value : Swift.Decodable {
  @inlinable public init(from decoder: any Swift.Decoder) throws {
         
        var container = try decoder.unkeyedContainer()

        self.init()
        while !container.isAtEnd {
            let key = try container.decode(Key.self)
            let (index, bucket) = self._keys._find(key)
            guard index == nil else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: S("Duplicate key at offset ") + String(describing: container.currentIndex - 1)
                )
                throw DecodingError.dataCorrupted(context)
            }

            guard !container.isAtEnd else {
                throw DecodingError.dataCorrupted(
                    DecodingError.Context(
                        codingPath: container.codingPath,
                        debugDescription: S("Unkeyed container reached end before value in key-value pair")
                    )
                )
            }
            let value = try container.decode(Value.self)
            _keys._appendNew(key, in: bucket)
            _values.append(value)
        }
        _checkInvariants()
    }
}
extension SDSoup.OrderedDictionary : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension SDSoup.OrderedDictionary : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SDSoup.OrderedDictionary : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SDSoup.OrderedDictionary.Elements {
  @frozen public struct SubSequence {
    @usableFromInline
    internal var _base: SDSoup.OrderedDictionary<Key, Value>
    @usableFromInline
    internal var _bounds: Swift.Range<Swift.Int>
    @inlinable @inline(__always) internal init(_base: SDSoup.OrderedDictionary<Key, Value>, bounds: Swift.Range<Swift.Int>) {
            self._base = _base
            self._bounds = bounds
        }
  }
}
extension SDSoup.OrderedDictionary.Elements.SubSequence : Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension SDSoup.OrderedDictionary.Elements.SubSequence : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SDSoup.OrderedDictionary.Elements.SubSequence : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SDSoup.OrderedDictionary.Elements.SubSequence {
  @inlinable @inline(__always) public var keys: SDSoup.OrderedSet<Key>.SubSequence {
    get {
        _base._keys[_bounds]
    }
  }
  @inlinable @inline(__always) public var values: SDSoup.OrderedDictionary<Key, Value>.Values.SubSequence {
    get {
        _base.values[_bounds]
    }
  }
}
extension SDSoup.OrderedDictionary.Elements.SubSequence {
  @inlinable public func index(forKey key: Key) -> Swift.Int? {
        guard let index = _base.index(forKey: key) else { return nil }
        guard _bounds.contains(index) else { return nil }
        return index
    }
}
extension SDSoup.OrderedDictionary.Elements.SubSequence : Swift.Sequence {
  public typealias Element = SDSoup.OrderedDictionary<Key, Value>.Element
  @frozen public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal var _base: SDSoup.OrderedDictionary<Key, Value>
    @usableFromInline
    internal var _end: Swift.Int
    @usableFromInline
    internal var _index: Swift.Int
    @inlinable @inline(__always) internal init(_base: SDSoup.OrderedDictionary<Key, Value>.Elements.SubSequence) {
            self._base = _base._base
            self._end = _base._bounds.upperBound
            self._index = _base._bounds.lowerBound
        }
    @inlinable public mutating func next() -> SDSoup.OrderedDictionary<Key, Value>.Elements.SubSequence.Element? {
            guard _index < _end else { return nil }
            defer { _index += 1 }
            return (_base._keys[_index], _base._values[_index])
        }
    public typealias Element = SDSoup.OrderedDictionary<Key, Value>.Elements.SubSequence.Element
  }
  @inlinable @inline(__always) public func makeIterator() -> SDSoup.OrderedDictionary<Key, Value>.Elements.SubSequence.Iterator {
        Iterator(_base: self)
    }
}
extension SDSoup.OrderedDictionary.Elements.SubSequence.Iterator : Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension SDSoup.OrderedDictionary.Elements.SubSequence : Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias SubSequence = SDSoup.OrderedDictionary<Key, Value>.Elements.SubSequence
  @inlinable @inline(__always) public var startIndex: Swift.Int {
    get { _bounds.lowerBound }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Int {
    get { _bounds.upperBound }
  }
  @inlinable @inline(__always) public var indices: Swift.Range<Swift.Int> {
    get { _bounds }
  }
  @inlinable @inline(__always) public func index(after i: Swift.Int) -> Swift.Int { i + 1 }
  @inlinable @inline(__always) public func index(before i: Swift.Int) -> Swift.Int { i - 1 }
  @inlinable @inline(__always) public func formIndex(after i: inout Swift.Int) { i += 1 }
  @inlinable @inline(__always) public func formIndex(before i: inout Swift.Int) { i -= 1 }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
        i + distance
    }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
        _base._values.index(i, offsetBy: distance, limitedBy: limit)
    }
  @inlinable @inline(__always) public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
        end - start
    }
  @inlinable public subscript(position: Swift.Int) -> SDSoup.OrderedDictionary<Key, Value>.Elements.SubSequence.Element {
    get {
        precondition(_bounds.contains(position), S("Index out of range"))
        return (_base._keys[position], _base._values[position])
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> SDSoup.OrderedDictionary<Key, Value>.Elements.SubSequence.SubSequence {
    get {
        precondition(
            bounds.lowerBound >= _bounds.lowerBound
                && bounds.upperBound <= _bounds.upperBound,
            S("Index out of range")
        )
        return Self(_base: _base, bounds: bounds)
    }
  }
  @inlinable @inline(__always) public var isEmpty: Swift.Bool {
    get { _bounds.isEmpty }
  }
  @inlinable @inline(__always) public var count: Swift.Int {
    get { _bounds.count }
  }
}
extension SDSoup.OrderedDictionary {
  @frozen public struct Elements {
    @usableFromInline
    internal var _base: SDSoup.OrderedDictionary<Key, Value>
    @inlinable @inline(__always) internal init(_base: SDSoup.OrderedDictionary<Key, Value>) {
            self._base = _base
        }
  }
}
extension SDSoup.OrderedDictionary.Elements : Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension SDSoup.OrderedDictionary {
  @inlinable @inline(__always) public var elements: SDSoup.OrderedDictionary<Key, Value>.Elements {
    get {
            Elements(_base: self)
        }
    @inline(__always) _modify {
            var elements = Elements(_base: self)
            self = Self()
            defer { self = elements._base }
            yield &elements
        }
  }
}
extension SDSoup.OrderedDictionary.Elements {
  @inlinable @inline(__always) public var keys: SDSoup.OrderedSet<Key> {
    get {
        _base._keys
    }
  }
  @inlinable @inline(__always) public var values: SDSoup.OrderedDictionary<Key, Value>.Values {
    get {
            _base.values
        }
    @inline(__always) _modify {
            var values = OrderedDictionary.Values(_base: _base)
            self = Self(_base: .init())
            defer { self._base = values._base }
            yield &values
        }
  }
}
extension SDSoup.OrderedDictionary.Elements {
  @inlinable public func index(forKey key: Key) -> Swift.Int? {
        _base.index(forKey: key)
    }
}
extension SDSoup.OrderedDictionary.Elements : Swift.Sequence {
  public typealias Element = (key: Key, value: Value)
  @inlinable public var underestimatedCount: Swift.Int {
    get { _base.count }
  }
  @inlinable public func makeIterator() -> SDSoup.OrderedDictionary<Key, Value>.Iterator {
        _base.makeIterator()
    }
  public typealias Iterator = SDSoup.OrderedDictionary<Key, Value>.Iterator
}
extension SDSoup.OrderedDictionary.Elements : Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable @inline(__always) public var startIndex: Swift.Int {
    get { 0 }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Int {
    get { _base.count }
  }
  @inlinable @inline(__always) public func index(after i: Swift.Int) -> Swift.Int { i + 1 }
  @inlinable @inline(__always) public func index(before i: Swift.Int) -> Swift.Int { i - 1 }
  @inlinable @inline(__always) public func formIndex(after i: inout Swift.Int) { i += 1 }
  @inlinable @inline(__always) public func formIndex(before i: inout Swift.Int) { i -= 1 }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
        i + distance
    }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
        _base._values.index(i, offsetBy: distance, limitedBy: limit)
    }
  @inlinable @inline(__always) public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
        end - start
    }
  @inlinable @inline(__always) public subscript(position: Swift.Int) -> SDSoup.OrderedDictionary<Key, Value>.Elements.Element {
    get {
        (_base._keys[position], _base._values[position])
    }
  }
  public subscript(bounds: Swift.Range<Swift.Int>) -> SDSoup.OrderedDictionary<Key, Value>.Elements.SubSequence {
    get
  }
  @inlinable @inline(__always) public var isEmpty: Swift.Bool {
    get { _base.isEmpty }
  }
  @inlinable @inline(__always) public var count: Swift.Int {
    get { _base.count }
  }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
        _base._values._failEarlyRangeCheck(index, bounds: bounds)
    }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.ClosedRange<Swift.Int>) {
        _base._values._failEarlyRangeCheck(index, bounds: bounds)
    }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
        _base._values._failEarlyRangeCheck(range, bounds: bounds)
    }
}
extension SDSoup.OrderedDictionary.Elements : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SDSoup.OrderedDictionary.Elements : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SDSoup.OrderedDictionary.Elements : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension SDSoup.OrderedDictionary.Elements : Swift.Equatable where Value : Swift.Equatable {
  @inlinable public static func == (left: SDSoup.OrderedDictionary<Key, Value>.Elements, right: SDSoup.OrderedDictionary<Key, Value>.Elements) -> Swift.Bool {
        left._base == right._base
    }
}
extension SDSoup.OrderedDictionary.Elements : Swift.Hashable where Value : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
        _base.hash(into: &hasher)
    }
  public var hashValue: Swift.Int {
    get
  }
}
extension SDSoup.OrderedDictionary.Elements {
  @inlinable @inline(__always) public mutating func swapAt(_ i: Swift.Int, _ j: Swift.Int) {
        _base.swapAt(i, j)
    }
  @inlinable @inline(__always) public mutating func partition(by belongsInSecondPartition: (SDSoup.OrderedDictionary<Key, Value>.Elements.Element) throws -> Swift.Bool) rethrows -> Swift.Int {
        try _base.partition(by: belongsInSecondPartition)
    }
}
extension SDSoup.OrderedDictionary.Elements {
  @inlinable @inline(__always) public mutating func sort(by areInIncreasingOrder: (SDSoup.OrderedDictionary<Key, Value>.Elements.Element, SDSoup.OrderedDictionary<Key, Value>.Elements.Element) throws -> Swift.Bool) rethrows {
        try _base.sort(by: areInIncreasingOrder)
    }
}
extension SDSoup.OrderedDictionary.Elements where Key : Swift.Comparable {
  @inlinable @inline(__always) public mutating func sort() {
        _base.sort()
    }
}
extension SDSoup.OrderedDictionary.Elements {
  @inlinable public mutating func shuffle() {
        _base.shuffle()
    }
  @inlinable public mutating func shuffle<T>(using generator: inout T) where T : Swift.RandomNumberGenerator {
        _base.shuffle(using: &generator)
    }
}
extension SDSoup.OrderedDictionary.Elements {
  @inlinable public mutating func reverse() {
        _base.reverse()
    }
}
extension SDSoup.OrderedDictionary.Elements {
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
        _base.removeAll(keepingCapacity: keepCapacity)
    }
  @discardableResult
  @inlinable public mutating func remove(at index: Swift.Int) -> SDSoup.OrderedDictionary<Key, Value>.Elements.Element {
        _base.remove(at: index)
    }
  @inlinable public mutating func removeSubrange(_ bounds: Swift.Range<Swift.Int>) {
        _base.removeSubrange(bounds)
    }
  @inlinable public mutating func removeSubrange<R>(_ bounds: R) where R : Swift.RangeExpression, R.Bound == Swift.Int {
        _base.removeSubrange(bounds)
    }
  @discardableResult
  @inlinable public mutating func removeLast() -> SDSoup.OrderedDictionary<Key, Value>.Elements.Element {
        _base.removeLast()
    }
  @inlinable public mutating func removeLast(_ n: Swift.Int) {
        _base.removeLast(n)
    }
  @discardableResult
  @inlinable public mutating func removeFirst() -> SDSoup.OrderedDictionary<Key, Value>.Elements.Element {
        _base.removeFirst()
    }
  @inlinable public mutating func removeFirst(_ n: Swift.Int) {
        _base.removeFirst(n)
    }
  @inlinable public mutating func removeAll(where shouldBeRemoved: (SDSoup.OrderedDictionary<Key, Value>.Elements.Element) throws -> Swift.Bool) rethrows {
        try _base.removeAll(where: shouldBeRemoved)
    }
}
extension SDSoup.OrderedDictionary : Swift.Equatable where Value : Swift.Equatable {
  @inlinable public static func == (left: SDSoup.OrderedDictionary<Key, Value>, right: SDSoup.OrderedDictionary<Key, Value>) -> Swift.Bool {
        left._keys == right._keys && left._values == right._values
    }
}
extension SDSoup.OrderedDictionary : Swift.ExpressibleByDictionaryLiteral {
  @inlinable public init(dictionaryLiteral elements: (Key, Value)...) {
        self.init(uniqueKeysWithValues: elements)
    }
}
extension SDSoup.OrderedDictionary : Swift.Hashable where Value : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
        hasher.combine(count)  
        for (key, value) in self {
            hasher.combine(key)
            hasher.combine(value)
        }
    }
  public var hashValue: Swift.Int {
    get
  }
}
extension SDSoup.OrderedDictionary {
  @inlinable @inline(__always) public init() {
        self._keys = OrderedSet()
        self._values = []
    }
  @inlinable @inline(__always) public init(minimumCapacity: Swift.Int, persistent: Swift.Bool = false) {
        self._keys = OrderedSet(minimumCapacity: minimumCapacity, persistent: persistent)
        self._values = []
        _values.reserveCapacity(minimumCapacity)
    }
}
extension SDSoup.OrderedDictionary {
  @_disfavoredOverload @inlinable public init<Seq>(uniqueKeysWithValues keysAndValues: Seq) where Seq : Swift.Sequence, Seq.Element == (key: Key, value: Value) {
        if Seq.self == [Key: Value].self {
            self.init(_uncheckedUniqueKeysWithValues: keysAndValues)
            return
        }
        self.init()
        reserveCapacity(keysAndValues.underestimatedCount)
        for (key, value) in keysAndValues {
            guard _keys._append(key).inserted else {
                preconditionFailure(S("Duplicate key: '") + String(describing: key) + S("'"))
            }
            _values.append(value)
        }
    }
  @inlinable public init<Seq>(uniqueKeysWithValues keysAndValues: Seq) where Seq : Swift.Sequence, Seq.Element == (Key, Value) {
        self.init()
        reserveCapacity(keysAndValues.underestimatedCount)
        for (key, value) in keysAndValues {
            guard _keys._append(key).inserted else {
                preconditionFailure(S("Duplicate key: '") + String(describing: key) + S("'"))
            }
            _values.append(value)
        }
    }
}
extension SDSoup.OrderedDictionary {
  @inlinable public init<Keys, Values>(uniqueKeys keys: Keys, values: Values) where Key == Keys.Element, Value == Values.Element, Keys : Swift.Sequence, Values : Swift.Sequence {
        let keys = ContiguousArray(keys)
        let values = ContiguousArray(values)
        precondition(
            keys.count == values.count,
            S("Mismatching element counts between keys and values")
        )
        self._keys = .init(keys)
        self._values = values
        precondition(_keys.count == _values.count, S("Duplicate keys"))
        _checkInvariants()
    }
}
extension SDSoup.OrderedDictionary {
  @_disfavoredOverload @inlinable @inline(__always) public init<Seq>(_ keysAndValues: Seq, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where Seq : Swift.Sequence, Seq.Element == (key: Key, value: Value) {
        self.init()
        try self.merge(keysAndValues, uniquingKeysWith: combine)
    }
  @inlinable @inline(__always) public init<Seq>(_ keysAndValues: Seq, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where Seq : Swift.Sequence, Seq.Element == (Key, Value) {
        self.init()
        try self.merge(keysAndValues, uniquingKeysWith: combine)
    }
}
extension SDSoup.OrderedDictionary {
  @inlinable public init<Seq>(grouping values: Seq, by keyForValue: (Seq.Element) throws -> Key) rethrows where Value : Swift.RangeReplaceableCollection, Seq : Swift.Sequence, Value.Element == Seq.Element {
        try self.init(_grouping: values, by: keyForValue)
    }
  @inlinable public init<Seq>(grouping values: Seq, by keyForValue: (Seq.Element) throws -> Key) rethrows where Value == [Seq.Element], Seq : Swift.Sequence {
         
         
         
        try self.init(_grouping: values, by: keyForValue)
    }
  @inlinable internal init<Seq>(_grouping values: Seq, by keyForValue: (Seq.Element) throws -> Key) rethrows where Value : Swift.RangeReplaceableCollection, Seq : Swift.Sequence, Value.Element == Seq.Element {
        self.init()
        for value in values {
            let key = try keyForValue(value)
            self.updateValue(forKey: key, default: Value()) { array in
                array.append(value)
            }
        }
    }
}
extension SDSoup.OrderedDictionary {
  @inlinable internal init<Seq>(_uncheckedUniqueKeysWithValues keysAndValues: Seq) where Seq : Swift.Sequence, Seq.Element == (key: Key, value: Value) {
        self.init()
        reserveCapacity(keysAndValues.underestimatedCount)
        for (key, value) in keysAndValues {
            _keys._appendNew(key)
            _values.append(value)
        }
        _checkInvariants()
    }
  @_disfavoredOverload @inlinable public init<Seq>(uncheckedUniqueKeysWithValues keysAndValues: Seq) where Seq : Swift.Sequence, Seq.Element == (key: Key, value: Value) {
        self.init(_uncheckedUniqueKeysWithValues: keysAndValues)
    }
  @inlinable public init<Seq>(uncheckedUniqueKeysWithValues keysAndValues: Seq) where Seq : Swift.Sequence, Seq.Element == (Key, Value) {
         
        let keysAndValues = keysAndValues.lazy.map { (key: $0.0, value: $0.1) }
        self.init(uncheckedUniqueKeysWithValues: keysAndValues)
    }
}
extension SDSoup.OrderedDictionary {
  @inlinable @inline(__always) public init<Keys, Values>(uncheckedUniqueKeys keys: Keys, values: Values) where Key == Keys.Element, Value == Values.Element, Keys : Swift.Sequence, Values : Swift.Sequence {
        self._keys = .init(uncheckedUniqueElements: keys)
        self._values = .init(values)
        precondition(_keys.count == _values.count)
        _checkInvariants()
    }
}
extension SDSoup.OrderedDictionary {
  public static var _isConsistencyCheckingEnabled: Swift.Bool {
    get
  }
  @inline(__always) @inlinable public func _checkInvariants() {}
}
extension SDSoup.OrderedDictionary {
  @inlinable public mutating func swapAt(_ i: Swift.Int, _ j: Swift.Int) {
        _keys.swapAt(i, j)
        _values.swapAt(i, j)
    }
  @inlinable public mutating func partition(by belongsInSecondPartition: (SDSoup.OrderedDictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows -> Swift.Int {
        let pivot = try _values.withUnsafeMutableBufferPointer { values in
            try _keys._partition(values: values, by: belongsInSecondPartition)
        }
        _checkInvariants()
        return pivot
    }
}
extension SDSoup.OrderedDictionary {
  @inlinable public mutating func sort(by areInIncreasingOrder: (SDSoup.OrderedDictionary<Key, Value>.Element, SDSoup.OrderedDictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows {
         
        let temp = try self.sorted(by: areInIncreasingOrder)
        precondition(temp.count == self.count)
        temp.withUnsafeBufferPointer { source in
            _keys = OrderedSet(uncheckedUniqueElements: source.lazy.map(\.key))
            _values = ContiguousArray(source.lazy.map(\.value))
        }
        _checkInvariants()
    }
}
extension SDSoup.OrderedDictionary where Key : Swift.Comparable {
  @inlinable public mutating func sort() {
        sort { $0.key < $1.key }
    }
}
extension SDSoup.OrderedDictionary {
  @inlinable public mutating func shuffle() {
        var generator = SystemRandomNumberGenerator()
        shuffle(using: &generator)
    }
  @inlinable public mutating func shuffle<T>(using generator: inout T) where T : Swift.RandomNumberGenerator {
        guard count > 1 else { return }
        var keys = self._keys.elements
        var values = self._values
        self = [:]
        var amount = keys.count
        var current = 0
        while amount > 1 {
            let random = Int.random(in: 0 ..< amount, using: &generator)
            amount -= 1
            keys.swapAt(current, current + random)
            values.swapAt(current, current + random)
            current += 1
        }
        self = OrderedDictionary(uncheckedUniqueKeys: keys, values: values)
    }
}
extension SDSoup.OrderedDictionary {
  @inlinable public mutating func reverse() {
        _keys.reverse()
        _values.reverse()
    }
}
extension SDSoup.OrderedDictionary {
  @inlinable public mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
        self._keys.reserveCapacity(minimumCapacity)
        self._values.reserveCapacity(minimumCapacity)
    }
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
        _keys.removeAll(keepingCapacity: keepCapacity)
        _values.removeAll(keepingCapacity: keepCapacity)
    }
  @discardableResult
  @inlinable public mutating func remove(at index: Swift.Int) -> SDSoup.OrderedDictionary<Key, Value>.Element {
        let key = _keys.remove(at: index)
        let value = _values.remove(at: index)
        return (key, value)
    }
  @inlinable public mutating func removeSubrange(_ bounds: Swift.Range<Swift.Int>) {
        _keys.removeSubrange(bounds)
        _values.removeSubrange(bounds)
    }
  @inlinable public mutating func removeSubrange<R>(_ bounds: R) where R : Swift.RangeExpression, R.Bound == Swift.Int {
        removeSubrange(bounds.relative(to: elements))
    }
  @discardableResult
  @inlinable public mutating func removeLast() -> SDSoup.OrderedDictionary<Key, Value>.Element {
        precondition(!isEmpty, S("Cannot remove last element of an empty collection"))
        return remove(at: count - 1)
    }
  @inlinable public mutating func removeLast(_ n: Swift.Int) {
        precondition(n >= 0, S("Can't remove a negative number of elements"))
        precondition(n <= count, S("Can't remove more elements than there are in the collection"))
        _keys.removeLast(n)
        _values.removeLast(n)
    }
  @discardableResult
  @inlinable public mutating func removeFirst() -> SDSoup.OrderedDictionary<Key, Value>.Element {
        precondition(!isEmpty, S("Cannot remove first element of an empty collection"))
        return remove(at: 0)
    }
  @inlinable public mutating func removeFirst(_ n: Swift.Int) {
        precondition(n >= 0, S("Can't remove a negative number of elements"))
        precondition(n <= count, S("Can't remove more elements than there are in the collection"))
        _keys.removeFirst(n)
        _values.removeFirst(n)
    }
  @inlinable public mutating func removeAll(where shouldBeRemoved: (SDSoup.OrderedDictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows {
        let pivot = try _values.withUnsafeMutableBufferPointer { values in
            try _keys._halfStablePartition(
                values: values,
                by: shouldBeRemoved
            )
        }
        removeSubrange(pivot...)
        _checkInvariants()
    }
}
extension SDSoup.OrderedDictionary : @unchecked Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension SDSoup.OrderedDictionary : Swift.Sequence {
  public typealias Element = (key: Key, value: Value)
  @frozen public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal let _base: SDSoup.OrderedDictionary<Key, Value>
    @usableFromInline
    internal var _position: Swift.Int
    @inlinable @inline(__always) internal init(_base: SDSoup.OrderedDictionary<Key, Value>) {
            self._base = _base
            self._position = 0
        }
    @inlinable public mutating func next() -> SDSoup.OrderedDictionary<Key, Value>.Element? {
            guard _position < _base._values.count else { return nil }
            let result = (_base._keys[_position], _base._values[_position])
            _position += 1
            return result
        }
    public typealias Element = SDSoup.OrderedDictionary<Key, Value>.Element
  }
  @inlinable @inline(__always) public var underestimatedCount: Swift.Int {
    get {
        count
    }
  }
  @inlinable @inline(__always) public func makeIterator() -> SDSoup.OrderedDictionary<Key, Value>.Iterator {
        Iterator(_base: self)
    }
}
extension SDSoup.OrderedDictionary.Iterator : Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension SDSoup.OrderedDictionary {
  @frozen public struct Values {
    @usableFromInline
    internal var _base: SDSoup.OrderedDictionary<Key, Value>
    @inlinable @inline(__always) internal init(_base: SDSoup.OrderedDictionary<Key, Value>) {
            self._base = _base
        }
  }
}
extension SDSoup.OrderedDictionary.Values : Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension SDSoup.OrderedDictionary.Values : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SDSoup.OrderedDictionary.Values : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SDSoup.OrderedDictionary.Values {
  @inlinable @inline(__always) public var elements: [Value] {
    get {
        Array(_base._values)
    }
  }
}
extension SDSoup.OrderedDictionary.Values {
  @inlinable @inline(__always) public func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<SDSoup.OrderedDictionary<Key, Value>.Values.Element>) throws -> R) rethrows -> R {
        try _base._values.withUnsafeBufferPointer(body)
    }
  @inlinable @inline(__always) public mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<SDSoup.OrderedDictionary<Key, Value>.Values.Element>) throws -> R) rethrows -> R {
        try _base._values.withUnsafeMutableBufferPointer(body)
    }
}
extension SDSoup.OrderedDictionary.Values : Swift.Sequence {
  public typealias Element = Value
  public typealias Iterator = Swift.IndexingIterator<SDSoup.OrderedDictionary<Key, Value>.Values>
}
extension SDSoup.OrderedDictionary.Values : Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable @inline(__always) public var startIndex: Swift.Int {
    get { 0 }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Int {
    get { _base._values.count }
  }
  @inlinable @inline(__always) public func index(after i: Swift.Int) -> Swift.Int { i + 1 }
  @inlinable @inline(__always) public func index(before i: Swift.Int) -> Swift.Int { i - 1 }
  @inlinable @inline(__always) public func formIndex(after i: inout Swift.Int) { i += 1 }
  @inlinable @inline(__always) public func formIndex(before i: inout Swift.Int) { i -= 1 }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
        i + distance
    }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
        _base._values.index(i, offsetBy: distance, limitedBy: limit)
    }
  @inlinable @inline(__always) public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
        end - start
    }
  @inlinable @inline(__always) public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Value>) throws -> R) rethrows -> R? {
        try _base._values.withUnsafeBufferPointer(body)
    }
}
extension SDSoup.OrderedDictionary.Values : Swift.MutableCollection {
  @inlinable @inline(__always) public subscript(position: Swift.Int) -> Value {
    get {
            _base._values[position]
        }
    @inline(__always) _modify {
            yield &_base._values[position]
        }
  }
  @inlinable @inline(__always) public mutating func swapAt(_ i: Swift.Int, _ j: Swift.Int) {
        _base._values.swapAt(i, j)
    }
  @inlinable @inline(__always) public mutating func partition(by belongsInSecondPartition: (Value) throws -> Swift.Bool) rethrows -> Swift.Int {
        try _base._values.partition(by: belongsInSecondPartition)
    }
  @inlinable @inline(__always) public mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<SDSoup.OrderedDictionary<Key, Value>.Values.Element>) throws -> R) rethrows -> R? {
        try _base._values.withUnsafeMutableBufferPointer(body)
    }
  public typealias SubSequence = Swift.Slice<SDSoup.OrderedDictionary<Key, Value>.Values>
}
extension SDSoup.OrderedDictionary.Values : Swift.Equatable where Value : Swift.Equatable {
  @inlinable public static func == (left: SDSoup.OrderedDictionary<Key, Value>.Values, right: SDSoup.OrderedDictionary<Key, Value>.Values) -> Swift.Bool {
        left.elementsEqual(right)
    }
}
extension SDSoup.OrderedDictionary.Values : Swift.Hashable where Value : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
        hasher.combine(count)  
        for item in self {
            hasher.combine(item)
        }
    }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public struct OrderedDictionary<Key, Value> where Key : Swift.Hashable {
  @usableFromInline
  internal var _keys: SDSoup.OrderedSet<Key>
  @usableFromInline
  internal var _values: Swift.ContiguousArray<Value>
  @inlinable @inline(__always) internal init(_uniqueKeys keys: SDSoup.OrderedSet<Key>, values: Swift.ContiguousArray<Value>) {
        self._keys = keys
        self._values = values
    }
}
extension SDSoup.OrderedDictionary {
  @inlinable @inline(__always) public var keys: SDSoup.OrderedSet<Key> {
    get { _keys }
  }
  @inlinable @inline(__always) public var values: SDSoup.OrderedDictionary<Key, Value>.Values {
    get { Values(_base: self) }
    @inline(__always) _modify {
            var values = Values(_base: self)
            self = [:]
            defer { self = values._base }
            yield &values
        }
  }
}
extension SDSoup.OrderedDictionary {
  public typealias Index = Swift.Int
  @inlinable @inline(__always) public var isEmpty: Swift.Bool {
    get { _values.isEmpty }
  }
  @inlinable @inline(__always) public var count: Swift.Int {
    get { _values.count }
  }
  @inlinable @inline(__always) public func index(forKey key: Key) -> Swift.Int? {
        _keys.firstIndex(of: key)
    }
}
extension SDSoup.OrderedDictionary {
  @inlinable public subscript(key: Key) -> Value? {
    get {
            guard let index = _keys.firstIndex(of: key) else { return nil }
            return _values[index]
        }
    set {
             
             
             
            let (index, bucket) = _keys._find(key)
            switch (index, newValue) {
            case let (index?, newValue?):  
                _values[index] = newValue
            case let (index?, nil):  
                _keys._removeExistingMember(at: index, in: bucket)
                _values.remove(at: index)
            case let (nil, newValue?):  
                _keys._appendNew(key, in: bucket)
                _values.append(newValue)
            case (nil, nil):  
                break
            }
            _checkInvariants()
        }
    @inline(__always) _modify {
            var value: Value?
            let (index, bucket) = _prepareForKeyingModify(key, &value)
            defer {
                _finalizeKeyingModify(key, index, bucket, &value)
            }
            yield &value
        }
  }
  @inlinable internal mutating func _prepareForKeyingModify(_ key: Key, _ value: inout Value?) -> (index: Swift.Int?, bucket: SDSoup._HashTable.Bucket) {
        let (index, bucket) = _keys._find(key)

         
         
        if let index {
            _values.swapAt(index, _values.count - 1)
            value = _values.removeLast()
        }
        return (index, bucket)
    }
  @inlinable internal mutating func _finalizeKeyingModify(_ key: Key, _ index: Swift.Int?, _ bucket: SDSoup._HashTable.Bucket, _ value: inout Value?) {
        switch (index, value) {
        case let (index?, value?):  
            _values.append(value)
            _values.swapAt(index, _values.count - 1)
        case let (index?, nil):  
            if index < _values.count {
                let standin = _values.remove(at: index)
                _values.append(standin)
            }
            _keys._removeExistingMember(at: index, in: bucket)
        case let (nil, value?):  
            _keys._appendNew(key, in: bucket)
            _values.append(value)
        case (nil, nil):  
            break
        }
        _checkInvariants()
    }
  @inlinable public subscript(key: Key, default defaultValue: @autoclosure () -> Value) -> Value {
    get {
            guard let offset = _keys.firstIndex(of: key) else { return defaultValue() }
            return _values[offset]
        }
    @inline(__always) _modify {
            var (index, value) = _prepareForDefaultedModify(key, defaultValue)
            defer {
                _finalizeDefaultedModify(index, &value)
            }
            yield &value
        }
  }
  @inlinable internal mutating func _prepareForDefaultedModify(_ key: Key, _ defaultValue: () -> Value) -> (index: Swift.Int, value: Value) {
        let (inserted, index) = _keys.append(key)
        if inserted {
            assert(index == _values.count)
            _values.append(defaultValue())
        }
        let value: Value = _values.withUnsafeMutableBufferPointer { buffer in
            assert(index < buffer.count)
            return (buffer.baseAddress! + index).move()
        }
        return (index, value)
    }
  @inlinable internal mutating func _finalizeDefaultedModify(_ index: Swift.Int, _ value: inout Value) {
        _values.withUnsafeMutableBufferPointer { buffer in
            assert(index < buffer.count)
            (buffer.baseAddress! + index).initialize(to: value)
        }
    }
}
extension SDSoup.OrderedDictionary {
  @discardableResult
  @inlinable public mutating func updateValue(_ value: Value, forKey key: Key) -> Value? {
        let (index, bucket) = _keys._find(key)
        if let index {
            let old = _values[index]
            _values[index] = value
            return old
        }
        _keys._appendNew(key, in: bucket)
        _values.append(value)
        return nil
    }
  @discardableResult
  @inlinable public mutating func updateValue(_ value: Value, forKey key: Key, insertingAt index: Swift.Int) -> (originalMember: Value?, index: Swift.Int) {
        let (inserted, offset) = _keys.insert(key, at: index)
        if inserted {
            assert(offset == index)
            _values.insert(value, at: offset)
            return (nil, offset)
        }
        let old = _values[offset]
        _values[offset] = value
        return (old, offset)
    }
  @inlinable public mutating func updateValue<R>(forKey key: Key, default defaultValue: @autoclosure () -> Value, with body: (inout Value) throws -> R) rethrows -> R {
        let (index, bucket) = _keys._find(key)
        if let index {
            return try body(&_values[index])
        }
        _keys._appendNew(key, in: bucket)
        _values.append(defaultValue())
        let i = _values.index(before: _values.endIndex)
        return try body(&_values[i])
    }
  @inlinable public mutating func updateValue<R>(forKey key: Key, insertingDefault defaultValue: @autoclosure () -> Value, at index: Swift.Int, with body: (inout Value) throws -> R) rethrows -> R {
        let (existingIndex, bucket) = _keys._find(key)
        if let existingIndex {
            return try body(&_values[existingIndex])
        }
        _keys._insertNew(key, at: index, in: bucket)
        _values.insert(defaultValue(), at: index)
        return try body(&_values[index])
    }
}
extension SDSoup.OrderedDictionary {
  @discardableResult
  @inlinable public mutating func removeValue(forKey key: Key) -> Value? {
        let (idx, bucket) = _keys._find(key)
        guard let index = idx else { return nil }
        _keys._removeExistingMember(at: index, in: bucket)
        return _values.remove(at: index)
    }
}
extension SDSoup.OrderedDictionary {
  @_disfavoredOverload @inlinable public mutating func merge<S>(_ keysAndValues: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (key: Key, value: Value) {
        for (key, value) in keysAndValues {
            let (index, bucket) = _keys._find(key)
            if let index {
                try { $0 = try combine($0, value) }(&_values[index])
            } else {
                _keys._appendNew(key, in: bucket)
                _values.append(value)
            }
        }
    }
  @inlinable public mutating func merge<S>(_ keysAndValues: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (Key, Value) {
        let mapped: LazyMapSequence =
            keysAndValues.lazy.map { (key: $0.0, value: $0.1) }
        try merge(mapped, uniquingKeysWith: combine)
    }
  @_disfavoredOverload @inlinable public __consuming func merging<S>(_ other: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows -> SDSoup.OrderedDictionary<Key, Value> where S : Swift.Sequence, S.Element == (key: Key, value: Value) {
        var copy = self
        try copy.merge(other, uniquingKeysWith: combine)
        return copy
    }
  @inlinable public __consuming func merging<S>(_ other: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows -> SDSoup.OrderedDictionary<Key, Value> where S : Swift.Sequence, S.Element == (Key, Value) {
        var copy = self
        try copy.merge(other, uniquingKeysWith: combine)
        return copy
    }
}
extension SDSoup.OrderedDictionary {
  @inlinable public func filter(_ isIncluded: (SDSoup.OrderedDictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows -> SDSoup.OrderedDictionary<Key, Value> {
        var result: OrderedDictionary = [:]
        for element in self where try isIncluded(element) {
            result._keys._appendNew(element.key)
            result._values.append(element.value)
        }
        return result
    }
}
extension SDSoup.OrderedDictionary {
  @inlinable public func mapValues<T>(_ transform: (Value) throws -> T) rethrows -> SDSoup.OrderedDictionary<Key, T> {
        OrderedDictionary<Key, T>(
            _uniqueKeys: _keys,
            values: ContiguousArray(try _values.map(transform))
        )
    }
  @inlinable public func compactMapValues<T>(_ transform: (Value) throws -> T?) rethrows -> SDSoup.OrderedDictionary<Key, T> {
        var result: OrderedDictionary<Key, T> = [:]
        for (key, value) in self {
            if let value = try transform(value) {
                result._keys._appendNew(key)
                result._values.append(value)
            }
        }
        return result
    }
}
extension SDSoup.OrderedSet : Swift.Encodable where Element : Swift.Encodable {
  @inlinable public func encode(to encoder: any Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(_elements)
    }
}
extension SDSoup.OrderedSet : Swift.Decodable where Element : Swift.Decodable {
  @inlinable public init(from decoder: any Swift.Decoder) throws {
        let container = try decoder.singleValueContainer()
        let elements = try container.decode(ContiguousArray<Element>.self)

        let (table, end) = _HashTable.create(untilFirstDuplicateIn: elements)
        guard end == elements.endIndex else {
            let context = DecodingError.Context(
                codingPath: container.codingPath,
                debugDescription: S("Decoded elements aren't unique (first duplicate at offset ") + String(describing: end) + S(")")
            )
            throw DecodingError.dataCorrupted(context)
        }
        self.init(
            _uniqueElements: elements,
            elements.count > _HashTable.maximumUnhashedCount ? table : nil
        )
    }
}
extension SDSoup.OrderedSet : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension SDSoup.OrderedSet : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SDSoup.OrderedSet : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SDSoup.OrderedSet {
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public func difference(from other: SDSoup.OrderedSet<Element>) -> Swift.CollectionDifference<Element>
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public func applying(_ difference: Swift.CollectionDifference<Element>) -> SDSoup.OrderedSet<Element>?
}
extension SDSoup.OrderedSet : Swift.Equatable {
  @inlinable public static func == (left: SDSoup.OrderedSet<Element>, right: SDSoup.OrderedSet<Element>) -> Swift.Bool {
        left.elementsEqual(right)
    }
}
extension SDSoup.OrderedSet : Swift.ExpressibleByArrayLiteral {
  @inlinable public init(arrayLiteral elements: Element...) {
        self.init(elements)
    }
  public typealias ArrayLiteralElement = Element
}
extension SDSoup.OrderedSet : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
        hasher.combine(count)  
        for item in _elements {
            hasher.combine(item)
        }
    }
  public var hashValue: Swift.Int {
    get
  }
}
extension SDSoup.OrderedSet {
  @inlinable @inline(__always) public init<Seq>(uncheckedUniqueElements elements: Seq) where Element == Seq.Element, Seq : Swift.Sequence {
        let elements = ContiguousArray<Element>(elements)
        let table = _HashTable.create(uncheckedUniqueElements: elements)
        self.init(
            _uniqueElements: elements,
            elements.count > _HashTable.maximumUnhashedCount ? table : nil
        )
        _checkInvariants()
    }
}
extension SDSoup.OrderedSet {
  @inlinable public init<Seq>(_ elements: Seq) where Element == Seq.Element, Seq : Swift.Sequence {
        if Seq.self == Self.self {
            self = elements as! Self
            return
        }
         
        if elements is _UniqueCollection {
            self.init(uncheckedUniqueElements: elements)
            return
        }

        self.init(minimumCapacity: elements.underestimatedCount)
        append(contentsOf: elements)
    }
  @inlinable public init(_ elements: SDSoup.OrderedSet<Element>) {
        self = elements
    }
  @inlinable public init(_ elements: SDSoup.OrderedSet<Element>.SubSequence) {
        self.init(uncheckedUniqueElements: elements._slice)
    }
  @inlinable public init(_ elements: Swift.Set<Element>) {
        self.init(uncheckedUniqueElements: elements)
    }
  @inlinable public init<Value>(_ elements: Swift.Dictionary<Element, Value>.Keys) {
        self._elements = ContiguousArray(elements)
        _regenerateHashTable()
        _checkInvariants()
    }
  @inlinable public init<C>(_ elements: C) where Element == C.Element, C : Swift.RandomAccessCollection {
         
         
        let (table, firstDupe) = _HashTable.create(
            untilFirstDuplicateIn: elements)
        if firstDupe == elements.endIndex {
             
            self.init(_uniqueElements: ContiguousArray(elements), table)
            return
        }

         
        self.init(_uniqueElements: ContiguousArray(elements[..<firstDupe]), table)
        self.append(contentsOf: elements[firstDupe...])
    }
}
extension SDSoup.OrderedSet {
  @inlinable internal mutating func _appendNew(_ item: Element) {
        assert(!contains(item), S("Duplicate item"))
        _elements.append(item)
        guard _elements.count <= _capacity else {
            _regenerateHashTable()
            return
        }
        guard _table != nil else { return }
        _ensureUnique()
        _table!.update { hashTable in
            var it = hashTable.bucketIterator(for: item)
            it.advanceToNextUnoccupiedBucket()
            it.currentValue = _elements.count - 1
        }
    }
  @inlinable internal mutating func _appendNew(_ item: Element, in bucket: SDSoup.OrderedSet<Element>._Bucket) {
        _elements.append(item)

        guard _elements.count <= _capacity else {
            _regenerateHashTable()
            return
        }
        guard _table != nil else { return }
        _ensureUnique()
        _table!.update { hashTable in
            assert(!hashTable.isOccupied(bucket))
            hashTable[bucket] = _elements.count - 1
        }
    }
  @discardableResult
  @inlinable internal mutating func _append(_ item: Element) -> (inserted: Swift.Bool, index: Swift.Int) {
        let (index, bucket) = _find(item)
        if let index { return (false, index) }
        _appendNew(item, in: bucket)
        return (true, _elements.index(before: _elements.endIndex))
    }
  @discardableResult
  @inlinable @inline(__always) public mutating func append(_ item: Element) -> (inserted: Swift.Bool, index: Swift.Int) {
        let result = _append(item)
        _checkInvariants()
        return result
    }
  @inlinable public mutating func append<S>(contentsOf elements: S) where Element == S.Element, S : Swift.Sequence {
        for item in elements {
            _append(item)
        }
        _checkInvariants()
    }
}
extension SDSoup.OrderedSet {
  @inlinable internal mutating func _insertNew(_ item: Element, at index: Swift.Int, in bucket: SDSoup.OrderedSet<Element>._Bucket) {
        guard _elements.count < _capacity else {
            _elements.insert(item, at: index)
            _regenerateHashTable()
            return
        }
        guard _table != nil else {
            _elements.insert(item, at: index)
            return
        }

        _ensureUnique()
        _table!.update { hashTable in
            assert(!hashTable.isOccupied(bucket))
            hashTable.adjustContents(preparingForInsertionOfElementAtOffset: index, in: _elements)
            hashTable[bucket] = index
        }
        _elements.insert(item, at: index)
        _checkInvariants()
    }
  @discardableResult
  @inlinable public mutating func insert(_ item: Element, at index: Swift.Int) -> (inserted: Swift.Bool, index: Swift.Int) {
        let (existing, bucket) = _find(item)
        if let existing { return (false, existing) }
        _insertNew(item, at: index, in: bucket)
        return (true, index)
    }
}
extension SDSoup.OrderedSet {
  @discardableResult
  @inlinable public mutating func update(_ item: Element, at index: Swift.Int) -> Element {
        let old = _elements[index]
        precondition(
            item == old,
            S("The replacement item must compare equal to the original")
        )
        _elements[index] = item
        return old
    }
}
extension SDSoup.OrderedSet {
  @discardableResult
  @inlinable public mutating func updateOrAppend(_ item: Element) -> Element? {
        let (inserted, index) = _append(item)
        if inserted { return nil }
        let old = _elements[index]
        _elements[index] = item
        _checkInvariants()
        return old
    }
  @discardableResult
  @inlinable public mutating func updateOrInsert(_ item: Element, at index: Swift.Int) -> (originalMember: Element?, index: Swift.Int) {
        let (existing, bucket) = _find(item)
        if let existing {
            let old = _elements[existing]
            _elements[existing] = item
            return (old, existing)
        }
        _insertNew(item, at: index, in: bucket)
        return (nil, index)
    }
}
extension SDSoup.OrderedSet {
  public static var _isConsistencyCheckingEnabled: Swift.Bool {
    get
  }
  @inline(__always) @inlinable public func _checkInvariants() {}
}
extension SDSoup.OrderedSet {
  @inlinable public mutating func swapAt(_ i: Swift.Int, _ j: Swift.Int) {
        guard i != j else { return }
        _elements.swapAt(i, j)
        guard _table != nil else { return }
        _ensureUnique()
        _table!.update { hashTable in
            hashTable.swapBucketValues(
                for: _elements[i],
                withCurrentValue: j,
                and: _elements[j],
                withCurrentValue: i
            )
        }
        _checkInvariants()
    }
  @inlinable public mutating func partition(by belongsInSecondPartition: (Element) throws -> Swift.Bool) rethrows -> Swift.Int {
        try _partition(by: belongsInSecondPartition, callback: { _, _ in })
    }
}
extension SDSoup.OrderedSet {
  @inlinable public mutating func _partition(by belongsInSecondPartition: (Element) throws -> Swift.Bool, callback: (Swift.Int, Swift.Int) -> Swift.Void) rethrows -> Swift.Int {
        guard _table != nil else {
            return try _elements.partition(by: belongsInSecondPartition)
        }
        _ensureUnique()
        let result: Int = try _table!.update { hashTable in
            let maybeOffset: Int? = try _elements.withContiguousMutableStorageIfAvailable { buffer in
                let pivot = try buffer._partition(
                    with: hashTable,
                    by: belongsInSecondPartition,
                    callback: callback
                )
                return pivot - buffer.startIndex
            }
            if let offset = maybeOffset {
                return _elements.index(startIndex, offsetBy: offset)
            }
            return try _elements._partition(
                with: hashTable,
                by: belongsInSecondPartition,
                callback: callback
            )
        }
        _checkInvariants()
        return result
    }
}
extension Swift.MutableCollection where Self : Swift.RandomAccessCollection, Self.Element : Swift.Hashable {
  @inlinable internal mutating func _partition(with hashTable: SDSoup._UnsafeHashTable, by belongsInSecondPartition: (Self.Element) throws -> Swift.Bool, callback: (Swift.Int, Swift.Int) -> Swift.Void) rethrows -> Self.Index {
        var low = startIndex
        var high = endIndex

        while true {
             
             
             
             

             
            while true {
                if low == high { return low }
                if try belongsInSecondPartition(self[low]) { break }
                formIndex(after: &low)
            }

             
            while true {
                formIndex(before: &high)
                if low == high { return low }
                if try !belongsInSecondPartition(self[high]) { break }
            }

             
            swapAt(low, high)
            let offsetLow = _offset(of: low)
            let offsetHigh = _offset(of: high)
            hashTable.swapBucketValues(
                for: self[low],
                withCurrentValue: offsetHigh,
                and: self[high],
                withCurrentValue: offsetLow
            )
            callback(offsetLow, offsetHigh)

            formIndex(after: &low)
        }
    }
}
extension SDSoup._HashTable.UnsafeHandle {
  @inlinable @inline(__always) internal func swapBucketValues<Element>(for left: Element, withCurrentValue leftValue: Swift.Int, and right: Element, withCurrentValue rightValue: Swift.Int) where Element : Swift.Hashable {
        let left = idealBucket(for: left)
        let right = idealBucket(for: right)
        swapBucketValues(
            for: left,
            withCurrentValue: leftValue,
            and: right,
            withCurrentValue: rightValue
        )
    }
  @usableFromInline
  @_effects(releasenone) internal func swapBucketValues(for left: SDSoup._HashTable.UnsafeHandle.Bucket, withCurrentValue leftValue: Swift.Int, and right: SDSoup._HashTable.UnsafeHandle.Bucket, withCurrentValue rightValue: Swift.Int)
}
extension SDSoup.OrderedSet {
  @inlinable public mutating func sort(by areInIncreasingOrder: (Element, Element) throws -> Swift.Bool) rethrows {
        defer {
             
             
             
             
            _regenerateExistingHashTable()
            _checkInvariants()
        }
        try _elements.sort(by: areInIncreasingOrder)
    }
}
extension SDSoup.OrderedSet where Element : Swift.Comparable {
  @inlinable public mutating func sort() {
        defer {
             
             
             
             
            _regenerateExistingHashTable()
            _checkInvariants()
        }
        _elements.sort()
    }
}
extension SDSoup.OrderedSet {
  @inlinable public mutating func shuffle() {
        var generator = SystemRandomNumberGenerator()
        shuffle(using: &generator)
    }
  @inlinable public mutating func shuffle<T>(using generator: inout T) where T : Swift.RandomNumberGenerator {
        _elements.shuffle(using: &generator)
        _regenerateExistingHashTable()
        _checkInvariants()
    }
}
extension SDSoup.OrderedSet {
  @inlinable public mutating func reverse() {
        _elements.reverse()
         
        _regenerateHashTable()
        _checkInvariants()
    }
}
extension SDSoup.OrderedSet {
  @inlinable internal mutating func _halfStablePartition<Value>(values: Swift.UnsafeMutableBufferPointer<Value>, by belongsInSecondPartition: ((key: Element, value: Value)) throws -> Swift.Bool) rethrows -> Swift.Int {
        precondition(self.count == values.count)
        var i = 0
        try _elements.withUnsafeMutableBufferPointer { keys in
            while i < keys.count, try !belongsInSecondPartition((keys[i], values[i])) {
                i += 1
            }
        }
        guard i < self.count else { return self.count }

        self._ensureUnique()
        let table = _table
        self._table = nil
        defer { self._table = table }

        return try _elements.withUnsafeMutableBufferPointer { keys in
            for j in i + 1 ..< keys.count {
                guard try !belongsInSecondPartition((keys[j], values[j])) else {
                    continue
                }
                keys.swapAt(i, j)
                values.swapAt(i, j)
                table?.update { hashTable in
                    hashTable.swapBucketValues(
                        for: keys[i],
                        withCurrentValue: j,
                        and: keys[j],
                        withCurrentValue: i
                    )
                }
                i += 1
            }
            return i
        }
    }
  @inlinable internal mutating func _partition<Value>(values: Swift.UnsafeMutableBufferPointer<Value>, by belongsInSecondPartition: ((key: Element, value: Value)) throws -> Swift.Bool) rethrows -> Swift.Int {
        self._ensureUnique()
        let table = self._table
        self._table = nil
        defer { self._table = table }
        return try _elements.withUnsafeMutableBufferPointer { keys in
            assert(keys.count == values.count)
            var low = keys.startIndex
            var high = keys.endIndex

            while true {
                 
                 
                 
                 

                 
                while true {
                    if low == high { return low }
                    if try belongsInSecondPartition((keys[low], values[low])) { break }
                    low += 1
                }

                 
                while true {
                    high -= 1
                    if low == high { return low }
                    if try !belongsInSecondPartition((keys[high], values[high])) { break }
                }

                 
                keys.swapAt(low, high)
                values.swapAt(low, high)
                table?.update { hashTable in
                    hashTable.swapBucketValues(
                        for: keys[low],
                        withCurrentValue: high,
                        and: keys[high],
                        withCurrentValue: low
                    )
                }
                low += 1
            }
        }
    }
}
extension SDSoup.OrderedSet {
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
        _elements.removeAll(keepingCapacity: keepCapacity)
        guard keepCapacity else {
            _table = nil
            return
        }
        guard _table != nil else { return }
        _ensureUnique()
        _table!.update { hashTable in
            hashTable.clear()
        }
    }
  @discardableResult
  @inlinable public mutating func remove(at index: Swift.Int) -> SDSoup.OrderedSet<Element>.Element {
        _elements._failEarlyRangeCheck(index, bounds: startIndex ..< endIndex)
        let bucket = _bucket(for: index)
        return _removeExistingMember(at: index, in: bucket)
    }
  @inlinable public mutating func removeSubrange(_ bounds: Swift.Range<Swift.Int>) {
        _elements._failEarlyRangeCheck(
            bounds,
            bounds: _elements.startIndex ..< _elements.endIndex
        )
        guard _table != nil else {
            _elements.removeSubrange(bounds)
            _checkInvariants()
            return
        }
        let c = bounds.count
        guard c > 0 else { return }
        let remainingCount = _elements.count - c
        if remainingCount <= count / 2 || remainingCount < _minimumCapacity {
             
            _elements.removeSubrange(bounds)
            _regenerateHashTable()
            _checkInvariants()
            return
        }

        _ensureUnique()
        _table!.update { hashTable in
             
            for item in _elements[bounds] {
                let (offset, bucket) = hashTable._find(item, in: _elements)
                precondition(offset != nil, S("Corrupt hash table"))
                hashTable.delete(
                    bucket: bucket,
                    hashValueGenerator: { offset, seed in
                        _elements[offset]._rawHashValue(seed: seed)
                    }
                )
            }
            hashTable.adjustContents(preparingForRemovalOf: bounds, in: _elements)
        }
        _elements.removeSubrange(bounds)
        _checkInvariants()
    }
  @inlinable public mutating func removeSubrange<R>(_ bounds: R) where R : Swift.RangeExpression, R.Bound == Swift.Int {
        removeSubrange(bounds.relative(to: self))
    }
  @discardableResult
  @inlinable public mutating func removeLast() -> Element {
        precondition(!isEmpty, S("Cannot remove last element of an empty collection"))
        guard _table != nil else {
            return _elements.removeLast()
        }
        guard _elements.count - 1 >= _minimumCapacity else {
            let old = _elements.removeLast()
            _regenerateHashTable()
            return old
        }
        defer { _checkInvariants() }
        let old = _elements.removeLast()
        _ensureUnique()
        _table!.update { hashTable in
            var it = hashTable.bucketIterator(for: old)
            it.advance(until: _elements.count)
             
            hashTable.delete(
                bucket: it.currentBucket,
                hashValueGenerator: { offset, seed in
                    _elements[offset]._rawHashValue(seed: seed)
                }
            )
        }
        return old
    }
  @inlinable public mutating func removeLast(_ n: Swift.Int) {
        precondition(n >= 0, S("Can't remove a negative number of elements"))
        precondition(n <= count, S("Can't remove more elements than there are in the collection"))
        removeSubrange(count - n ..< count)
    }
  @discardableResult
  @inlinable public mutating func removeFirst() -> Element {
        precondition(!isEmpty, S("Cannot remove first element of an empty collection"))
        return remove(at: startIndex)
    }
  @inlinable public mutating func removeFirst(_ n: Swift.Int) {
        precondition(n >= 0, S("Can't remove a negative number of elements"))
        precondition(n <= count, S("Can't remove more elements than there are in the collection"))
        removeSubrange(0 ..< n)
    }
  @inlinable public mutating func removeAll(where shouldBeRemoved: (Element) throws -> Swift.Bool) rethrows {
        defer {
            _regenerateHashTable()
            _checkInvariants()
        }
        try _elements.removeAll(where: shouldBeRemoved)
    }
}
extension SDSoup.OrderedSet {
  @inlinable public mutating func formIntersection(_ other: SDSoup.OrderedSet<Element>) {
        self = self.intersection(other)
    }
  @inlinable @inline(__always) public mutating func formIntersection(_ other: SDSoup.OrderedSet<Element>.UnorderedView) {
        formIntersection(other._base)
    }
  @inlinable public mutating func formIntersection<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
        self = self.intersection(other)
    }
}
extension SDSoup.OrderedSet {
  @inlinable public mutating func formSymmetricDifference(_ other: __owned SDSoup.OrderedSet<Element>) {
        self = self.symmetricDifference(other)
    }
  @inlinable @inline(__always) public mutating func formSymmetricDifference(_ other: __owned SDSoup.OrderedSet<Element>.UnorderedView) {
        formSymmetricDifference(other._base)
    }
  @inlinable public mutating func formSymmetricDifference<S>(_ other: __owned S) where Element == S.Element, S : Swift.Sequence {
        self = self.symmetricDifference(other)
    }
}
extension SDSoup.OrderedSet {
  @inlinable public mutating func formUnion(_ other: __owned SDSoup.OrderedSet<Element>) {
        append(contentsOf: other)
    }
  @inlinable @inline(__always) public mutating func formUnion(_ other: __owned SDSoup.OrderedSet<Element>.UnorderedView) {
        formUnion(other._base)
    }
  @inlinable public mutating func formUnion<S>(_ other: __owned S) where Element == S.Element, S : Swift.Sequence {
        append(contentsOf: other)
    }
}
extension SDSoup.OrderedSet {
  @inlinable public __consuming func intersection(_ other: SDSoup.OrderedSet<Element>) -> SDSoup.OrderedSet<Element> {
        var result = Self()
        for item in self {
            if other.contains(item) {
                result._appendNew(item)
            }
        }
        result._checkInvariants()
        return result
    }
  @inlinable @inline(__always) public __consuming func intersection(_ other: SDSoup.OrderedSet<Element>.UnorderedView) -> SDSoup.OrderedSet<Element> {
        intersection(other._base)
    }
  @inlinable public __consuming func intersection<S>(_ other: S) -> SDSoup.OrderedSet<Element> where Element == S.Element, S : Swift.Sequence {
        _UnsafeBitset.withTemporaryBitset(capacity: self.count) { bitset in
            for item in other {
                if let index = self._find_inlined(item).index {
                    bitset.insert(index)
                }
            }
            let result = self._extractSubset(using: bitset)
            result._checkInvariants()
            return result
        }
    }
}
extension SDSoup.OrderedSet {
  @inlinable public func isDisjoint(with other: SDSoup.OrderedSet<Element>) -> Swift.Bool {
        guard !self.isEmpty, !other.isEmpty else { return true }
        if self.count <= other.count {
            for item in self {
                if other.contains(item) { return false }
            }
        } else {
            for item in other {
                if self.contains(item) { return false }
            }
        }
        return true
    }
  @inlinable @inline(__always) public func isDisjoint(with other: SDSoup.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
        isDisjoint(with: other._base)
    }
  @inlinable public func isDisjoint(with other: Swift.Set<Element>) -> Swift.Bool {
        guard !self.isEmpty, !other.isEmpty else { return true }
        if self.count <= other.count {
            for item in self {
                if other.contains(item) { return false }
            }
        } else {
            for item in other {
                if self.contains(item) { return false }
            }
        }
        return true
    }
  @inlinable public func isDisjoint<S>(with other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
        guard !self.isEmpty else { return true }
        for item in other {
            if self.contains(item) { return false }
        }
        return true
    }
}
extension SDSoup.OrderedSet {
  public func isEqual(to other: SDSoup.OrderedSet<Element>) -> Swift.Bool
  public func isEqual(to other: SDSoup.OrderedSet<Element>.UnorderedView) -> Swift.Bool
  public func isEqual<Seq>(to other: Seq) -> Swift.Bool where Element == Seq.Element, Seq : Swift.Sequence
}
extension SDSoup.OrderedSet {
  @inlinable public func isStrictSubset(of other: SDSoup.OrderedSet<Element>) -> Swift.Bool {
        self.count < other.count && self.isSubset(of: other)
    }
  @inlinable @inline(__always) public func isStrictSubset(of other: SDSoup.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
        isStrictSubset(of: other._base)
    }
  @inlinable public func isStrictSubset(of other: Swift.Set<Element>) -> Swift.Bool {
        self.count < other.count && self.isSubset(of: other)
    }
  @inlinable public func isStrictSubset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
        if S.self == Self.self {
            return self.isStrictSubset(of: other as! Self)
        }
        if S.self == Set<Element>.self {
            return self.isStrictSubset(of: other as! Set<Element>)
        }

        var it = self.makeIterator()
        guard let first = it.next() else {
            return other.contains(where: { _ in true })
        }
        if let match = other._customContainsEquatableElement(first) {
             
            guard match else { return false }
            while let item = it.next() {
                guard other.contains(item) else { return false }
            }
            return !other.allSatisfy { self.contains($0) }
        }

        return _UnsafeBitset.withTemporaryBitset(capacity: count) { seen in
             
            var isKnownStrict = false
            for item in other {
                if let index = _find(item).index {
                    if seen.insert(index), seen.count == self.count, isKnownStrict {
                         
                        return true
                    }
                } else {
                    if !isKnownStrict, seen.count == self.count { return true }
                    isKnownStrict = true
                }
            }
            return false
        }
    }
}
extension SDSoup.OrderedSet {
  @inlinable public func isStrictSuperset(of other: SDSoup.OrderedSet<Element>) -> Swift.Bool {
        self.count > other.count && other.isSubset(of: self)
    }
  @inlinable @inline(__always) public func isStrictSuperset(of other: SDSoup.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
        isStrictSuperset(of: other._base)
    }
  @inlinable public func isStrictSuperset(of other: Swift.Set<Element>) -> Swift.Bool {
        self.count > other.count && other.isSubset(of: self)
    }
  @inlinable public func isStrictSuperset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
        if S.self == Self.self {
            return self.isStrictSuperset(of: other as! Self)
        }
        if S.self == Set<Element>.self {
            return self.isStrictSuperset(of: other as! Set<Element>)
        }

        var it = self.makeIterator()
        guard let first = it.next() else { return false }
        if let match = other._customContainsEquatableElement(first) {
             
            guard other.allSatisfy({ self.contains($0) }) else { return false }
            guard match else { return true }
            while let item = it.next() {
                guard other.contains(item) else { return true }
            }
            return false
        }

        return _UnsafeBitset.withTemporaryBitset(capacity: count) { seen in
             
            for item in other {
                guard let index = _find(item).index else {
                    return false
                }
                if seen.insert(index), seen.count == self.count {
                     
                    return false
                }
            }
            return seen.count < self.count
        }
    }
}
extension SDSoup.OrderedSet {
  @inlinable public func isSubset(of other: SDSoup.OrderedSet<Element>) -> Swift.Bool {
        guard other.count >= self.count else { return false }
        for item in self {
            guard other.contains(item) else { return false }
        }
        return true
    }
  @inlinable @inline(__always) public func isSubset(of other: SDSoup.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
        isSubset(of: other._base)
    }
  @inlinable public func isSubset(of other: Swift.Set<Element>) -> Swift.Bool {
        guard other.count >= self.count else { return false }
        for item in self {
            guard other.contains(item) else { return false }
        }
        return true
    }
  @inlinable public func isSubset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
        guard !isEmpty else { return true }

        if S.self == Self.self {
            return isSubset(of: other as! Self)
        }

        var it = self.makeIterator()
        let first = it.next()!
        if let match = other._customContainsEquatableElement(first) {
             
            guard match else { return false }
            while let item = it.next() {
                guard other.contains(item) else { return false }
            }
            return true
        }

        return _UnsafeBitset.withTemporaryBitset(capacity: count) { seen in
             
            for item in other {
                if let index = _find(item).index {
                    if seen.insert(index), seen.count == self.count {
                         
                        return true
                    }
                }
            }
            return false
        }
    }
}
extension SDSoup.OrderedSet {
  @inlinable public func isSuperset(of other: SDSoup.OrderedSet<Element>) -> Swift.Bool {
        other.isSubset(of: self)
    }
  @inlinable public func isSuperset(of other: SDSoup.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
        isSuperset(of: other._base)
    }
  @inlinable public func isSuperset(of other: Swift.Set<Element>) -> Swift.Bool {
        guard self.count >= other.count else { return false }
        return _isSuperset(of: other)
    }
  @inlinable public func isSuperset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
        _isSuperset(of: other)
    }
  @inlinable internal func _isSuperset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
        if S.self == Self.self {
            return self.isSuperset(of: other as! Self)
        }
        for item in other {
            guard self.contains(item) else { return false }
        }
        return true
    }
}
extension SDSoup.OrderedSet {
  @inlinable @inline(__always) public mutating func subtract(_ other: SDSoup.OrderedSet<Element>) {
        self = subtracting(other)
    }
  @inlinable @inline(__always) public mutating func subtract(_ other: SDSoup.OrderedSet<Element>.UnorderedView) {
        subtract(other._base)
    }
  @inlinable @inline(__always) public mutating func subtract<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
        self = _subtracting(other)
    }
}
extension SDSoup.OrderedSet {
  @inlinable @inline(__always) public __consuming func subtracting(_ other: SDSoup.OrderedSet<Element>) -> SDSoup.OrderedSet<Element> {
        _subtracting(other)
    }
  @inlinable @inline(__always) public __consuming func subtracting(_ other: SDSoup.OrderedSet<Element>.UnorderedView) -> SDSoup.OrderedSet<Element> {
        subtracting(other._base)
    }
  @inlinable @inline(__always) public __consuming func subtracting<S>(_ other: S) -> SDSoup.OrderedSet<Element> where Element == S.Element, S : Swift.Sequence {
        _subtracting(other)
    }
  @inlinable internal __consuming func _subtracting<S>(_ other: S) -> SDSoup.OrderedSet<Element> where Element == S.Element, S : Swift.Sequence {
        guard count > 0 else { return Self() }
        return _UnsafeBitset.withTemporaryBitset(capacity: count) { difference in
            difference.insertAll(upTo: count)
            for item in other {
                if let index = self._find(item).index {
                    if difference.remove(index), difference.isEmpty {
                        return Self()
                    }
                }
            }
            assert(!difference.isEmpty)
            let result = _extractSubset(using: difference)
            result._checkInvariants()
            return result
        }
    }
}
extension SDSoup.OrderedSet {
  @inlinable public __consuming func symmetricDifference(_ other: __owned SDSoup.OrderedSet<Element>) -> SDSoup.OrderedSet<Element> {
        _UnsafeBitset.withTemporaryBitset(capacity: self.count) { bitset1 in
            _UnsafeBitset.withTemporaryBitset(capacity: other.count) { bitset2 in
                bitset1.insertAll(upTo: self.count)
                for item in other {
                    if let index = self._find(item).index {
                        bitset1.remove(index)
                    }
                }
                bitset2.insertAll(upTo: other.count)
                for item in self {
                    if let index = other._find(item).index {
                        bitset2.remove(index)
                    }
                }
                var result = self._extractSubset(
                    using: bitset1,
                    extraCapacity: bitset2.count
                )
                for offset in bitset2 {
                    result._appendNew(other._elements[offset])
                }
                result._checkInvariants()
                return result
            }
        }
    }
  @inlinable @inline(__always) public __consuming func symmetricDifference(_ other: __owned SDSoup.OrderedSet<Element>.UnorderedView) -> SDSoup.OrderedSet<Element> {
        symmetricDifference(other._base)
    }
  @inlinable public __consuming func symmetricDifference<S>(_ other: __owned S) -> SDSoup.OrderedSet<Element> where Element == S.Element, S : Swift.Sequence {
        _UnsafeBitset.withTemporaryBitset(capacity: self.count) { bitset in
            var new = Self()
            bitset.insertAll(upTo: self.count)
            for item in other {
                if let index = self._find(item).index {
                    bitset.remove(index)
                } else {
                    new.append(item)
                }
            }
            var result = _extractSubset(using: bitset, extraCapacity: new.count)
            for item in new._elements {
                result._appendNew(item)
            }
            result._checkInvariants()
            return result
        }
    }
}
extension SDSoup.OrderedSet {
  @inlinable public __consuming func union(_ other: __owned SDSoup.OrderedSet<Element>) -> SDSoup.OrderedSet<Element> {
        var result = self
        result.formUnion(other)
        return result
    }
  @inlinable @inline(__always) public __consuming func union(_ other: __owned SDSoup.OrderedSet<Element>.UnorderedView) -> SDSoup.OrderedSet<Element> {
        union(other._base)
    }
  @inlinable public __consuming func union<S>(_ other: __owned S) -> SDSoup.OrderedSet<Element> where Element == S.Element, S : Swift.Sequence {
        var result = self
        result.formUnion(other)
        return result
    }
}
extension SDSoup.OrderedSet {
  @inlinable public init() {
        __storage = nil
        _elements = []
    }
}
extension SDSoup.OrderedSet {
  @inlinable public func contains(_ element: Element) -> Swift.Bool {
        _find_inlined(element).index != nil
    }
}
extension SDSoup.OrderedSet {
  @discardableResult
  @inlinable public mutating func remove(_ member: Element) -> Element? {
        let (idx, bucket) = _find(member)
        guard let index = idx else { return nil }
        return _removeExistingMember(at: index, in: bucket)
    }
}
extension SDSoup.OrderedSet : Swift.Sequence {
  public typealias Iterator = Swift.IndexingIterator<SDSoup.OrderedSet<Element>>
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
        _find(element).index != nil
    }
  @inlinable public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
        _elements._copyToContiguousArray()
    }
  @inlinable public __consuming func _copyContents(initializing ptr: Swift.UnsafeMutableBufferPointer<Element>) -> (SDSoup.OrderedSet<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {
        guard !isEmpty else { return (makeIterator(), 0) }
        let copied: Int = _elements.withUnsafeBufferPointer { buffer in
            guard let p = ptr.baseAddress else {
                preconditionFailure(S("Attempt to copy contents into nil buffer pointer"))
            }
            let c = Swift.min(buffer.count, ptr.count)
            p.initialize(from: buffer.baseAddress!, count: c)
            return c
        }
        return (Iterator(_elements: self, _position: copied), copied)
    }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
        try _elements.withContiguousStorageIfAvailable(body)
    }
}
extension SDSoup.OrderedSet : Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable @inline(__always) public var startIndex: Swift.Int {
    get { _elements.startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Int {
    get { _elements.endIndex }
  }
  @inlinable @inline(__always) public var indices: SDSoup.OrderedSet<Element>.Indices {
    get { _elements.indices }
  }
  @inlinable @inline(__always) public func index(after i: Swift.Int) -> Swift.Int { i + 1 }
  @inlinable @inline(__always) public func index(before i: Swift.Int) -> Swift.Int { i - 1 }
  @inlinable @inline(__always) public func formIndex(after i: inout Swift.Int) { i += 1 }
  @inlinable @inline(__always) public func formIndex(before i: inout Swift.Int) { i -= 1 }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
        i + distance
    }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
        _elements.index(i, offsetBy: distance, limitedBy: limit)
    }
  @inlinable @inline(__always) public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
        end - start
    }
  @inlinable @inline(__always) public subscript(position: Swift.Int) -> Element {
    get {
        _elements[position]
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> SDSoup.OrderedSet<Element>.SubSequence {
    get {
        _failEarlyRangeCheck(bounds, bounds: startIndex ..< endIndex)
        return SubSequence(_base: self, bounds: bounds)
    }
  }
  @inlinable @inline(__always) public var isEmpty: Swift.Bool {
    get { _elements.isEmpty }
  }
  @inlinable @inline(__always) public var count: Swift.Int {
    get { _elements.count }
  }
  @inlinable public func _customIndexOfEquatableElement(_ element: Element) -> Swift.Int?? {
        guard let table = _table else {
            return _elements._customIndexOfEquatableElement(element)
        }
        return table.read { hashTable in
            let (o, _) = hashTable._find(element, in: _elements)
            guard let offset = o else { return .some(nil) }
            return offset
        }
    }
  @inlinable @inline(__always) public func _customLastIndexOfEquatableElement(_ element: Element) -> Swift.Int?? {
         
        _customIndexOfEquatableElement(element)
    }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
        _elements._failEarlyRangeCheck(index, bounds: bounds)
    }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.ClosedRange<Swift.Int>) {
        _elements._failEarlyRangeCheck(index, bounds: bounds)
    }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
        _elements._failEarlyRangeCheck(range, bounds: bounds)
    }
}
extension SDSoup.OrderedSet : SDSoup._UniqueCollection {
}
extension SDSoup.OrderedSet {
  @inlinable public init(minimumCapacity: Swift.Int, persistent: Swift.Bool = false) {
        self.init()
        self._reserveCapacity(minimumCapacity, persistent: persistent)
    }
}
extension SDSoup.OrderedSet {
  @inlinable public mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
        self._reserveCapacity(minimumCapacity, persistent: false)
    }
}
extension SDSoup.OrderedSet {
  @inlinable internal mutating func _reserveCapacity(_ minimumCapacity: Swift.Int, persistent: Swift.Bool) {
        precondition(minimumCapacity >= 0, S("Minimum capacity cannot be negative"))
        defer { _checkInvariants() }

        _elements.reserveCapacity(minimumCapacity)

        let currentScale = _scale
        let newScale = _HashTable.scale(forCapacity: minimumCapacity)

        let reservedScale = persistent ? newScale : _reservedScale

        if currentScale < newScale {
             
            _regenerateHashTable(scale: newScale, reservedScale: reservedScale)
            return
        }

        let requiredScale = _HashTable.scale(forCapacity: self.count)
        let minScale = Swift.max(Swift.max(newScale, reservedScale), requiredScale)
        if minScale < currentScale {
             
            _regenerateHashTable(scale: minScale, reservedScale: reservedScale)
            return
        }

         
         
        _ensureUnique()
        if _reservedScale != reservedScale {
             
            __storage!.header.reservedScale = reservedScale
        }
    }
}
extension SDSoup.OrderedSet : @unchecked Swift.Sendable where Element : Swift.Sendable {
}
extension SDSoup.OrderedSet {
  @frozen public struct SubSequence {
    @usableFromInline
    internal var _base: SDSoup.OrderedSet<Element>
    @usableFromInline
    internal var _bounds: Swift.Range<Swift.Int>
    @inlinable @inline(__always) internal init(_base: SDSoup.OrderedSet<Element>, bounds: Swift.Range<Swift.Int>) {
            self._base = _base
            self._bounds = bounds
        }
  }
}
extension SDSoup.OrderedSet.SubSequence : Swift.Sendable where Element : Swift.Sendable {
}
extension SDSoup.OrderedSet.SubSequence {
  @inlinable internal var _slice: Swift.Array<Element>.SubSequence {
    get {
        _base._elements[_bounds]
    }
  }
  @inlinable internal func _index(of element: Element) -> Swift.Int? {
        guard let index = _base._find(element).index else { return nil }
        guard _bounds.contains(index) else { return nil }
        return index
    }
}
extension SDSoup.OrderedSet.SubSequence : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SDSoup.OrderedSet.SubSequence : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SDSoup.OrderedSet.SubSequence : Swift.Sequence {
  public typealias Element = SDSoup.OrderedSet<Element>.Element
  public typealias Iterator = Swift.IndexingIterator<SDSoup.OrderedSet<Element>.SubSequence>
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
        _index(of: element) != nil
    }
  @inlinable public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
        _slice._copyToContiguousArray()
    }
  @inlinable public __consuming func _copyContents(initializing ptr: Swift.UnsafeMutableBufferPointer<Element>) -> (SDSoup.OrderedSet<Element>.SubSequence.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {
        guard !isEmpty else { return (makeIterator(), 0) }
        let copied: Int = _slice.withUnsafeBufferPointer { buffer in
            guard let p = ptr.baseAddress else {
                preconditionFailure(S("Attempt to copy contents into nil buffer pointer"))
            }
            let c = Swift.min(buffer.count, ptr.count)
            if c > 0 {
                p.initialize(from: buffer.baseAddress!, count: c)
            }
            return c
        }
        return (
            Iterator(_elements: self, _position: _bounds.lowerBound + copied),
            copied
        )
    }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
        try _slice.withContiguousStorageIfAvailable(body)
    }
}
extension SDSoup.OrderedSet.SubSequence : SDSoup._UniqueCollection {
}
extension SDSoup.OrderedSet.SubSequence : Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Array<Element>.SubSequence.Indices
  public typealias SubSequence = SDSoup.OrderedSet<Element>.SubSequence
  @inlinable @inline(__always) public var startIndex: Swift.Int {
    get { _bounds.lowerBound }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Int {
    get { _bounds.upperBound }
  }
  @inlinable @inline(__always) public var indices: SDSoup.OrderedSet<Element>.SubSequence.Indices {
    get { _slice.indices }
  }
  @inlinable @inline(__always) public func index(after i: Swift.Int) -> Swift.Int { i + 1 }
  @inlinable @inline(__always) public func index(before i: Swift.Int) -> Swift.Int { i - 1 }
  @inlinable @inline(__always) public func formIndex(after i: inout Swift.Int) { i += 1 }
  @inlinable @inline(__always) public func formIndex(before i: inout Swift.Int) { i -= 1 }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
        i + distance
    }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
        _slice.index(i, offsetBy: distance, limitedBy: limit)
    }
  @inlinable @inline(__always) public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
        end - start
    }
  @inlinable @inline(__always) public subscript(position: Swift.Int) -> Element {
    get {
        _slice[position]
    }
  }
  @inlinable @inline(__always) public subscript(bounds: Swift.Range<Swift.Int>) -> SDSoup.OrderedSet<Element>.SubSequence.SubSequence {
    get {
        _failEarlyRangeCheck(bounds, bounds: startIndex ..< endIndex)
        return SubSequence(_base: _base, bounds: bounds)
    }
  }
  @inlinable @inline(__always) public var isEmpty: Swift.Bool {
    get { _bounds.isEmpty }
  }
  @inlinable @inline(__always) public var count: Swift.Int {
    get { _bounds.count }
  }
  @inlinable @inline(__always) public func _customIndexOfEquatableElement(_ element: Element) -> Swift.Int?? {
        .some(_index(of: element))
    }
  @inlinable @inline(__always) public func _customLastIndexOfEquatableElement(_ element: Element) -> Swift.Int?? {
        .some(_index(of: element))
    }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
        _slice._failEarlyRangeCheck(index, bounds: bounds)
    }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.ClosedRange<Swift.Int>) {
        _slice._failEarlyRangeCheck(index, bounds: bounds)
    }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
        _slice._failEarlyRangeCheck(range, bounds: bounds)
    }
}
extension SDSoup.OrderedSet.SubSequence : Swift.Equatable {
  @inlinable public static func == (left: SDSoup.OrderedSet<Element>.SubSequence, right: SDSoup.OrderedSet<Element>.SubSequence) -> Swift.Bool {
        left.elementsEqual(right)
    }
}
extension SDSoup.OrderedSet.SubSequence : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
        hasher.combine(count)
        for item in self {
            hasher.combine(item)
        }
    }
  public var hashValue: Swift.Int {
    get
  }
}
extension SDSoup.OrderedSet {
  @frozen public struct UnorderedView {
    @usableFromInline
    internal var _base: SDSoup.OrderedSet<Element>
    @inlinable @inline(__always) internal init(_base: SDSoup.OrderedSet<Element>) {
            self._base = _base
        }
  }
  @inlinable @inline(__always) public init(_ view: SDSoup.OrderedSet<Element>.UnorderedView) {
        self = view._base
    }
  @inlinable public var unordered: SDSoup.OrderedSet<Element>.UnorderedView {
    @inline(__always) get {
            UnorderedView(_base: self)
        }
    @inline(__always) _modify {
            var view = UnorderedView(_base: self)
            self = OrderedSet()
            defer { self = view._base }
            yield &view
        }
  }
}
extension SDSoup.OrderedSet.UnorderedView : Swift.Sendable where Element : Swift.Sendable {
}
extension SDSoup.OrderedSet.UnorderedView : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SDSoup.OrderedSet.UnorderedView : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SDSoup.OrderedSet.UnorderedView : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension SDSoup.OrderedSet.UnorderedView : Swift.Equatable {
  @inlinable public static func == (left: SDSoup.OrderedSet<Element>.UnorderedView, right: SDSoup.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
        if left._base.__storage != nil,
           left._base.__storage === right._base.__storage {
            return true
        }
        guard left._base.count == right._base.count else { return false }

        for item in left._base {
            if !right._base.contains(item) { return false }
        }
        return true
    }
}
extension SDSoup.OrderedSet.UnorderedView : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
         
         
         
         
        let copy = hasher
        let seed = copy.finalize()

        var hash = 0
        for member in _base {
            hash ^= member._rawHashValue(seed: seed)
        }
        hasher.combine(hash)
    }
  public var hashValue: Swift.Int {
    get
  }
}
extension SDSoup.OrderedSet.UnorderedView : Swift.ExpressibleByArrayLiteral {
  @inlinable @inline(__always) public init(arrayLiteral elements: Element...) {
        _base = OrderedSet(elements)
    }
  public typealias ArrayLiteralElement = Element
}
extension SDSoup.OrderedSet.UnorderedView : Swift.SetAlgebra {
  public typealias Element = SDSoup.OrderedSet<Element>.Element
}
extension SDSoup.OrderedSet.UnorderedView {
  @inlinable @inline(__always) public init() {
        _base = OrderedSet()
    }
  @inlinable @inline(__always) public init<S>(_ elements: S) where Element == S.Element, S : Swift.Sequence {
        _base = OrderedSet(elements)
    }
  @inlinable @inline(__always) public init(_ elements: SDSoup.OrderedSet<Element>.UnorderedView) {
        self = elements
    }
  @inlinable @inline(__always) public init(_ elements: Swift.Set<Element>) {
        self._base = OrderedSet(elements)
    }
  @inlinable @inline(__always) public init<Value>(_ elements: Swift.Dictionary<Element, Value>.Keys) {
        self._base = OrderedSet(elements)
    }
}
extension SDSoup.OrderedSet.UnorderedView {
  @inlinable @inline(__always) public func contains(_ element: Element) -> Swift.Bool {
        _base.contains(element)
    }
}
extension SDSoup.OrderedSet.UnorderedView {
  @inlinable public mutating func insert(_ newMember: __owned Element) -> (inserted: Swift.Bool, memberAfterInsert: Element) {
        let (inserted, index) = _base.append(newMember)
        return (inserted, _base[index])
    }
  @inlinable public mutating func update(with newMember: __owned Element) -> Element? {
        let (inserted, index) = _base.append(newMember)
        if inserted { return nil }
        let old = _base._elements[index]
        _base._elements[index] = newMember
        return old
    }
}
extension SDSoup.OrderedSet.UnorderedView {
  @discardableResult
  @inlinable @inline(__always) public mutating func remove(_ member: Element) -> Element? {
        _base.remove(member)
    }
}
extension SDSoup.OrderedSet.UnorderedView {
  @inlinable @inline(__always) public mutating func formUnion(_ other: __owned SDSoup.OrderedSet<Element>.UnorderedView) {
        _base.formUnion(other._base)
    }
  @inlinable public __consuming func union(_ other: __owned SDSoup.OrderedSet<Element>.UnorderedView) -> SDSoup.OrderedSet<Element>.UnorderedView {
        _base.union(other._base).unordered
    }
  @inlinable public mutating func formUnion<S>(_ other: __owned S) where Element == S.Element, S : Swift.Sequence {
        _base.formUnion(other)
    }
  @inlinable public __consuming func union<S>(_ other: __owned S) -> SDSoup.OrderedSet<Element>.UnorderedView where Element == S.Element, S : Swift.Sequence {
        _base.union(other).unordered
    }
}
extension SDSoup.OrderedSet.UnorderedView {
  @inlinable public __consuming func intersection(_ other: SDSoup.OrderedSet<Element>.UnorderedView) -> SDSoup.OrderedSet<Element>.UnorderedView {
        _base.intersection(other._base).unordered
    }
  @inlinable public mutating func formIntersection(_ other: SDSoup.OrderedSet<Element>.UnorderedView) {
        _base.formIntersection(other._base)
    }
  @inlinable public __consuming func intersection<S>(_ other: S) -> SDSoup.OrderedSet<Element>.UnorderedView where Element == S.Element, S : Swift.Sequence {
        _base.intersection(other).unordered
    }
  @inlinable public mutating func formIntersection<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
        _base.formIntersection(other)
    }
}
extension SDSoup.OrderedSet.UnorderedView {
  @inlinable public __consuming func symmetricDifference(_ other: __owned SDSoup.OrderedSet<Element>.UnorderedView) -> SDSoup.OrderedSet<Element>.UnorderedView {
        _base.symmetricDifference(other._base).unordered
    }
  @inlinable public mutating func formSymmetricDifference(_ other: __owned SDSoup.OrderedSet<Element>.UnorderedView) {
        _base.formSymmetricDifference(other._base)
    }
  @inlinable public __consuming func symmetricDifference<S>(_ other: __owned S) -> SDSoup.OrderedSet<Element>.UnorderedView where Element == S.Element, S : Swift.Sequence {
        _base.symmetricDifference(other).unordered
    }
  @inlinable public mutating func formSymmetricDifference<S>(_ other: __owned S) where Element == S.Element, S : Swift.Sequence {
        _base.formSymmetricDifference(other)
    }
}
extension SDSoup.OrderedSet.UnorderedView {
  @inlinable public __consuming func subtracting(_ other: SDSoup.OrderedSet<Element>.UnorderedView) -> SDSoup.OrderedSet<Element>.UnorderedView {
        _base.subtracting(other._base).unordered
    }
  @inlinable public mutating func subtract(_ other: SDSoup.OrderedSet<Element>.UnorderedView) {
        _base.subtract(other._base)
    }
  @inlinable public __consuming func subtracting<S>(_ other: S) -> SDSoup.OrderedSet<Element>.UnorderedView where Element == S.Element, S : Swift.Sequence {
        _base.subtracting(other).unordered
    }
  @inlinable public mutating func subtract<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
        _base.subtract(other)
    }
}
extension SDSoup.OrderedSet.UnorderedView {
  @inlinable public func isSubset(of other: SDSoup.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
        _base.isSubset(of: other._base)
    }
  @inlinable public func isSubset(of other: Swift.Set<Element>) -> Swift.Bool {
        _base.isSubset(of: other)
    }
  @inlinable public func isSubset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
        _base.isSubset(of: other)
    }
}
extension SDSoup.OrderedSet.UnorderedView {
  @inlinable public func isSuperset(of other: SDSoup.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
        _base.isSuperset(of: other._base)
    }
  @inlinable public func isSuperset(of other: Swift.Set<Element>) -> Swift.Bool {
        _base.isSuperset(of: other)
    }
  @inlinable public func isSuperset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
        _base.isSuperset(of: other)
    }
}
extension SDSoup.OrderedSet.UnorderedView {
  @inlinable public func isStrictSubset(of other: SDSoup.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
        _base.isStrictSubset(of: other._base)
    }
  @inlinable public func isStrictSubset(of other: Swift.Set<Element>) -> Swift.Bool {
        _base.isStrictSubset(of: other)
    }
  @inlinable public func isStrictSubset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
        _base.isStrictSubset(of: other)
    }
}
extension SDSoup.OrderedSet.UnorderedView {
  @inlinable public func isStrictSuperset(of other: SDSoup.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
        _base.isStrictSuperset(of: other._base)
    }
  @inlinable public func isStrictSuperset(of other: Swift.Set<Element>) -> Swift.Bool {
        _base.isStrictSuperset(of: other)
    }
  @inlinable public func isStrictSuperset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
        _base.isStrictSuperset(of: other)
    }
}
extension SDSoup.OrderedSet.UnorderedView {
  @inlinable public func isDisjoint(with other: SDSoup.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
        _base.isDisjoint(with: other._base)
    }
  @inlinable public func isDisjoint(with other: Swift.Set<Element>) -> Swift.Bool {
        _base.isDisjoint(with: other)
    }
  @inlinable public func isDisjoint<S>(with other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
        _base.isDisjoint(with: other)
    }
}
extension SDSoup.OrderedSet {
  @frozen public struct _UnstableInternals {
    @usableFromInline
    internal typealias _Bucket = SDSoup._HashTable.Bucket
    @usableFromInline
    internal var base: SDSoup.OrderedSet<Element>
    @inlinable internal init(_ base: SDSoup.OrderedSet<Element>) {
            self.base = base
        }
  }
  @inlinable public var __unstable: SDSoup.OrderedSet<Element>._UnstableInternals {
    @inline(__always) get {
            _UnstableInternals(self)
        }
    @inline(__always) _modify {
            var view = _UnstableInternals(self)
            self = OrderedSet()
            defer { self = view.base }
            yield &view
        }
  }
}
extension SDSoup.OrderedSet._UnstableInternals : Swift.Sendable where Element : Swift.Sendable {
}
@frozen public struct OrderedSet<Element> where Element : Swift.Hashable {
  @usableFromInline
  internal typealias _Bucket = SDSoup._HashTable.Bucket
  @usableFromInline
  internal var __storage: SDSoup._HashTable.Storage?
  @usableFromInline
  internal var _elements: Swift.ContiguousArray<Element>
  @inlinable internal init(_uniqueElements: Swift.ContiguousArray<Element>, _ table: SDSoup._HashTable?) {
        self.__storage = table?._storage
        self._elements = _uniqueElements
    }
  @inlinable @inline(__always) internal var _table: SDSoup._HashTable? {
    get { __storage.map { _HashTable($0) } }
    set { __storage = newValue?._storage }
  }
}
extension SDSoup.OrderedSet {
  @inlinable public var elements: [Element] {
    get {
            Array(_elements)
        }
    set {
            self = .init(newValue)
        }
    @inline(__always) _modify {
            var members = Array(_elements)
            _elements = []
            defer { self = .init(members) }
            yield &members
        }
  }
}
extension SDSoup.OrderedSet {
  @inlinable internal var _capacity: Swift.Int {
    get {
        _table?.capacity ?? _HashTable.maximumUnhashedCount
    }
  }
  @inlinable internal var _minimumCapacity: Swift.Int {
    get {
        if _scale == _reservedScale { return 0 }
        return _HashTable.minimumCapacity(forScale: _scale)
    }
  }
  @inlinable internal var _scale: Swift.Int {
    get {
        _table?.scale ?? 0
    }
  }
  @inlinable internal var _reservedScale: Swift.Int {
    get {
        _table?.reservedScale ?? 0
    }
  }
  @inlinable internal var _bias: Swift.Int {
    get {
        _table?.bias ?? 0
    }
  }
}
extension SDSoup.OrderedSet {
  @inlinable internal mutating func _regenerateHashTable(scale: Swift.Int, reservedScale: Swift.Int) {
        assert(_HashTable.maximumCapacity(forScale: scale) >= _elements.count)
        assert(reservedScale == 0 || reservedScale >= _HashTable.minimumScale)
        _table = _HashTable.create(
            uncheckedUniqueElements: _elements,
            scale: Swift.max(scale, reservedScale),
            reservedScale: reservedScale
        )
    }
  @inlinable internal mutating func _regenerateHashTable() {
        let reservedScale = _reservedScale
        guard
            _elements.count > _HashTable.maximumUnhashedCount || reservedScale != 0
        else {
             
            _table = nil
            return
        }
        let scale = _HashTable.scale(forCapacity: _elements.count)
        _regenerateHashTable(scale: scale, reservedScale: reservedScale)
    }
  @inlinable internal mutating func _regenerateExistingHashTable() {
        assert(_capacity >= _elements.count)
        guard _table != nil else {
            return
        }
        _ensureUnique()
        _table!.update { hashTable in
            hashTable.clear()
            hashTable.fill(uncheckedUniqueElements: _elements)
        }
    }
}
extension SDSoup.OrderedSet {
  @inlinable @inline(__always) internal mutating func _isUnique() -> Swift.Bool {
        isKnownUniquelyReferenced(&__storage)
    }
  @inlinable internal mutating func _ensureUnique() {
        if __storage == nil { return }
        if isKnownUniquelyReferenced(&__storage) { return }
        _table = _table!.copy()
    }
}
extension SDSoup.OrderedSet {
  @inlinable internal func _find(_ item: Element) -> (index: Swift.Int?, bucket: SDSoup.OrderedSet<Element>._Bucket) {
        _find_inlined(item)
    }
  @inlinable @inline(__always) internal func _find_inlined(_ item: Element) -> (index: Swift.Int?, bucket: SDSoup.OrderedSet<Element>._Bucket) {
        _elements.withUnsafeBufferPointer { elements in
            guard let table = _table else {
                return (elements.firstIndex(of: item), _Bucket(offset: 0))
            }
            return table.read { hashTable in
                hashTable._find(item, in: elements)
            }
        }
    }
  @inlinable internal func _bucket(for index: Swift.Int) -> SDSoup.OrderedSet<Element>._Bucket {
        guard let table = _table else { return _Bucket(offset: 0) }
        return table.read { hashTable in
            var it = hashTable.bucketIterator(for: _elements[index])
            it.advance(until: index)
            precondition(it.isOccupied, S("Corrupt hash table"))
            return it.currentBucket
        }
    }
  @inlinable @inline(__always) public func firstIndex(of element: Element) -> Swift.Int? {
        _find(element).index
    }
  @inlinable @inline(__always) public func lastIndex(of element: Element) -> Swift.Int? {
        _find(element).index
    }
}
extension SDSoup.OrderedSet {
  @inlinable @inline(never) internal __consuming func _extractSubset(using bitset: SDSoup._UnsafeBitset, extraCapacity: Swift.Int = 0) -> SDSoup.OrderedSet<Element> {
        assert(bitset.isEmpty || bitset.max()! <= count)
        if bitset.isEmpty { return Self(minimumCapacity: extraCapacity) }
        if bitset.count == self.count {
            if extraCapacity <= self._capacity - self.count {
                return self
            }
            var copy = self
            copy.reserveCapacity(count + extraCapacity)
            return copy
        }
        var result = Self(minimumCapacity: bitset.count + extraCapacity)
        for offset in bitset {
            result._appendNew(_elements[offset])
        }
        assert(result.count == bitset.count)
        return result
    }
}
extension SDSoup.OrderedSet {
  @discardableResult
  @inlinable internal mutating func _removeExistingMember(at index: Swift.Int, in bucket: SDSoup.OrderedSet<Element>._Bucket) -> Element {
        guard _elements.count - 1 >= _minimumCapacity else {
            let old = _elements.remove(at: index)
            _regenerateHashTable()
            return old
        }
        guard _table != nil else {
            return _elements.remove(at: index)
        }

        defer { _checkInvariants() }
        _ensureUnique()
        _table!.update { hashTable in
             
            hashTable.delete(
                bucket: bucket,
                hashValueGenerator: { offset, seed in
                    _elements[offset]._rawHashValue(seed: seed)
                }
            )
            hashTable.adjustContents(preparingForRemovalOf: index, in: _elements)
        }
        return _elements.remove(at: index)
    }
}
extension SDSoup.OrderedSet {
  @inlinable public func filter(_ isIncluded: (Element) throws -> Swift.Bool) rethrows -> SDSoup.OrderedSet<Element> {
        try _UnsafeBitset.withTemporaryBitset(capacity: self.count) { bitset in
            for i in _elements.indices where try isIncluded(_elements[i]) {
                bitset.insert(i)
            }
            let result = self._extractSubset(using: bitset)
            result._checkInvariants()
            return result
        }
    }
}
public protocol PHImageManagerTwin {
  @discardableResult
  func requestImage(for asset: Photos.PHAsset, targetSize: CoreFoundation.CGSize, contentMode: Photos.PHImageContentMode, options: Photos.PHImageRequestOptions?, resultHandler: @escaping (UIKit.UIImage?, [Swift.AnyHashable : Any]?) -> Swift.Void) -> Photos.PHImageRequestID
  @discardableResult
  func requestAVAsset(forVideo asset: Photos.PHAsset, options: Photos.PHVideoRequestOptions?, resultHandler: @escaping (AVFoundation.AVAsset?, AVFoundation.AVAudioMix?, [Swift.AnyHashable : Any]?) -> Swift.Void) -> Photos.PHImageRequestID
  @discardableResult
  func requestImageData(for asset: Photos.PHAsset, options: Photos.PHImageRequestOptions?, resultHandler: @escaping (Foundation.Data?, Swift.String?, UIKit.UIImage.Orientation, [Swift.AnyHashable : Any]?) -> Swift.Void) -> Photos.PHImageRequestID
  func cancelImageRequest(_ requestID: Photos.PHImageRequestID)
}
extension Photos.PHImageManager : SDSoup.PHImageManagerTwin {
}
public protocol Pausable : AnyObject {
  func pause()
  func resume()
}
extension SDSoup.Proxy : SDSoup.Pausable where Subject : SDSoup.Pausable {
  public func pause()
  public func resume()
}
public protocol PermissionProvider {
  var permissionType: SDSoup.PermissionType { get }
  var permissionStatus: SDSoup.PermissionStatus { get }
  var permissionDidChange: Combine.AnyPublisher<Swift.Void, Swift.Never> { get }
  func requestPermission(completionHandler: @escaping (SDSoup.PermissionStatus) -> Swift.Void)
}
extension SDSoup.PermissionProvider {
  public var permissionDidChange: Combine.AnyPublisher<Swift.Void, Swift.Never> {
    get
  }
  @inlinable public func requestPermissionAndForget() {
        requestPermission(completionHandler: { _ in })
    }
  @discardableResult
  @inlinable public func requestPermission() async -> SDSoup.PermissionStatus {
        await withCheckedContinuation { continuation in
            requestPermission { status in
                continuation.resume(returning: status)
            }
        }
    }
}
public enum PermissionStatus : Swift.Sendable {
  case allowed
  case denied
  case disabled
  case notDetermined
  public var value: Swift.String {
    get
  }
  public static func == (a: SDSoup.PermissionStatus, b: SDSoup.PermissionStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SDSoup.PermissionStatus {
  public var isDisabled: Swift.Bool {
    get
  }
  public var isAllowed: Swift.Bool {
    get
  }
  public var isDetermined: Swift.Bool {
    get
  }
}
public typealias PermissionType = SDSoup.Tagged<SDSoup.PermissionTypeTag, Swift.String>
extension SDSoup.Tagged where Tag == SDSoup.PermissionTypeTag, T == Swift.String {
  public static let bluetooth: SDSoup.Tagged<SDSoup.PermissionTypeTag, Swift.String>
  public static let appTracking: SDSoup.Tagged<SDSoup.PermissionTypeTag, Swift.String>
  public static let wiFi: SDSoup.Tagged<SDSoup.PermissionTypeTag, Swift.String>
  public static let localNetwork: SDSoup.Tagged<SDSoup.PermissionTypeTag, Swift.String>
  public static let recordAudio: SDSoup.Tagged<SDSoup.PermissionTypeTag, Swift.String>
  public static let location: SDSoup.Tagged<SDSoup.PermissionTypeTag, Swift.String>
  public static let contacts: SDSoup.Tagged<SDSoup.PermissionTypeTag, Swift.String>
  public static let camera: SDSoup.Tagged<SDSoup.PermissionTypeTag, Swift.String>
  public static let gallery: SDSoup.Tagged<SDSoup.PermissionTypeTag, Swift.String>
  public static let calendar: SDSoup.Tagged<SDSoup.PermissionTypeTag, Swift.String>
  public static let userNotifications: SDSoup.Tagged<SDSoup.PermissionTypeTag, Swift.String>
  public static let reachability: SDSoup.Tagged<SDSoup.PermissionTypeTag, Swift.String>
}
public enum PermissionTypeTag {
}
public typealias PhoneCountry = SDSoup.Tagged<SDSoup.PhoneCountryTag, SDSoup.PhoneCountryType>
public enum PhoneCountryType : Swift.String {
  case ru
  case by
  case uz
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
public enum PhoneCountryTag {
}
public typealias PhoneNumber = SDSoup.Tagged<SDSoup.PhoneNumberTag, Swift.String>
public enum PhoneNumberTag {
}
public struct GradientToken : Swift.Sendable {
  public enum Kind : Swift.Equatable, Swift.Sendable {
    case linear
    case radial
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SDSoup.GradientToken.Kind, b: SDSoup.GradientToken.Kind) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public let type: SDSoup.GradientToken.Kind
  public let colors: [SDSoup.PlasmaColorToken]
  public let locations: [CoreFoundation.CGFloat]
  public let startPoint: CoreFoundation.CGPoint
  public let endPoint: CoreFoundation.CGPoint
  public init(type: SDSoup.GradientToken.Kind, colors: [SDSoup.PlasmaColorToken], locations: [CoreFoundation.CGFloat], startPoint: CoreFoundation.CGPoint, endPoint: CoreFoundation.CGPoint)
}
public struct ComplexGradientToken : Swift.Sendable {
  public let gradients: [SDSoup.GradientToken]
  public let backgroundColor: SDSoup.PlasmaColorToken
}
public enum PlasmaColorScheme : Swift.Sendable {
  case light
  case dark
  public static func == (a: SDSoup.PlasmaColorScheme, b: SDSoup.PlasmaColorScheme) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct PlasmaColorToken : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public let light: UIKit.UIColor
  public let dark: UIKit.UIColor
  public init(light: UIKit.UIColor, dark: UIKit.UIColor)
  public func color(_ scheme: SDSoup.PlasmaColorScheme) -> UIKit.UIColor
  public static let onDarkOverlaySoft: SDSoup.PlasmaColorToken
  public static let onDarkOverlayHard: SDSoup.PlasmaColorToken
  public static let onDarkOverlayBlur: SDSoup.PlasmaColorToken
  public static let textPrimary: SDSoup.PlasmaColorToken
  public static let textSecondary: SDSoup.PlasmaColorToken
  public static let textTertiary: SDSoup.PlasmaColorToken
  public static let textParagraph: SDSoup.PlasmaColorToken
  public static let textPositive: SDSoup.PlasmaColorToken
  public static let textWarning: SDSoup.PlasmaColorToken
  public static let textNegative: SDSoup.PlasmaColorToken
  public static let textAccentAthena: SDSoup.PlasmaColorToken
  public static let textAccentJoy: SDSoup.PlasmaColorToken
  public static let textAccentB2E: SDSoup.PlasmaColorToken
  public static let textAccentBrand: SDSoup.PlasmaColorToken
  public static let textAccentMain: SDSoup.PlasmaColorToken
  public static let onDarkTextPrimary: SDSoup.PlasmaColorToken
  public static let onDarkTextSecondary: SDSoup.PlasmaColorToken
  public static let onDarkTextTertiary: SDSoup.PlasmaColorToken
  public static let onDarkTextParagraph: SDSoup.PlasmaColorToken
  public static let onDarkTextPositive: SDSoup.PlasmaColorToken
  public static let onDarkTextWarning: SDSoup.PlasmaColorToken
  public static let onDarkTextNegative: SDSoup.PlasmaColorToken
  public static let onDarkTextAccentAthena: SDSoup.PlasmaColorToken
  public static let onDarkTextAccentJoy: SDSoup.PlasmaColorToken
  public static let onDarkTextAccentB2E: SDSoup.PlasmaColorToken
  public static let onDarkTextAccentBrand: SDSoup.PlasmaColorToken
  public static let onDarkTextAccentMain: SDSoup.PlasmaColorToken
  public static let onLightTextPrimary: SDSoup.PlasmaColorToken
  public static let onLightTextSecondary: SDSoup.PlasmaColorToken
  public static let onLightTextTertiary: SDSoup.PlasmaColorToken
  public static let onLightTextParagraph: SDSoup.PlasmaColorToken
  public static let onLightTextPositive: SDSoup.PlasmaColorToken
  public static let onLightTextWarning: SDSoup.PlasmaColorToken
  public static let onLightTextNegative: SDSoup.PlasmaColorToken
  public static let onLightTextAccentAthena: SDSoup.PlasmaColorToken
  public static let onLightTextAccentJoy: SDSoup.PlasmaColorToken
  public static let onLightTextAccentB2E: SDSoup.PlasmaColorToken
  public static let onLightTextAccentBrand: SDSoup.PlasmaColorToken
  public static let onLightTextAccentMain: SDSoup.PlasmaColorToken
  public static let inverseTextPrimary: SDSoup.PlasmaColorToken
  public static let inverseTextSecondary: SDSoup.PlasmaColorToken
  public static let inverseTextTertiary: SDSoup.PlasmaColorToken
  public static let inverseTextParagraph: SDSoup.PlasmaColorToken
  public static let surfaceSolidDefault: SDSoup.PlasmaColorToken
  public static let surfaceSolidPrimary: SDSoup.PlasmaColorToken
  public static let surfaceSolidSecondary: SDSoup.PlasmaColorToken
  public static let surfaceSolidTertiary: SDSoup.PlasmaColorToken
  public static let surfaceSolidCard: SDSoup.PlasmaColorToken
  public static let surfaceTransparentPrimary: SDSoup.PlasmaColorToken
  public static let surfaceTransparentSecondary: SDSoup.PlasmaColorToken
  public static let surfaceTransparentTertiary: SDSoup.PlasmaColorToken
  public static let surfaceTransparentCard: SDSoup.PlasmaColorToken
  public static let surfacePositive: SDSoup.PlasmaColorToken
  public static let surfaceWarning: SDSoup.PlasmaColorToken
  public static let surfaceNegative: SDSoup.PlasmaColorToken
  public static let surfaceClear: SDSoup.PlasmaColorToken
  public static let surfaceAccentAthena: SDSoup.PlasmaColorToken
  public static let surfaceAccentJoy: SDSoup.PlasmaColorToken
  public static let surfaceAccentB2E: SDSoup.PlasmaColorToken
  public static let surfaceAccentBrand: SDSoup.PlasmaColorToken
  public static let surfaceSpeechBubbleSent: SDSoup.PlasmaColorToken
  public static let surfaceSpeechBubbleReceived: SDSoup.PlasmaColorToken
  public static let surfaceAccentMain: SDSoup.PlasmaColorToken
  public static let onDarkSurfaceSolidDefault: SDSoup.PlasmaColorToken
  public static let onDarkSurfaceSolidPrimary: SDSoup.PlasmaColorToken
  public static let onDarkSurfaceSolidSecondary: SDSoup.PlasmaColorToken
  public static let onDarkSurfaceSolidTertiary: SDSoup.PlasmaColorToken
  public static let onDarkSurfaceSolidCard: SDSoup.PlasmaColorToken
  public static let onDarkSurfaceTransparentPrimary: SDSoup.PlasmaColorToken
  public static let onDarkSurfaceTransparentSecondary: SDSoup.PlasmaColorToken
  public static let onDarkSurfaceTransparentTertiary: SDSoup.PlasmaColorToken
  public static let onDarkSurfaceTransparentCard: SDSoup.PlasmaColorToken
  public static let onDarkSurfacePositive: SDSoup.PlasmaColorToken
  public static let onDarkSurfaceWarning: SDSoup.PlasmaColorToken
  public static let onDarkSurfaceNegative: SDSoup.PlasmaColorToken
  public static let onDarkSurfaceAccentAthena: SDSoup.PlasmaColorToken
  public static let onDarkSurfaceAccentJoy: SDSoup.PlasmaColorToken
  public static let onDarkSurfaceAccentB2E: SDSoup.PlasmaColorToken
  public static let onDarkSurfaceAccentBrand: SDSoup.PlasmaColorToken
  public static let onDarkSurfaceAccentMain: SDSoup.PlasmaColorToken
  public static let onLightSurfaceSolidDefault: SDSoup.PlasmaColorToken
  public static let onLightSurfaceSolidPrimary: SDSoup.PlasmaColorToken
  public static let onLightSurfaceSolidSecondary: SDSoup.PlasmaColorToken
  public static let onLightSurfaceSolidTertiary: SDSoup.PlasmaColorToken
  public static let onLightSurfaceSolidCard: SDSoup.PlasmaColorToken
  public static let onLightSurfaceTransparentPrimary: SDSoup.PlasmaColorToken
  public static let onLightSurfaceTransparentSecondary: SDSoup.PlasmaColorToken
  public static let onLightSurfaceTransparentTertiary: SDSoup.PlasmaColorToken
  public static let onLightSurfaceTransparentCard: SDSoup.PlasmaColorToken
  public static let onLightSurfacePositive: SDSoup.PlasmaColorToken
  public static let onLightSurfaceWarning: SDSoup.PlasmaColorToken
  public static let onLightSurfaceNegative: SDSoup.PlasmaColorToken
  public static let onLightSurfaceAccentAthena: SDSoup.PlasmaColorToken
  public static let onLightSurfaceAccentJoy: SDSoup.PlasmaColorToken
  public static let onLightSurfaceAccentB2E: SDSoup.PlasmaColorToken
  public static let onLightSurfaceAccentBrand: SDSoup.PlasmaColorToken
  public static let onLightSurfaceTransparentDeep: SDSoup.PlasmaColorToken
  public static let onLightSurfaceAccentMain: SDSoup.PlasmaColorToken
  public static let backgroundPrimary: SDSoup.PlasmaColorToken
  public static let onDarkBackgroundPrimary: SDSoup.PlasmaColorToken
  public static let backgroundSecondary: SDSoup.PlasmaColorToken
  public static let backgroundTertiary: SDSoup.PlasmaColorToken
  public static let adaptiveCold: SDSoup.PlasmaColorToken
  public static let adaptiveNeutral: SDSoup.PlasmaColorToken
  public static let adaptiveWarm: SDSoup.PlasmaColorToken
  public enum PlasmaGradient {
    public static let textGradientAthena: SDSoup.GradientToken
    public static let textGradientJoy: SDSoup.GradientToken
    public static let textGradientB2E: SDSoup.GradientToken
    public static let textGradientBrand: SDSoup.GradientToken
    public static let textGradientMain: SDSoup.GradientToken
    public static let onDarkTextGradientAthena: SDSoup.GradientToken
    public static let onDarkTextGradientJoy: SDSoup.GradientToken
    public static let onDarkTextGradientB2E: SDSoup.GradientToken
    public static let onDarkTextGradientBrand: SDSoup.GradientToken
    public static let onDarkTextGradientMain: SDSoup.GradientToken
    public static let onLightTextGradientAthena: SDSoup.GradientToken
    public static let onLightTextGradientJoy: SDSoup.GradientToken
    public static let onLightTextGradientB2E: SDSoup.GradientToken
    public static let onLightTextGradientBrand: SDSoup.GradientToken
    public static let onLightTextGradientMain: SDSoup.GradientToken
    public static let surfaceSkeleton: SDSoup.GradientToken
    public static let surfaceGradientMain: SDSoup.GradientToken
    public static let onDarkSurfaceGradientMain: SDSoup.GradientToken
    public static let onLightSurfaceGradientMain: SDSoup.GradientToken
    public static let backgroundModalSheet: SDSoup.ComplexGradientToken
    public static let backgroundMobileAssistantAthena: SDSoup.ComplexGradientToken
    public static let backgroundMobileAssistantJoy: SDSoup.ComplexGradientToken
    public static let backgroundMobileAssistantB2E: SDSoup.ComplexGradientToken
    public static let backgroundMobileAssistantBrand: SDSoup.ComplexGradientToken
    public static let backgroundMobileAssistantMain: SDSoup.ComplexGradientToken
  }
  public static func == (a: SDSoup.PlasmaColorToken, b: SDSoup.PlasmaColorToken) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SDSoup.GradientToken : Swift.Hashable, Swift.Equatable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SDSoup.GradientToken, b: SDSoup.GradientToken) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct PlatformAssertionCaller : SDSoup.AssertionCaller {
  public init()
  public func assert(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt)
  public func fatalError(_ message: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt) -> Swift.Never
  public func assertionFailure(_ message: @autoclosure () -> Swift.String, file: Swift.StaticString, line: Swift.UInt)
}
final public class Plist {
  public init(bundle: Foundation.Bundle, assertionCaller: any SDSoup.AssertionCaller)
  final public func value<T>(for key: Swift.String, type _: T.Type = T.self) -> Swift.Result<T, SDSoup.Plist.Error> where T : Swift.LosslessStringConvertible
  final public func value<T>(for key: Swift.String) -> Swift.Result<T, SDSoup.Plist.Error> where T : Swift.LosslessStringConvertible
  @objc deinit
}
extension SDSoup.Plist {
  public enum Error : Swift.Error, Foundation.LocalizedError {
    case missingKey
    case invalidValue
    public var errorDescription: Swift.String? {
      get
    }
    public static func == (a: SDSoup.Plist.Error, b: SDSoup.Plist.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public enum Pretty {
  public static func string(_ value: Any?) -> Swift.String
  public static func json(_ value: Any?) -> any Swift.Sendable
  public static func convert(_ value: Any?) -> SDSoup.PrettyElement
}
public protocol PrettyConvertible {
  var prettyElement: SDSoup.PrettyElement { get }
}
public protocol PrettyUnconvertible : SDSoup.PrettyConvertible {
}
public protocol PrettyRawConvertible : SDSoup.PrettyConvertible {
}
extension SDSoup.PrettyUnconvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        let string = String(describing: type(of: self))
        return .string(string)
    }
  }
}
extension SDSoup.PrettyRawConvertible where Self : Swift.RawRepresentable, Self.RawValue : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        rawValue.prettyElement
    }
  }
}
indirect public enum PrettyElement : Swift.Sendable, Swift.Hashable {
  case bool(Swift.Bool)
  case double(Swift.Double)
  case int(Swift.Int)
  case uInt(Swift.UInt)
  case string(Swift.String)
  case null
  case collection([SDSoup.PrettyElement])
  case dictionary([SDSoup.PrettyElement : SDSoup.PrettyElement])
  case complex(SDSoup.PrettyElement, name: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SDSoup.PrettyElement, b: SDSoup.PrettyElement) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension SDSoup.PrettyElement {
  public func less(_ rhs: SDSoup.PrettyElement) -> Swift.Bool
}
public protocol PrettyError : Swift.Error {
  var errorName: Swift.String { get }
  var errorDomain: Swift.String { get }
  var errorCode: Swift.Int { get }
  var errorUserInfo: [Swift.String : any Swift.Sendable] { get }
}
extension SDSoup.PrettyError {
  public var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : any Swift.Sendable] {
    get
  }
}
extension SDSoup.PrettyError where Self : Swift.Identifiable {
  public var errorName: Swift.String {
    get
  }
}
extension SDSoup.PrettyError where Self : Swift.Identifiable, Self.ID : Swift.CaseIterable, Self.ID.AllCases.Index == Swift.Int {
  public var errorCode: Swift.Int {
    get
  }
}
extension Swift.Int {
  public static let noPrettyErrorCode: Swift.Int
}
extension Swift.Error {
  public var prettyNSError: Foundation.NSError {
    get
  }
  public var prettyErrorDomain: Swift.String {
    get
  }
  public var prettyErrorCode: Swift.Int {
    get
  }
}
extension SDSoup.Pretty {
  @inlinable public static func errorName<T>(_ errorType: T) -> Swift.String where T : Swift.RawRepresentable {
        String(describing: errorType)
    }
  public static func errorUserInfo(_ error: (any Swift.Error)? = nil, from userInfo: [Swift.String : Any]...) -> [Swift.String : Any]
}
extension Swift.Bool : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        .bool(self)
    }
  }
}
extension Swift.String : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        .string(self)
    }
  }
}
extension Swift.Double : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        .double(self)
    }
  }
}
extension Swift.Int : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        .int(self)
    }
  }
}
extension Swift.UInt : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        .uInt(self)
    }
  }
}
extension Foundation.NSNull : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        .null
    }
  }
}
extension Swift.Array : SDSoup.PrettyConvertible where Element : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        .collection(map(\.prettyElement))
    }
  }
}
extension Swift.Set : SDSoup.PrettyConvertible where Element : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        .collection(
            self
                .map(\.prettyElement)
                .sorted { $0.less($1) }
        )
    }
  }
}
extension Swift.Dictionary : SDSoup.PrettyConvertible where Key : SDSoup.PrettyConvertible, Value : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        .dictionary(
            self
                .mapKeys(\.prettyElement)
                .mapValues(\.prettyElement)
        )
    }
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional : SDSoup.PrettyConvertible where Wrapped : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        switch self {
        case .none: .null
        case let .some(wrapped): wrapped.prettyElement
        }
    }
  }
}
#else
extension Swift.Optional : SDSoup.PrettyConvertible where Wrapped : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        switch self {
        case .none: .null
        case let .some(wrapped): wrapped.prettyElement
        }
    }
  }
}
#endif
public var isRunningTests: Swift.Bool {
  get
}
@propertyWrapper @dynamicMemberLookup public struct Property<Value> : SDSoup.PropertyType {
  @usableFromInline
  internal let getter: () -> Value
  @inlinable public var value: Value {
    get { getter() }
  }
  public let signal: Combine.AnyPublisher<Swift.Void, Swift.Never>
  @inlinable public var wrappedValue: Value {
    get { value }
  }
  @inlinable public var projectedValue: SDSoup.Property<Value> {
    get { self }
  }
  public init(signal: Combine.AnyPublisher<Swift.Void, Swift.Never> = Empty().eraseToAnyPublisher(), getter: @escaping () -> Value)
  @inlinable public subscript<T>(dynamicMember keyPath: Swift.KeyPath<Value, T>) -> SDSoup.Property<T> {
    get {
        map { $0[keyPath: keyPath] }
    }
  }
  @available(*, deprecated, message: "Используйте init(signal:getter:)")
  public init(getter: @escaping () -> Value, signal: Combine.AnyPublisher<Value, Swift.Never>)
}
extension SDSoup.Property {
  @inlinable public static func constant(_ constant: Value) -> SDSoup.Property<Value> {
        Property { constant }
    }
  @available(*, deprecated, message: "Используйте .constant")
  @inlinable public init(_ constant: Value) {
        self.init { constant }
    }
}
extension SDSoup.Property {
  @inlinable public func map<Output>(using transform: @escaping (Value) -> Output) -> SDSoup.Property<Output> {
        Property<Output>(signal: signal) { [getter] in
            transform(getter())
        }
    }
  @available(*, deprecated, message: "Используйте @dynamicMemberLookup")
  @inlinable public func map<Output>(_ keyPath: Swift.KeyPath<Value, Output>) -> SDSoup.Property<Output> {
        map { $0[keyPath: keyPath] }
    }
  public func flatMap<Wrapped, Output>(using transform: @escaping (Wrapped) -> Output) -> SDSoup.Property<Output?> where Value == Wrapped?
  @inlinable public func flatMap<Wrapped, Output>(_ keyPath: Swift.KeyPath<Wrapped, Output>) -> SDSoup.Property<Output?> where Value == Wrapped? {
        flatMap { $0[keyPath: keyPath] }
    }
}
extension SDSoup.Property : Swift.Equatable where Value : Swift.Equatable {
  @inlinable public static func == (lhs: SDSoup.Property<Value>, rhs: SDSoup.Property<Value>) -> Swift.Bool {
        lhs.value == rhs.value
    }
}
extension SDSoup.Property where Value : Swift.Collection {
  public func mapElements<OutputElement>(using transform: @escaping (Value.Element) -> OutputElement) -> SDSoup.Property<[OutputElement]>
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol PropertyType<Value> : SDSoup.PrettyConvertible {
  associatedtype Value
  var signal: Combine.AnyPublisher<Swift.Void, Swift.Never> { get }
  var value: Self.Value { get }
}
#else
public protocol PropertyType : SDSoup.PrettyConvertible {
  associatedtype Value
  var signal: Combine.AnyPublisher<Swift.Void, Swift.Never> { get }
  var value: Self.Value { get }
}
#endif
extension SDSoup.PropertyType {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        Pretty.convert(value)
    }
  }
  @inlinable public var next: Combine.AnyPublisher<Self.Value, Swift.Never> {
    get {
        signal
            .map { value }
            .eraseToAnyPublisher()
    }
  }
  @inlinable public var immediate: Combine.AnyPublisher<Self.Value, Swift.Never> {
    get {
        PropertyImmediatePublisher(self).eraseToAnyPublisher()
    }
  }
  @available(*, deprecated, message: "Используйте sink")
  @inlinable public func subscribe(_ block: @escaping (Self.Value) -> Swift.Void) -> Combine.AnyCancellable {
        next.sink(receiveValue: block)
    }
  @inlinable public func sink(receiveValue: @escaping (Self.Value) -> Swift.Void) -> Combine.AnyCancellable {
        next.sink(receiveValue: receiveValue)
    }
  public func sink(receiveValue: @escaping (Self.Value, Self.Value) -> Swift.Void) -> Combine.AnyCancellable
  @inlinable public func sinkToImmediate(receiveValue: @escaping (Self.Value) -> Swift.Void) -> Combine.AnyCancellable {
        immediate.sink(receiveValue: receiveValue)
    }
  @inlinable public func sink(immediately: Swift.Bool, receiveValue: @escaping (Self.Value) -> Swift.Void) -> Combine.AnyCancellable {
        if immediately {
            immediate.sink(receiveValue: receiveValue)
        } else {
            next.sink(receiveValue: receiveValue)
        }
    }
}
public struct PropertyImmediatePublisher<P> : Combine.Publisher where P : SDSoup.PropertyType {
  public typealias Output = P.Value
  public typealias Failure = Swift.Never
  public let subject: P
  public init(_ subject: P)
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, P.Value == S.Input, S.Failure == Swift.Never
}
public class Proxy<Subject> : SDSoup.NamedType {
  public var subject: Subject? {
    get
  }
  public init(label: Swift.String = #fileID, assertionCaller: any SDSoup.AssertionCaller)
  public func register(_: Subject)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class WeakProxy<Subject> : SDSoup.Proxy<Subject> where Subject : AnyObject {
  override final public var subject: Subject? {
    get
  }
  override final public func register(_ subject: Subject)
  override public init(label: Swift.String = #fileID, assertionCaller: any SDSoup.AssertionCaller)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class StrongProxy<Subject> : SDSoup.Proxy<Subject> {
  override final public var subject: Subject? {
    get
  }
  override final public func register(_ subject: Subject)
  override public init(label: Swift.String = #fileID, assertionCaller: any SDSoup.AssertionCaller)
  @objc deinit
}
extension SDSoup.Proxy : @unchecked Swift.Sendable where Subject : Swift.Sendable {
}
extension SDSoup.WeakProxy : @unchecked Swift.Sendable where Subject : Swift.Sendable {
}
extension SDSoup.StrongProxy : @unchecked Swift.Sendable where Subject : Swift.Sendable {
}
public struct Queue<T> {
  public var isEmpty: Swift.Bool {
    get
  }
  public var count: Swift.Int {
    get
  }
  public init(_ list: [T] = [])
  public mutating func enqueue(_ element: T)
  @discardableResult
  public mutating func dequeue() -> T?
  public mutating func peek() -> T?
  public mutating func clean()
}
extension SDSoup.Queue : Swift.Sendable where T : Swift.Sendable {
}
public enum R {
  public static let sbr: Swift.String
  public static let sbrCamelCase: Swift.String
  public static let sbl: Swift.String
  public static let pay: Swift.String
  public static let org: Swift.String
  public static let cast: Swift.String
  public static let devices: Swift.String
  public static let devicesCamelCase: Swift.String
  public static let greenDomain: Swift.String
  public static let phoneNumber: Swift.String
  public static let slt: Swift.String
  public static let sbNotification: Swift.String
}
extension Swift.RandomAccessCollection {
  @_alwaysEmitIntoClient @inline(__always) public func _index(at offset: Swift.Int) -> Self.Index {
        index(startIndex, offsetBy: offset)
    }
  @_alwaysEmitIntoClient @inline(__always) public func _offset(of index: Self.Index) -> Swift.Int {
        distance(from: startIndex, to: index)
    }
  @_alwaysEmitIntoClient @inline(__always) public subscript(_offset offset: Swift.Int) -> Self.Element {
    get {
        self[_index(at: offset)]
    }
  }
}
public typealias RefreshToken = SDSoup.Tagged<SDSoup.RefreshTokenTag, Swift.String>
public enum RefreshTokenTag {
}
public struct Regex {
  public enum CharacterSet : Swift.String, Swift.CaseIterable {
    case latin
    case cyrillic
    case digits
    case spaces
    case special
    public var rawValue: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias AllCases = [SDSoup.Regex.CharacterSet]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [SDSoup.Regex.CharacterSet] {
      get
    }
  }
  public let value: Swift.String
  public init(value: Swift.String)
}
extension SDSoup.Regex {
  public static func build(_ components: [SDSoup.Regex.CharacterSet], lengthLimit: Swift.ClosedRange<Swift.Int>? = nil) -> SDSoup.Regex
}
@propertyWrapper final public class ResettableLazy<Item> {
  final public var wrappedValue: Item {
    get
  }
  public init(_ initializer: @escaping () -> Item)
  final public func clear()
  @objc deinit
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Result {
  public var isSuccess: Swift.Bool {
    get
  }
  public var isFailure: Swift.Bool {
    get
  }
  public var success: Success? {
    get
  }
  public var error: Failure? {
    get
  }
}
#else
extension Swift.Result {
  public var isSuccess: Swift.Bool {
    get
  }
  public var isFailure: Swift.Bool {
    get
  }
  public var success: Success? {
    get
  }
  public var error: Failure? {
    get
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Result where Success == () {
  public static var success: Swift.Result<(), Failure> {
    get
  }
}
#else
extension Swift.Result where Success == () {
  public static var success: Swift.Result<(), Failure> {
    get
  }
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Result {
  #if compiler(>=5.3) && $TypedThrows
  public init(catchingAsync body: () async throws(Failure) -> Success) async
  #endif
}
#else
extension Swift.Result {
  #if compiler(>=5.3) && $TypedThrows
  public init(catchingAsync body: () async throws(Failure) -> Success) async
  #endif
}
#endif
extension Swift.Sequence {
  @inlinable public func nonnull<T>() -> [T] where Self.Element == T? { compactMap { $0 } }
  @inlinable public func unique<T>(by block: (Self.Element) -> T) -> [Self.Element] where T : Swift.Hashable {
        var set = Set<T>()
        return filter { set.insert(block($0)).inserted }
    }
}
extension Swift.Sequence where Self.Element == Swift.Character {
  @inlinable public func toString() -> Swift.String {
        String(self)
    }
}
extension Swift.Sequence where Self.Element : Swift.Hashable {
  public func uniqued() -> [Self.Element]
}
extension Swift.Sequence {
  @inlinable public func invokeForEach(_ invoke: (Self.Element) -> () -> Swift.Void) {
        forEach { element in
            invoke(element)()
        }
    }
  @inlinable public func invokeForEach(_ keyPath: Swift.KeyPath<Self.Element, () -> Swift.Void>) {
        forEach { element in
            element[keyPath: keyPath]()
        }
    }
  @inlinable public func invokeForEach<T>(_ invoke: (Self.Element) -> (T) -> Swift.Void, value: T) {
        forEach { element in
            invoke(element)(value)
        }
    }
  @inlinable public func invokeForEach<T>(_ keyPath: Swift.KeyPath<Self.Element, (T) -> Swift.Void>, value: T) {
        forEach { element in
            element[keyPath: keyPath](value)
        }
    }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class ShakeOverlayWindow : UIKit.UIWindow {
  @_Concurrency.MainActor @preconcurrency final public func onPresentationRequest(_ presentationRequestHandler: @escaping (UIKit.UIViewController) -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency final public func onSecretActivation(_ secretActivationHandler: @escaping (UIKit.UIViewController) -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency @objc override final public func motionEnded(_ motion: UIKit.UIEvent.EventSubtype, with _: UIKit.UIEvent?)
  @available(iOS 13.0, *)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(windowScene: UIKit.UIWindowScene)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public typealias AudioFocus = SDSoup.SharedResource
public typealias AudioFocusUtilizer = SDSoup.SharedResourceUtilizer
public enum SharedResourceCaptureType {
  case inclusive
  case exclusive(priority: SDSoup.Tagged<SDSoup.SharedResourceUtilizerPriorityTag, Swift.Int>)
}
extension SDSoup.SharedResource {
  public typealias CaptureType = SDSoup.SharedResourceCaptureType
}
public enum SharedResourceNameTag {
}
extension SDSoup.SharedResource {
  public typealias Name = SDSoup.Tagged<SDSoup.SharedResourceNameTag, Swift.String>
}
public protocol SharedResource {
  var name: SDSoup.Tagged<SDSoup.SharedResourceNameTag, Swift.String> { get }
  var utilizers: [SDSoup.Tagged<SDSoup.SharedResourceUtilizerNameTag, Swift.String> : any SDSoup.SharedResourceUtilizer] { get }
  func requestAccess(for utilizer: any SDSoup.SharedResourceUtilizer) -> Swift.Bool
  func requestAccessAsynchronously(for utilizer: any SDSoup.SharedResourceUtilizer)
  func revokeAccess(for utilizer: any SDSoup.SharedResourceUtilizer)
}
final public class SharedResourceImpl : SDSoup.AudioFocus {
  final public let name: SDSoup.SharedResourceImpl.Name
  final public var utilizers: [SDSoup.Tagged<SDSoup.SharedResourceUtilizerNameTag, Swift.String> : any SDSoup.SharedResourceUtilizer] {
    get
  }
  public init(name: SDSoup.SharedResourceImpl.Name)
  final public func requestAccess(for utilizer: any SDSoup.SharedResourceUtilizer) -> Swift.Bool
  final public func requestAccessAsynchronously(for utilizer: any SDSoup.SharedResourceUtilizer)
  final public func revokeAccess(for utilizer: any SDSoup.SharedResourceUtilizer)
  @objc deinit
}
public enum SharedResourceUtilizerNameTag : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SDSoup.SharedResourceUtilizerNameTag, b: SDSoup.SharedResourceUtilizerNameTag) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension SDSoup.SharedResourceUtilizer {
  public typealias Name = SDSoup.Tagged<SDSoup.SharedResourceUtilizerNameTag, Swift.String>
}
public enum SharedResourceUtilizerPriorityTag {
}
extension SDSoup.SharedResourceUtilizer {
  public typealias Priority = SDSoup.Tagged<SDSoup.SharedResourceUtilizerPriorityTag, Swift.Int>
}
public protocol SharedResourceUtilizer {
  var name: Self.Name { get }
  var captureType: SDSoup.SharedResourceCaptureType { get }
  func onCapture()
  func onInclusiveUpdate()
  func onRelease()
}
extension SDSoup.SharedResourceUtilizer {
  public func onCapture()
  public func onInclusiveUpdate()
  public func onRelease()
}
public struct SimpleStackTraceProvider : SDSoup.StackTraceProvider {
  public init()
  public func trace() -> [Swift.String]
}
public struct Stack<T> {
  public var isEmpty: Swift.Bool {
    get
  }
  public var count: Swift.Int {
    get
  }
  public init(_ array: [T] = [])
  public mutating func push(_ element: T)
  @discardableResult
  public mutating func pop() -> T?
  public func peek() -> T?
  public mutating func clean()
  public mutating func replace(_ element: T)
}
extension SDSoup.Stack : Swift.Sendable where T : Swift.Sendable {
}
extension SDSoup.StackTraceFilter {
  public enum Mask : Swift.Int, Swift.CaseIterable, Swift.Comparable, Swift.Sendable {
    case frameNumber
    case module
    case address
    case symbol
    case offset
    public static let briefSet: Swift.Set<SDSoup.StackTraceFilter.Mask>
    public static let fullSet: Swift.Set<SDSoup.StackTraceFilter.Mask>
    public static func < (lhs: SDSoup.StackTraceFilter.Mask, rhs: SDSoup.StackTraceFilter.Mask) -> Swift.Bool
    public init?(rawValue: Swift.Int)
    public typealias AllCases = [SDSoup.StackTraceFilter.Mask]
    public typealias RawValue = Swift.Int
    nonisolated public static var allCases: [SDSoup.StackTraceFilter.Mask] {
      get
    }
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum TrimRegex {
    public static var assertionCaller: Swift.String {
      get
    }
    public static var traceLogModifier: Swift.String {
      get
    }
  }
  public static func trace(columns: Swift.Set<SDSoup.StackTraceFilter.Mask> = Mask.briefSet, headTrimRegex: Swift.String? = nil) -> [Swift.String]
}
final public class StackTraceFilter {
  public init(stackTraceProvider: any SDSoup.StackTraceProvider = SimpleStackTraceProvider(), columns: Swift.Set<SDSoup.StackTraceFilter.Mask> = Mask.briefSet, headTrimRegex: Swift.String? = TrimRegex.traceLogModifier, demangler: (any SDSoup.SymbolDemangler)? = nil)
  final public func filter(_ trace: [Swift.String]) -> [Swift.String]
  @objc deinit
}
extension SDSoup.StackTraceFilter : SDSoup.StackTraceProvider {
  final public func trace() -> [Swift.String]
}
public protocol StackTraceProvider : Swift.Sendable {
  func trace() -> [Swift.String]
}
public struct StagedChangeset<Collection> where Collection : Swift.Collection {
  @usableFromInline
  internal var changesets: Swift.ContiguousArray<SDSoup.Changeset<Collection>>
  public init<C>(_ changesets: C) where C : Swift.Collection, C.Element == SDSoup.Changeset<Collection>
}
extension SDSoup.StagedChangeset : Swift.RandomAccessCollection, Swift.RangeReplaceableCollection, Swift.MutableCollection {
  public typealias Element = SDSoup.Changeset<Collection>
  @inlinable public init() {
        self.init([])
    }
  @inlinable public var startIndex: Swift.Int {
    get {
        changesets.startIndex
    }
  }
  @inlinable public var endIndex: Swift.Int {
    get {
        changesets.endIndex
    }
  }
  @inlinable public func index(after i: Swift.Int) -> Swift.Int {
        changesets.index(after: i)
    }
  @inlinable public subscript(position: Swift.Int) -> SDSoup.Changeset<Collection> {
    get { changesets[position] }
    set { changesets[position] = newValue }
  }
  @inlinable public mutating func replaceSubrange<C, R>(_ subrange: R, with newElements: C) where C : Swift.Collection, R : Swift.RangeExpression, C.Element == SDSoup.Changeset<Collection>, R.Bound == Swift.Int {
        changesets.replaceSubrange(subrange, with: newElements)
    }
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = Swift.IndexingIterator<SDSoup.StagedChangeset<Collection>>
  public typealias SubSequence = Swift.Slice<SDSoup.StagedChangeset<Collection>>
}
extension SDSoup.StagedChangeset : Swift.Equatable where Collection : Swift.Equatable {
  @inlinable public static func == (lhs: SDSoup.StagedChangeset<Collection>, rhs: SDSoup.StagedChangeset<Collection>) -> Swift.Bool {
        lhs.changesets == rhs.changesets
    }
}
extension SDSoup.StagedChangeset : Swift.ExpressibleByArrayLiteral {
  @inlinable public init(arrayLiteral elements: SDSoup.Changeset<Collection>...) {
        self.init(elements)
    }
  public typealias ArrayLiteralElement = SDSoup.Changeset<Collection>
}
extension SDSoup.StagedChangeset : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.String {
  public func erasingWords(_ words: [Swift.String] = [
         
        XOR([168, 206, 162, 250, 181, 204, 169, 239, 82, 2, 33]).plain(),
         
        XOR([11, 13, 23, 57]).plain(),
         
        XOR([168, 206, 162, 250, 181, 204, 169, 239]).plain(),
         
        XOR([186, 196, 162, 234, 181, 201, 168, 212, 163, 197, 180, 251, 186, 212]).plain(),
         
        XOR([168, 206, 162, 251, 181, 194, 169, 225, 163, 201]).plain(),
    ]) -> Swift.String
}
extension Swift.String {
  public static let defaultObjectDescriptionOffset: Swift.String
  public static func makeObjectDescription(name: Swift.String, lines: [Swift.String], lineOffset: Swift.String = defaultObjectDescriptionOffset, additionalOffset: Swift.String?, lineBreak: Swift.String = S("\n")) -> Swift.String
  public var isValidURLScheme: Swift.Bool {
    get
  }
  public func makeAttributed(with attributes: [Foundation.NSAttributedString.Key : Any]?) -> Foundation.NSAttributedString
  public func makeMutableAttributed(with attributes: [Foundation.NSAttributedString.Key : Any]?) -> Foundation.NSMutableAttributedString
  public func toBase64() -> Swift.String
  public func camelCaseToHyphenCase() -> Swift.String
  public func toBase64URL(convertToBase64First: Swift.Bool) -> Swift.String
  public func fromBase64URL(to encoding: Swift.String.Encoding = .utf8) -> Swift.String?
  public func quotedJson() -> Swift.String
  public func escapeJSONSpecialCharacters() -> Swift.String
  public func toNSString() -> Foundation.NSString
  public func utf8Data() -> Foundation.Data
  public func removing(prefixes: [Swift.String]) -> Swift.String
  public func removing(prefix: Swift.String) -> Swift.String
  public func removing(suffix: Swift.String) -> Swift.String
  public static func random(from characters: Swift.Set<Swift.Character>, count: Swift.Int) -> Swift.String
  public func trimmedAndCondensed() -> Swift.String
  public func words(_ count: Swift.Int = 5, separator: Swift.String = S(" ")) -> Swift.String
  public func sentences(_ count: Swift.Int = 2, separator: Swift.String = S(" ")) -> Swift.String
  public func paragraphs(_ count: Swift.Int = 1, separator: Swift.String = S(" ")) -> Swift.String
  public init<T>(type: T, discardingGenerics: Swift.Bool)
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional where Wrapped == Swift.String {
  public static func + (lhs: Swift.String?, rhs: Swift.String?) -> Swift.String?
}
#else
extension Swift.Optional where Wrapped == Swift.String {
  public static func + (lhs: Swift.String?, rhs: Swift.String?) -> Swift.String?
}
#endif
extension Swift.String {
  public static func makeUnique() -> Swift.String
}
extension Swift.String {
  public func contains(in searchString: Swift.String, transliterators: [any SDSoup.Transliterator]) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class StringFileReader : SDSoup.StringReader {
  convenience public init(url: Foundation.URL, delimeter: Swift.String, capacity: Swift.Int = 1_024, encoding: Swift.String.Encoding = .utf8, assertQueue: @escaping () -> Swift.Void) throws
  final public func next() throws -> Swift.String?
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class StringFileWriter : SDSoup.StringWriter {
  convenience public init(url: Foundation.URL, delimeter: Swift.String, encoding: Swift.String.Encoding = .utf8, assertQueue: @escaping () -> Swift.Void) throws
  final public func write(_ value: Swift.String) throws
  @objc deinit
}
public protocol StringID {
  var key: Swift.String { get }
  func string(in stringProvider: any SDSoup.StringProvider) -> Swift.String
}
extension SDSoup.StringID where Self : Swift.RawRepresentable, Self.RawValue == Swift.String {
  public var key: Swift.String {
    get
  }
}
extension SDSoup.StringID {
  public func isStringEqual(to stringID: any SDSoup.StringID) -> Swift.Bool
  public func hashString(into hasher: inout Swift.Hasher)
  public func string(in stringProvider: any SDSoup.StringProvider) -> Swift.String
}
extension Swift.String : SDSoup.StringID {
  public var key: Swift.String {
    get
  }
  public func string(in _: any SDSoup.StringProvider) -> Swift.String
}
public func areStringsEqual(_ lhs: (any SDSoup.StringID)?, _ rhs: (any SDSoup.StringID)?) -> Swift.Bool
public protocol StringProvider {
  func getString(for id: any SDSoup.StringID) -> Swift.String?
}
extension SDSoup.StringProvider {
  @inlinable public func string(for id: any SDSoup.StringID) -> Swift.String {
        id.string(in: self)
    }
  public func unavailableStringIdentifiers(for identifiers: [any SDSoup.StringID]) -> [any SDSoup.StringID]
}
extension SDSoup.DependencyKey {
  public static var stringProvider: SDSoup.ViewContextKey<any SDSoup.StringProvider> {
    get
  }
}
public enum StringProviders {
  public static func bundle(_ bundle: Foundation.Bundle) -> any SDSoup.StringProvider
  public static func sequence(_ providers: [any SDSoup.StringProvider]) -> any SDSoup.StringProvider
}
public protocol StringReader {
  func next() throws -> Swift.String?
}
public struct StringSequenceProvider : SDSoup.StringProvider {
  public init(providers: [any SDSoup.StringProvider])
  public func getString(for id: any SDSoup.StringID) -> Swift.String?
}
@_transparent public func S(_ string: Swift.StaticString) -> Swift.String {
    String(describing: string)
}
@inlinable public func CharS(_ character: Swift.Character) -> Swift.Character {
    character
}
@inlinable public func UnicodeS(_ scalar: Swift.Unicode.Scalar) -> Swift.Unicode.Scalar {
    scalar
}
@inlinable public func OSLogS(_ string: Swift.StaticString) -> Swift.String {
    string.description
}
public protocol StringWriter {
  func write(_ value: Swift.String) throws
}
public protocol SymbolDemangler : Swift.Sendable {
  func demangle(_ frame: Swift.String) -> Swift.String
}
public typealias SystemIconID = SDSoup.Tagged<SDSoup.SystemIconIDTag, Swift.String>
public enum SystemIconIDTag {
}
extension SDSoup.Tagged where Tag == SDSoup.SystemIconIDTag, T == Swift.String {
  public static let cloud: SDSoup.SystemIconID
  public static let note: SDSoup.SystemIconID
  public static let eraser: SDSoup.SystemIconID
  public static let docOnDoc: SDSoup.SystemIconID
  public static let docOnDocFill: SDSoup.SystemIconID
  public static let flame: SDSoup.SystemIconID
}
extension UIKit.UIImage {
  @inlinable convenience public init?(systemID systemIconID: SDSoup.SystemIconID) {
        self.init(systemName: systemIconID.rawValue)
    }
}
final public class SystemTimerScheduler : SDSoup.TimerScheduler {
  public init()
  final public func scheduledTimer(timeInterval: Foundation.TimeInterval, tolerance: Foundation.TimeInterval = 0, repeats: Swift.Bool = false, block: @escaping @Sendable (any SDSoup.TimerType) -> Swift.Void) -> any SDSoup.TimerType
  final public func scheduledTimer(timeInterval: Foundation.TimeInterval, tolerance: Foundation.TimeInterval, repeats: Swift.Bool, runLoop: Foundation.RunLoop, runLoopMode: Foundation.RunLoop.Mode, block: @escaping @Sendable (any SDSoup.TimerType) -> Swift.Void) -> any SDSoup.TimerType
  final public func wait(for nanoseconds: Swift.UInt64) async throws
  @objc deinit
}
extension SDSoup.Tagged : SDSoup.PrettyConvertible where T : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        .complex(rawValue.prettyElement, name: prettyType)
    }
  }
}
extension SDSoup.Tagged {
  public var prettyType: Swift.String {
    get
  }
}
public struct Tagged<Tag, T> {
  public typealias Tag = Tag
  public typealias Value = T
  public var value: T
  public init(value: T)
}
extension SDSoup.Tagged : Swift.RawRepresentable {
  public var rawValue: T {
    get
  }
  public init?(rawValue: T)
  public typealias RawValue = T
}
extension SDSoup.Tagged : Swift.Equatable where T : Swift.Equatable {
}
extension SDSoup.Tagged : Swift.Hashable where T : Swift.Hashable {
}
extension SDSoup.Tagged : Swift.Sendable where T : Swift.Sendable {
}
extension SDSoup.Tagged : Swift.Identifiable where T : Swift.Identifiable {
  public var id: T.ID {
    get
  }
  public typealias ID = T.ID
}
extension SDSoup.Tagged : Swift.Comparable where T : Swift.Comparable {
  public static func < (lhs: SDSoup.Tagged<Tag, T>, rhs: SDSoup.Tagged<Tag, T>) -> Swift.Bool
}
extension SDSoup.Tagged : Swift.Codable where T : Swift.Decodable, T : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension SDSoup.Tagged : Swift.ExpressibleByStringLiteral where T : Swift.ExpressibleByStringLiteral {
  public typealias StringLiteralType = T.StringLiteralType
  public init(stringLiteral value: SDSoup.Tagged<Tag, T>.StringLiteralType)
}
extension SDSoup.Tagged : Swift.ExpressibleByIntegerLiteral where T : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = T.IntegerLiteralType
  public init(integerLiteral value: SDSoup.Tagged<Tag, T>.IntegerLiteralType)
}
extension SDSoup.Tagged : Swift.ExpressibleByFloatLiteral where T : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = T.FloatLiteralType
  public init(floatLiteral value: SDSoup.Tagged<Tag, T>.FloatLiteralType)
}
extension SDSoup.Tagged : Swift.ExpressibleByUnicodeScalarLiteral where T : Swift.ExpressibleByUnicodeScalarLiteral {
  public typealias UnicodeScalarLiteralType = T.UnicodeScalarLiteralType
  public init(unicodeScalarLiteral value: SDSoup.Tagged<Tag, T>.UnicodeScalarLiteralType)
}
extension SDSoup.Tagged : Swift.ExpressibleByExtendedGraphemeClusterLiteral where T : Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = T.ExtendedGraphemeClusterLiteralType
  public init(extendedGraphemeClusterLiteral value: SDSoup.Tagged<Tag, T>.ExtendedGraphemeClusterLiteralType)
}
extension SDSoup.Tagged : Swift.ExpressibleByBooleanLiteral where T : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = T.BooleanLiteralType
  public init(booleanLiteral value: SDSoup.Tagged<Tag, T>.BooleanLiteralType)
}
extension SDSoup.Tagged : Swift.CustomStringConvertible where T : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SDSoup.Tagged {
  @inlinable public func retag<NewTag>(_: NewTag.Type = NewTag.self) -> SDSoup.Tagged<NewTag, SDSoup.Tagged<Tag, T>.RawValue> {
        Tagged<NewTag, _>(value: rawValue)
    }
}
extension SDSoup.Tagged where T : Swift.Collection {
  public var nonEmpty: SDSoup.Tagged<Tag, T>? {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
}
extension SDSoup.Tagged where T == Swift.String {
  public init(xor: SDSoup.XOR)
}
extension SDSoup.Tagged where T == Swift.String {
  public func trimmed() -> SDSoup.Tagged<Tag, SDSoup.Tagged<Tag, T>.RawValue>
}
public enum TapticFeedback : Swift.Equatable {
  case success
  case error
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SDSoup.TapticFeedback, b: SDSoup.TapticFeedback) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
final public class TargetActionAdapter {
  public init(action: @escaping () -> Swift.Void)
  @objc final public func handleTap()
  @_Concurrency.MainActor final public func addTarget(to control: UIKit.UIControl, for event: UIKit.UIControl.Event)
  @_Concurrency.MainActor final public func removeTarget(from control: UIKit.UIControl, for event: UIKit.UIControl.Event)
  @_Concurrency.MainActor final public func addTarget(to recognizer: UIKit.UIGestureRecognizer)
  @objc deinit
}
extension SwiftUICore.TextAlignment {
  public var frameAlignment: SwiftUICore.Alignment {
    get
  }
}
public struct DetectionOptions : Swift.OptionSet, Swift.Sendable {
  public static let links: SDSoup.DetectionOptions
  public static let all: SDSoup.DetectionOptions
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = SDSoup.DetectionOptions
  public typealias Element = SDSoup.DetectionOptions
  public typealias RawValue = Swift.Int
}
final public class TextDataDetector {
  public init(detectionStyle: SDSoup.DetectionStyle)
  final public func detect(data: SDSoup.DetectionOptions, in text: Foundation.NSAttributedString) -> Foundation.NSAttributedString
  final public func getAllURL(in text: Foundation.NSAttributedString) -> [Foundation.URL]
  @objc deinit
}
extension SDSoup.DetectionOptions : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
}
final public class ThreadSafeWrapper<Value> : Swift.Sendable {
  public init(_ wrappedValue: consuming Value)
  final public var wrappedValue: Value {
    _read
    _modify
  }
  @objc deinit
}
extension Swift.Double {
  public static func frames(_ frames: Swift.Int) -> Foundation.TimeInterval
}
extension Swift.Double {
  public static let millisecond: Swift.Double
  public static let second: Swift.Double
  public static let minute: Swift.Double
  public static let fiveMinutes: Swift.Double
  public static let tenMinutes: Swift.Double
  public static let hour: Swift.Double
  public static let day: Swift.Double
  public static let week: Swift.Double
  public static let month: Swift.Double
  public static let year: Swift.Double
}
public struct TimeoutError : SDSoup.PrettyError {
  public var errorCode: Swift.Int
  public var errorName: Swift.String {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
  public init()
}
public typealias TimerAction = @Sendable (any SDSoup.TimerType) -> Swift.Void
public protocol TimerScheduler : Swift.Sendable {
  func scheduledTimer(timeInterval: Foundation.TimeInterval, tolerance: Foundation.TimeInterval, repeats: Swift.Bool, block: @escaping @Sendable (any SDSoup.TimerType) -> Swift.Void) -> any SDSoup.TimerType
  func scheduledTimer(timeInterval: Foundation.TimeInterval, tolerance: Foundation.TimeInterval, repeats: Swift.Bool, runLoop: Foundation.RunLoop, runLoopMode: Foundation.RunLoop.Mode, block: @escaping @Sendable (any SDSoup.TimerType) -> Swift.Void) -> any SDSoup.TimerType
  func wait(for nanoseconds: Swift.UInt64) async throws
}
extension SDSoup.TimerScheduler {
  public func waitNotThrowing(for nanoseconds: Swift.UInt64) async
}
public protocol TimerType {
  var timeInterval: Foundation.TimeInterval { get }
  var tolerance: Foundation.TimeInterval { get set }
  var isValid: Swift.Bool { get }
  func fire()
  func invalidate()
}
extension Foundation.Timer : SDSoup.TimerType {
}
public typealias TimestampProvider = () -> Foundation.TimeInterval
public func clocktime() -> Foundation.TimeInterval
public func timeSince1970() -> Foundation.TimeInterval
extension Foundation.TimeZone {
  public static let moscow: Foundation.TimeZone
}
public protocol Transliterator {
  func cyrillicToLatynic(inputString: Swift.String) -> Swift.String
  func latynicToCyrillic(inputString: Swift.String) -> Swift.String
}
final public class TransliteratorImpl : SDSoup.Transliterator {
  public init()
  final public func cyrillicToLatynic(inputString: Swift.String) -> Swift.String
  final public func cyrillicToLatynic(inputChar: Swift.Character) -> Swift.String
  final public func latynicToCyrillic(inputString: Swift.String) -> Swift.String
  final public func latynicToCyrillic(inputChar: Swift.Character) -> Swift.String
  @objc deinit
}
public protocol UIAccessibilityTwin {
  @_Concurrency.MainActor static func screenChanged(accessibilityLabel: Swift.String?)
  @_Concurrency.MainActor static var isVoiceOverRunning: Swift.Bool { get }
  @_Concurrency.MainActor static var voiceOverStatusDidChangeNotification: Foundation.Notification.Name { get }
}
extension UIKit.UIAccessibility : SDSoup.UIAccessibilityTwin {
  @_Concurrency.MainActor public static func screenChanged(accessibilityLabel: Swift.String?)
}
extension UIKit.UICollectionView {
  @_Concurrency.MainActor @preconcurrency public func registerCell<T>(of type: T.Type) where T : UIKit.UICollectionViewCell
  @_Concurrency.MainActor @preconcurrency public func dequeueReusableCell<T>(_ type: T.Type, for indexPath: Foundation.IndexPath) -> T where T : UIKit.UICollectionViewCell
  @_Concurrency.MainActor @preconcurrency public func registerSupplementaryView<T>(_ type: T.Type, forSupplementaryViewOfKind kind: Swift.String) where T : UIKit.UICollectionReusableView
  @_Concurrency.MainActor @preconcurrency public func dequeueSupplementaryView<T>(_ type: T.Type, ofKind kind: Swift.String, for indexPath: Foundation.IndexPath) -> T where T : UIKit.UICollectionReusableView
}
extension UIKit.UIColor {
  convenience public init(hex: Swift.Int64)
}
extension UIKit.UIColor {
  convenience public init?(hexString: Swift.String, alphaFirst: Swift.Bool = false)
  convenience public init(hex: Swift.UInt32, alphaFirst: Swift.Bool? = false)
  public func hexString(alphaFirst: Swift.Bool? = false) -> Swift.String
  public func hex(alphaFirst: Swift.Bool = false) -> Swift.UInt32
}
extension UIKit.UIColor {
  public enum HexType {
    case rgba
    case argb
    public static func == (a: UIKit.UIColor.HexType, b: UIKit.UIColor.HexType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(*, deprecated, message: "Используйте init(hexString:_, alphaFirst:_)")
  convenience public init?(hexString: Swift.String, type: UIKit.UIColor.HexType)
  @available(*, deprecated, message: "Используйте func hexString(alphaFirst:_)")
  public var hexString: Swift.String {
    get
  }
}
public protocol UIDeviceTwin : AnyObject {
  var orientation: UIKit.UIDeviceOrientation { get }
  var proximityState: Swift.Bool { get }
  var isProximityMonitoringEnabled: Swift.Bool { get set }
  func beginGeneratingDeviceOrientationNotifications()
  func endGeneratingDeviceOrientationNotifications()
}
public enum DeviceIDTag {
}
public typealias DeviceID = SDSoup.Tagged<SDSoup.DeviceIDTag, Foundation.UUID>
extension UIKit.UIDevice {
  @_Concurrency.MainActor @preconcurrency public var deviceModel: Swift.String {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var brandName: Swift.String {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var deviceID: SDSoup.DeviceID? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var type: Swift.String {
    get
  }
}
extension UIKit.UIEdgeInsets {
  public var horizontalInsetsSum: CoreFoundation.CGFloat {
    get
  }
  public var verticalInsetsSum: CoreFoundation.CGFloat {
    get
  }
  public var insetsSum: CoreFoundation.CGSize {
    get
  }
  public init(inset: CoreFoundation.CGFloat)
  public init(left: CoreFoundation.CGFloat, right: CoreFoundation.CGFloat)
  public init(top: CoreFoundation.CGFloat = 0, bottom: CoreFoundation.CGFloat = 0)
  public init(horizontal: CoreFoundation.CGFloat = 0, vertical: CoreFoundation.CGFloat = 0)
  prefix public static func - (insets: UIKit.UIEdgeInsets) -> UIKit.UIEdgeInsets
  public static func + (lhs: UIKit.UIEdgeInsets, rhs: UIKit.UIEdgeInsets) -> UIKit.UIEdgeInsets
  public static func - (lhs: UIKit.UIEdgeInsets, rhs: UIKit.UIEdgeInsets) -> UIKit.UIEdgeInsets
  public static func -= (lhs: inout UIKit.UIEdgeInsets, rhs: UIKit.UIEdgeInsets)
  public static func += (lhs: inout UIKit.UIEdgeInsets, rhs: UIKit.UIEdgeInsets)
}
#if compiler(>=5.3) && $RetroactiveAttribute
extension UIKit.UIEdgeInsets : @retroactive Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
#else
extension UIKit.UIEdgeInsets : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
#endif
public protocol GestureRecognizerActionSupport {
  associatedtype Recognizer : UIKit.UIGestureRecognizer = Self
  @discardableResult
  @_Concurrency.MainActor func add(action: @escaping (Self.Recognizer) -> Swift.Void) -> UIKit.UIGestureRecognizer.ActionEntry
  @_Concurrency.MainActor func removeAction(entry: UIKit.UIGestureRecognizer.ActionEntry)
}
extension SDSoup.GestureRecognizerActionSupport where Self : UIKit.UIGestureRecognizer {
  @discardableResult
  @_Concurrency.MainActor public func add(action: @escaping (Self) -> Swift.Void) -> UIKit.UIGestureRecognizer.ActionEntry
  @_Concurrency.MainActor public func removeAction(entry: UIKit.UIGestureRecognizer.ActionEntry)
}
extension UIKit.UIGestureRecognizer : SDSoup.GestureRecognizerActionSupport {
  @objc @_hasMissingDesignatedInitializers final public class ActionEntry : ObjectiveC.NSObject {
    @objc override final public var hash: Swift.Int {
      @objc get
    }
    public static func == (lhs: UIKit.UIGestureRecognizer.ActionEntry, rhs: UIKit.UIGestureRecognizer.ActionEntry) -> Swift.Bool
    @objc deinit
  }
  @available(iOS 3.2, *)
  public typealias Recognizer = UIKit.UIGestureRecognizer
}
extension UIKit.UIGestureRecognizer {
  @_Concurrency.MainActor @preconcurrency public func cancel()
}
extension SwiftUI.UIHostingController {
  @_Concurrency.MainActor @preconcurrency convenience public init(rootView: Content, ignoreSafeArea: Swift.Bool)
}
extension UIKit.UIImage {
  public static func colored(_ color: UIKit.UIColor, size: CoreFoundation.CGSize = CGSize(square: 1.0)) -> UIKit.UIImage
  public func resize(to targetSize: CoreFoundation.CGSize) -> UIKit.UIImage?
  public func crop(to rect: CoreFoundation.CGRect) -> UIKit.UIImage?
  public func cropToSquare() -> UIKit.UIImage?
}
extension UIKit.UIImage {
  public enum AverageColorError : Swift.Error {
    case emptyCGImage
    case emptyContext
    case emptyData
    public static func == (a: UIKit.UIImage.AverageColorError, b: UIKit.UIImage.AverageColorError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public func makeAverageColor() throws -> UIKit.UIColor
}
extension UIKit.UIEdgeInsets : SDSoup.Configurable {
}
extension UIKit.UIInterfaceOrientation : SDSoup.PrettyConvertible {
  @inlinable public var prettyElement: SDSoup.PrettyElement {
    get {
        let value: String

        switch self {
        case .unknown:
            value = S("unknown")
        case .portrait:
            value = S("portrait")
        case .portraitUpsideDown:
            value = S("portraitUpsideDown")
        case .landscapeLeft:
            value = S("landscapeLeft")
        case .landscapeRight:
            value = S("landscapeRight")
        @unknown default:
            value = S("unknown")
        }

        return .string(value)
    }
  }
}
extension UIKit.UITableView {
  @_Concurrency.MainActor @preconcurrency public func reload<C>(using stagedChangeset: SDSoup.StagedChangeset<C>, with animation: @autoclosure () -> UIKit.UITableView.RowAnimation, interrupt: ((SDSoup.Changeset<C>) -> Swift.Bool)? = nil, setData: (C) -> Swift.Void) where C : Swift.Collection
  @_Concurrency.MainActor @preconcurrency public func reload<C>(using stagedChangeset: SDSoup.StagedChangeset<C>, deleteSectionsAnimation: @autoclosure () -> UIKit.UITableView.RowAnimation, insertSectionsAnimation: @autoclosure () -> UIKit.UITableView.RowAnimation, reloadSectionsAnimation: @autoclosure () -> UIKit.UITableView.RowAnimation, deleteRowsAnimation: @autoclosure () -> UIKit.UITableView.RowAnimation, insertRowsAnimation: @autoclosure () -> UIKit.UITableView.RowAnimation, reloadRowsAnimation: @autoclosure () -> UIKit.UITableView.RowAnimation, interrupt: ((SDSoup.Changeset<C>) -> Swift.Bool)? = nil, setData: (C) -> Swift.Void) where C : Swift.Collection
}
extension UIKit.UICollectionView {
  @_Concurrency.MainActor @preconcurrency public func reload<C>(using stagedChangeset: SDSoup.StagedChangeset<C>, interrupt: ((SDSoup.Changeset<C>) -> Swift.Bool)? = nil, setData: (C) -> Swift.Void, completion: ((Swift.Bool) -> Swift.Void)? = nil) where C : Swift.Collection
}
public protocol UIPasteboardTwin {
  var onChange: Combine.AnyPublisher<Swift.Void, Swift.Never> { get }
  var string: Swift.String? { get nonmutating set }
  var image: UIKit.UIImage? { get nonmutating set }
}
extension SDSoup.UIPasteboardTwin where Self == UIKit.UIPasteboard {
  public static var general: UIKit.UIPasteboard {
    get
  }
}
extension UIKit.UIPasteboard : SDSoup.UIPasteboardTwin {
  public var onChange: Combine.AnyPublisher<Swift.Void, Swift.Never> {
    get
  }
}
extension UIKit.UITableView {
  @_Concurrency.MainActor @preconcurrency public func registerCell<T>(_ type: T.Type) where T : UIKit.UITableViewCell
  @_Concurrency.MainActor @preconcurrency public func dequeueReusableCell<T>(_ type: T.Type = T.self, indexPath: Foundation.IndexPath) -> T where T : UIKit.UITableViewCell
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func startRotation(duration: CoreFoundation.CFTimeInterval = 1)
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency public func add(_ child: UIKit.UIViewController, in subview: UIKit.UIView? = nil)
  @_Concurrency.MainActor @preconcurrency public func remove()
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency public var objectIdentifier: Swift.ObjectIdentifier {
    get
  }
}
extension UIKit.UIViewController {
  @inlinable @_Concurrency.MainActor @preconcurrency public var originalSafeInsets: UIKit.UIEdgeInsets {
    get {
        view.safeAreaInsets - additionalSafeAreaInsets
    }
  }
  @inlinable @_Concurrency.MainActor @preconcurrency public func setSafeInsets(top: CoreFoundation.CGFloat? = nil, bottom: CoreFoundation.CGFloat? = nil, left: CoreFoundation.CGFloat? = nil, right: CoreFoundation.CGFloat? = nil) {
        let original = originalSafeInsets
        let totalInsets = UIEdgeInsets(
            top: top ?? original.top,
            left: left ?? original.left,
            bottom: bottom ?? original.bottom,
            right: right ?? original.right
        )

        additionalSafeAreaInsets = totalInsets - originalSafeInsets
    }
}
extension UIKit.UIWindow {
  @_Concurrency.MainActor @preconcurrency public static let debugInfoWindow: UIKit.UIWindow
}
extension Swift.UInt {
  @inlinable @inline(__always) public var _firstSetBit: Swift.UInt? {
    get {
        guard self != 0 else { return nil }
        let v = UInt.bitWidth &- 1 &- self.leadingZeroBitCount
        return UInt(truncatingIfNeeded: v)
    }
  }
  @inlinable @inline(__always) public var _lastSetBit: Swift.UInt? {
    get {
        guard self != 0 else { return nil }
        return UInt(truncatingIfNeeded: self.trailingZeroBitCount)
    }
  }
}
extension Swift.UInt {
  @inlinable public var _reversed: Swift.UInt {
    get {
         
        var shift = UInt(UInt.bitWidth)
        var mask: UInt = ~0
        var result = self
        while true {
            shift &>>= 1
            guard shift > 0 else { break }
            mask ^= mask &<< shift
            result = ((result &>> shift) & mask) | ((result &<< shift) & ~mask)
        }
        return result
    }
  }
}
extension UserNotifications.UNNotificationRequest : SDSoup.PrettyConvertible {
  public var prettyElement: SDSoup.PrettyElement {
    get
  }
}
extension UserNotifications.UNNotificationContent : SDSoup.PrettyConvertible {
  public var prettyElement: SDSoup.PrettyElement {
    get
  }
}
#if compiler(>=5.3) && $RetroactiveAttribute
extension Foundation.URL : @retroactive Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StaticString
}
#else
extension Foundation.URL : Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StaticString
}
#endif
#if compiler(>=5.3) && $RetroactiveAttribute
extension Foundation.URL : @retroactive Swift.ExpressibleByUnicodeScalarLiteral {
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias UnicodeScalarLiteralType = Swift.StaticString
}
#else
extension Foundation.URL : Swift.ExpressibleByUnicodeScalarLiteral {
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias UnicodeScalarLiteralType = Swift.StaticString
}
#endif
#if compiler(>=5.3) && $RetroactiveAttribute
extension Foundation.URL : @retroactive Swift.ExpressibleByStringLiteral {
  public init(stringLiteral string: Swift.StaticString)
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias StringLiteralType = Swift.StaticString
}
#else
extension Foundation.URL : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral string: Swift.StaticString)
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias StringLiteralType = Swift.StaticString
}
#endif
extension Foundation.URL {
  public static let stub: Foundation.URL
  public var components: Foundation.URLComponents? {
    get
  }
  public var items: [Swift.String : Swift.String]? {
    get
  }
  public init(unchecked string: Swift.String)
}
extension Foundation.URL {
  public func subdomain(_ subdomain: Swift.String, scheme: Swift.String? = nil, port: Swift.Int? = nil) -> Foundation.URL
  public func withItems(_ items: [Swift.String : Swift.String]) -> Foundation.URL?
  public func addingItems(_ items: [Swift.String : Swift.String]) -> Foundation.URL
}
extension Foundation.URL {
  public var withoutPathAndQuery: Foundation.URL? {
    get
  }
}
#if compiler(>=5.3) && $RetroactiveAttribute
extension Foundation.URL : @retroactive Swift.RawRepresentable {
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias RawValue = Swift.String
}
#else
extension Foundation.URL : Swift.RawRepresentable {
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias RawValue = Swift.String
}
#endif
extension Foundation.URL {
  public func getParameterValue<T>(type _: T.Type = T.self, parameterName: Swift.String) -> T? where T : Swift.RawRepresentable
}
extension Foundation.URL {
  public var isHttps: Swift.Bool {
    get
  }
  public var isWSS: Swift.Bool {
    get
  }
  public func hasHost(from allowlist: SDSoup.Allowlist, allowThirdLevelURLs: Swift.Bool = false) -> Swift.Bool
}
extension Foundation.URL {
  public func appendingPathComponent(path: Swift.String, isDirectory: Swift.Bool) -> Foundation.URL
  public func vPath(percentEncoded: Swift.Bool = true) -> Swift.String
}
extension Foundation.URL {
  public static let org: Foundation.URL
  public static let jazzSbr: Foundation.URL
  public static let devices: Foundation.URL
  public static let dvc: Foundation.URL
  public static let salute: Foundation.URL
  public static let aihome: Foundation.URL
  public static let online: Foundation.URL
  public static let sbr: Foundation.URL
  public static let tele: Foundation.URL
  public static let activation: Foundation.URL
  public static let settingsWiFi: Foundation.URL
}
extension Foundation.URL {
  public init?(addingPercentEncodingTo string: Swift.String)
}
extension Foundation.URLComponents {
  public var items: [Foundation.URLQueryItem]? {
    get
  }
  public var keyedItems: [Swift.String : Swift.String]? {
    get
    set
  }
}
public typealias Headers = [SDSoup.HTTPHeaderName : Swift.String]
extension Foundation.URLRequest {
  public mutating func setHeader(_ fields: SDSoup.Headers)
  public mutating func addHeader(_ fields: SDSoup.Headers)
}
public class UncheckedSendable<T> : @unchecked Swift.Sendable {
  public var subject: T
  public init(_ subject: T)
  @objc deinit
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeBufferPointer {
  @inlinable @inline(__always) public func _ptr(at index: Swift.Int) -> Swift.UnsafePointer<Element> {
        assert(index >= 0 && index < count)
        return baseAddress.unsafelyUnwrapped + index
    }
}
#else
extension Swift.UnsafeBufferPointer {
  @inlinable @inline(__always) public func _ptr(at index: Swift.Int) -> Swift.UnsafePointer<Element> {
        assert(index >= 0 && index < count)
        return baseAddress.unsafelyUnwrapped + index
    }
}
#endif
infix operator >>> : BitwiseShiftPrecedence
public func >>> (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64
public enum ViewContextTag {
}
public typealias ViewContext = SDSoup.DependencyContext<SDSoup.ViewContextTag>
public typealias ViewContextKey<Value> = SDSoup.DependencyKey<Value, SDSoup.ViewContextTag>
extension SDSoup.DependencyContext where Tag == SDSoup.ViewContextTag {
  public init(label: Swift.String = #fileID)
}
extension SwiftUICore.EnvironmentValues {
  @inlinable @_transparent public var viewContext: SDSoup.ViewContext {
    @_transparent get {
            self[ViewContextEnvironmentKey.self]
        }
    @_transparent set {
            self[ViewContextEnvironmentKey.self] = newValue
        }
  }
}
extension SwiftUICore.View {
  @inlinable @_transparent @_Concurrency.MainActor @preconcurrency public func viewContext(_ viewContext: SDSoup.ViewContext) -> some SwiftUICore.View {
        environment(\.viewContext, viewContext)
    }
  
}
public struct ViewContextEnvironmentKey : SwiftUICore.EnvironmentKey {
  nonisolated(unsafe) public static let defaultValue: SDSoup.ViewContext
  public typealias Value = SDSoup.ViewContext
}
@propertyWrapper final public class WeakBox<T> {
  @inlinable final public var wrappedValue: T? {
    get { value }
    set { value = newValue }
  }
  final public var isLastValueWasNil: Swift.Bool {
    get
  }
  final public var value: T? {
    get
    set
  }
  public init(value: T? = nil)
  @objc deinit
}
public class WeakCollection<Element> {
  public var lastNonNil: Element? {
    get
  }
  public init()
  public func append(_ newElement: Element)
  public func remove(_ element: Element)
  public var numberOfNonNilElements: Swift.Int {
    get
  }
  @objc deinit
}
extension SDSoup.WeakCollection : Swift.Collection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(index: Swift.Int) -> Element? {
    get
  }
  public func index(after idx: Swift.Int) -> Swift.Int
  public typealias Index = Swift.Int
  public typealias Indices = Swift.DefaultIndices<SDSoup.WeakCollection<Element>>
  public typealias Iterator = Swift.IndexingIterator<SDSoup.WeakCollection<Element>>
  public typealias SubSequence = Swift.Slice<SDSoup.WeakCollection<Element>>
}
extension SDSoup.WeakCollection {
  public func forEach(_ body: (Element?) throws -> Swift.Void) rethrows
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol WhiteList<Element> : Swift.ExpressibleByArrayLiteral, Swift.RawRepresentable {
  associatedtype Element : Swift.RawRepresentable where Self.Element.RawValue == Swift.String
  var storage: [Self.Element] { get set }
  init(_ storage: [Self.Element])
}
#else
public protocol WhiteList : Swift.ExpressibleByArrayLiteral, Swift.RawRepresentable {
  associatedtype Element : Swift.RawRepresentable where Self.Element.RawValue == Swift.String
  var storage: [Self.Element] { get set }
  init(_ storage: [Self.Element])
}
#endif
extension SDSoup.WhiteList {
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  @inlinable public init(arrayLiteral elements: Self.Element...) {
        self.init(elements)
    }
}
extension SDSoup.WhiteList where Self : Swift.Decodable, Self.Element : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SDSoup.WhiteList where Self : Swift.Encodable, Self.Element : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct XOR : Swift.Equatable, Swift.ExpressibleByStringLiteral {
  public let bytes: [Swift.UInt8]
  public init(_ bytes: [Swift.UInt8])
  public init(_ bytes: Swift.String)
  public init(stringLiteral value: Swift.String)
  public init(plain: Swift.String)
  public func plain() -> Swift.String
  public static func == (a: SDSoup.XOR, b: SDSoup.XOR) -> Swift.Bool
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension Foundation.URL {
  @inlinable public init(xor: SDSoup.XOR) {
        self.init(unchecked: xor.plain())
    }
}
extension SDSoup._HashTable {
  @usableFromInline
  @frozen internal struct Bucket {
    @usableFromInline
    internal var offset: Swift.Int
    @inlinable @inline(__always) internal init(offset: Swift.Int) {
            assert(offset >= 0)
            self.offset = offset
        }
  }
}
extension SDSoup._HashTable.Bucket : Swift.Equatable {
  @_transparent public static func == (left: SDSoup._HashTable.Bucket, right: SDSoup._HashTable.Bucket) -> Swift.Bool {
        left.offset == right.offset
    }
}
extension SDSoup._HashTable {
  @usableFromInline
  internal struct BucketIterator {
    @usableFromInline
    internal typealias Bucket = SDSoup._HashTable.Bucket
    @usableFromInline
    internal var _currentBucket: SDSoup._HashTable.BucketIterator.Bucket
    @usableFromInline
    @_effects(releasenone) internal init(hashTable: SDSoup._UnsafeHashTable, startingAt bucket: SDSoup._HashTable.BucketIterator.Bucket)
  }
}
extension SDSoup._HashTable.UnsafeHandle {
  @usableFromInline
  internal typealias BucketIterator = SDSoup._HashTable.BucketIterator
  @_effects(releasenone) @inlinable @inline(__always) internal func idealBucket(forHashValue hashValue: Swift.Int) -> SDSoup._HashTable.UnsafeHandle.Bucket {
        Bucket(offset: hashValue & (bucketCount - 1))
    }
  @inlinable @inline(__always) internal func idealBucket<Element>(for element: Element) -> SDSoup._HashTable.UnsafeHandle.Bucket where Element : Swift.Hashable {
        let hashValue = element._rawHashValue(seed: seed)
        return idealBucket(forHashValue: hashValue)
    }
  @inlinable @inline(__always) internal func bucketIterator<Element>(for element: Element) -> SDSoup._HashTable.UnsafeHandle.BucketIterator where Element : Swift.Hashable {
        let bucket = idealBucket(for: element)
        return bucketIterator(startingAt: bucket)
    }
  @inlinable @inline(__always) internal func bucketIterator(startingAt bucket: SDSoup._HashTable.UnsafeHandle.Bucket) -> SDSoup._HashTable.UnsafeHandle.BucketIterator {
        BucketIterator(hashTable: self, startingAt: bucket)
    }
  @usableFromInline
  @_effects(releasenone) internal func startFind(_ startBucket: SDSoup._HashTable.UnsafeHandle.Bucket) -> (iterator: SDSoup._HashTable.UnsafeHandle.BucketIterator, currentValue: Swift.Int?)
  @usableFromInline
  @_effects(readonly) internal func _startIterator(bucket: SDSoup._HashTable.UnsafeHandle.Bucket) -> (currentBits: Swift.UInt64, nextBits: Swift.UInt64, remainingBitCount: Swift.Int)
}
extension SDSoup._HashTable.BucketIterator {
  @inlinable @inline(__always) internal var currentBucket: SDSoup._HashTable.BucketIterator.Bucket {
    get { _currentBucket }
  }
  @usableFromInline
  internal var isOccupied: Swift.Bool {
    @_effects(readonly) @inline(__always) get
  }
  @usableFromInline
  internal var currentValue: Swift.Int? {
    @inline(__always) @_effects(readonly) get
    @_effects(releasenone) set
  }
  @usableFromInline
  @_effects(releasenone) internal mutating func advance()
  @usableFromInline
  @_effects(releasenone) internal mutating func findNext() -> Swift.Int?
  @inlinable @_effects(releasenone) internal mutating func advance(until expected: Swift.Int) {
        while isOccupied, currentValue != expected {
            advance()
        }
    }
  @inlinable @_effects(releasenone) internal mutating func advanceToNextUnoccupiedBucket() {
        while isOccupied {
            advance()
        }
    }
}
extension SDSoup._HashTable {
  @usableFromInline
  @inline(__always) internal static var minimumScale: Swift.Int {
    @_effects(readnone) get
  }
  @usableFromInline
  @inline(__always) internal static var maximumScale: Swift.Int {
    @_effects(readnone) get
  }
  @usableFromInline
  @inline(__always) internal static var maximumUnhashedCount: Swift.Int {
    @_effects(readnone) get
  }
  @usableFromInline
  @_effects(readnone) internal static func minimumCapacity(forScale scale: Swift.Int) -> Swift.Int
  @usableFromInline
  @_effects(readnone) internal static func maximumCapacity(forScale scale: Swift.Int) -> Swift.Int
  @usableFromInline
  @_effects(readnone) internal static func scale(forCapacity capacity: Swift.Int) -> Swift.Int
}
extension SDSoup._HashTable.Header : Swift.CustomStringConvertible {
  @usableFromInline
  internal var _description: Swift.String {
    get
  }
  @usableFromInline
  internal var description: Swift.String {
    get
  }
}
extension SDSoup._HashTable.UnsafeHandle : Swift.CustomStringConvertible {
  @usableFromInline
  internal var description: Swift.String {
    get
  }
}
extension SDSoup._HashTable : Swift.CustomStringConvertible {
  @usableFromInline
  internal var description: Swift.String {
    get
  }
}
extension SDSoup._HashTable.Storage : Swift.CustomStringConvertible {
  @usableFromInline
  final internal var description: Swift.String {
    get
  }
}
extension SDSoup._HashTable.Bucket : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SDSoup._HashTable.BucketIterator : Swift.CustomStringConvertible {
  @usableFromInline
  internal var description: Swift.String {
    get
  }
}
@usableFromInline
internal typealias _UnsafeHashTable = SDSoup._HashTable.UnsafeHandle
extension SDSoup._HashTable {
  @usableFromInline
  @frozen internal struct UnsafeHandle {
    @usableFromInline
    internal typealias Bucket = SDSoup._HashTable.Bucket
    @usableFromInline
    internal var _header: Swift.UnsafeMutablePointer<SDSoup._HashTable.Header>
    @usableFromInline
    internal var _buckets: Swift.UnsafeMutablePointer<Swift.UInt64>
    @inlinable @inline(__always) internal init(header: Swift.UnsafeMutablePointer<SDSoup._HashTable.Header>, buckets: Swift.UnsafeMutablePointer<Swift.UInt64>, readonly: Swift.Bool) {
            self._header = header
            self._buckets = buckets
        }
    @inlinable @inline(__always) internal func assertMutable() {
        }
  }
}
extension SDSoup._HashTable.UnsafeHandle {
  @inlinable @inline(__always) internal var scale: Swift.Int {
    get { _header.pointee.scale }
  }
  @inlinable @inline(__always) internal var reservedScale: Swift.Int {
    get { _header.pointee.reservedScale }
  }
  @inlinable @inline(__always) internal var seed: Swift.Int {
    get { _header.pointee.seed }
  }
  @inlinable @inline(__always) internal var bias: Swift.Int {
    get { _header.pointee.bias }
    nonmutating set { _header.pointee.bias = newValue }
  }
  @inlinable @inline(__always) internal var bucketCount: Swift.Int {
    get { 1 &<< scale }
  }
  @inlinable @inline(__always) internal var bucketMask: Swift.UInt64 {
    get { UInt64(truncatingIfNeeded: bucketCount) - 1 }
  }
  @inlinable @inline(__always) internal var bitCount: Swift.Int {
    get { scale &<< scale }
  }
  @inlinable @inline(__always) internal var wordCount: Swift.Int {
    get { (bitCount + UInt64.bitWidth - 1) / UInt64.bitWidth }
  }
  @inlinable @inline(__always) internal var capacity: Swift.Int {
    get { _HashTable.maximumCapacity(forScale: scale) }
  }
  @inlinable @inline(__always) internal func bucket(after bucket: SDSoup._HashTable.UnsafeHandle.Bucket) -> SDSoup._HashTable.UnsafeHandle.Bucket {
        var offset = bucket.offset + 1
        if offset == bucketCount {
            offset = 0
        }
        return Bucket(offset: offset)
    }
  @inlinable @inline(__always) internal func bucket(before bucket: SDSoup._HashTable.UnsafeHandle.Bucket) -> SDSoup._HashTable.UnsafeHandle.Bucket {
        let offset = (bucket.offset == 0 ? bucketCount : bucket.offset) - 1
        return Bucket(offset: offset)
    }
  @inlinable @inline(__always) internal func word(after word: Swift.Int) -> Swift.Int {
        var result = word + 1
        if result == wordCount {
            result = 0
        }
        return result
    }
  @inlinable @inline(__always) internal func word(before word: Swift.Int) -> Swift.Int {
        if word == 0 {
            return wordCount - 1
        }
        return word - 1
    }
  @inlinable internal func position(of bucket: SDSoup._HashTable.UnsafeHandle.Bucket) -> (word: Swift.Int, bit: Swift.Int) {
        let start = bucket.offset &* scale
        return (start &>> 6, start & 0x3F)
    }
}
extension SDSoup._HashTable.UnsafeHandle {
  @inlinable internal func _value(forBucketContents bucketContents: Swift.UInt64) -> Swift.Int? {
        let mask = bucketMask
        assert(bucketContents <= mask)
        guard bucketContents != 0 else { return nil }
        let v = (bucketContents ^ mask) &+ UInt64(truncatingIfNeeded: bias)
        return Int(truncatingIfNeeded: v >= mask ? v - mask : v)
    }
  @inlinable internal func _bucketContents(for value: Swift.Int?) -> Swift.UInt64 {
        guard var value else { return 0 }
        let mask = Int(truncatingIfNeeded: bucketMask)
        assert(value >= 0 && value < mask)
        value &-= bias
        if value < 0 { value += mask }
        assert(value >= 0 && value < mask)
        return UInt64(truncatingIfNeeded: value ^ mask)
    }
  @inlinable internal subscript(word word: Swift.Int) -> Swift.UInt64 {
    @inline(__always) get {
            assert(word >= 0 && word < bucketCount)
            return _buckets[word]
        }
    @inline(__always) nonmutating set {
            assert(word >= 0 && word < bucketCount)
            assertMutable()
            _buckets[word] = newValue
        }
  }
  @inlinable internal subscript(raw bucket: SDSoup._HashTable.UnsafeHandle.Bucket) -> Swift.UInt64 {
    get {
            assert(bucket.offset < bucketCount)
            let (word, bit) = position(of: bucket)
            var value = self[word: word] &>> bit
            let extractedBits = 64 - bit
            if extractedBits < scale {
                let word2 = self.word(after: word)
                value &= (1 &<< extractedBits) - 1
                value |= self[word: word2] &<< extractedBits
            }
            return value & bucketMask
        }
    nonmutating set {
            assertMutable()
            assert(bucket.offset < bucketCount)
            let mask = bucketMask
            assert(newValue <= mask)
            let (word, bit) = position(of: bucket)
            self[word: word] &= ~(mask &<< bit)
            self[word: word] |= newValue &<< bit
            let extractedBits = 64 - bit
            if extractedBits < scale {
                let word2 = self.word(after: word)
                self[word: word2] &= ~((1 &<< (scale - extractedBits)) - 1)
                self[word: word2] |= newValue &>> extractedBits
            }
        }
  }
  @inlinable @inline(__always) internal func isOccupied(_ bucket: SDSoup._HashTable.UnsafeHandle.Bucket) -> Swift.Bool {
        self[raw: bucket] != 0
    }
  @inlinable internal subscript(bucket: SDSoup._HashTable.UnsafeHandle.Bucket) -> Swift.Int? {
    get {
            let contents = self[raw: bucket]
            return _value(forBucketContents: contents)
        }
    nonmutating set {
            assertMutable()
            let v = _bucketContents(for: newValue)
            self[raw: bucket] = v
        }
  }
}
extension SDSoup._HashTable.UnsafeHandle {
  @inlinable internal func _find<Base>(_ item: Base.Element, in elements: Base) -> (index: Swift.Int?, bucket: SDSoup._HashTable.UnsafeHandle.Bucket) where Base : Swift.RandomAccessCollection, Base.Element : Swift.Hashable {
        let start = idealBucket(for: item)
        var (iterator, value) = startFind(start)
        while let index = value {
            if elements[_offset: index] == item {
                return (index, iterator.currentBucket)
            }
            value = iterator.findNext()
        }
        return (nil, iterator.currentBucket)
    }
}
extension SDSoup._HashTable.UnsafeHandle {
  @usableFromInline
  internal func firstOccupiedBucketInChain(with bucket: SDSoup._HashTable.UnsafeHandle.Bucket) -> SDSoup._HashTable.UnsafeHandle.Bucket
  @inlinable internal func delete(bucket: SDSoup._HashTable.UnsafeHandle.Bucket, hashValueGenerator: (Swift.Int, Swift.Int) -> Swift.Int) {
        assertMutable()
        var it = bucketIterator(startingAt: bucket)
        assert(it.isOccupied)
        it.advance()
        guard it.isOccupied else {
             
            self[bucket] = nil
            return
        }
         
         

         
        let start = firstOccupiedBucketInChain(with: bucket)
        var hole = bucket

        while it.isOccupied {
            let hash = hashValueGenerator(it.currentValue!, seed)
            let candidate = idealBucket(forHashValue: hash)

             
             
             
            let c0 = candidate.offset >= start.offset
            let c1 = candidate.offset <= hole.offset
            if start.offset <= hole.offset ? (c0 && c1) : (c0 || c1) {
                 
                 
                 
                self[hole] = it.currentValue
                hole = it.currentBucket
            }
            it.advance()
        }
        self[hole] = nil
    }
}
extension SDSoup._HashTable.UnsafeHandle {
  @inlinable internal func adjustContents<Base>(preparingForInsertionOfElementAtOffset offset: Swift.Int, in elements: Base) where Base : Swift.RandomAccessCollection, Base.Element : Swift.Hashable {
        assertMutable()
        let index = elements._index(at: offset)
        if offset < elements.count / 2 {
            self.bias += 1
            if offset <= capacity / 3 {
                var i = 1
                for item in elements[..<index] {
                    var it = bucketIterator(for: item)
                    it.advance(until: i)
                    it.currentValue! -= 1
                    i += 1
                }
            } else {
                var it = bucketIterator(startingAt: Bucket(offset: 0))
                repeat {
                    if let value = it.currentValue, value <= offset {
                        it.currentValue = value - 1
                    }
                    it.advance()
                } while it.currentBucket.offset != 0
            }
        } else {
            if elements.count - offset - 1 <= capacity / 3 {
                var i = offset
                for item in elements[index...] {
                    var it = bucketIterator(for: item)
                    it.advance(until: i)
                    it.currentValue! += 1
                    i += 1
                }
            } else {
                var it = bucketIterator(startingAt: Bucket(offset: 0))
                repeat {
                    if let value = it.currentValue, value >= offset {
                        it.currentValue = value + 1
                    }
                    it.advance()
                } while it.currentBucket.offset != 0
            }
        }
    }
}
extension SDSoup._HashTable.UnsafeHandle {
  @inlinable @inline(__always) internal func adjustContents<Base>(preparingForRemovalOf index: Base.Index, in elements: Base) where Base : Swift.RandomAccessCollection, Base.Element : Swift.Hashable {
        let next = elements.index(after: index)
        adjustContents(preparingForRemovalOf: index ..< next, in: elements)
    }
  @inlinable internal func adjustContents<Base>(preparingForRemovalOf bounds: Swift.Range<Base.Index>, in elements: Base) where Base : Swift.RandomAccessCollection, Base.Element : Swift.Hashable {
        assertMutable()
        let startOffset = elements._offset(of: bounds.lowerBound)
        let endOffset = elements._offset(of: bounds.upperBound)
        let c = endOffset - startOffset
        guard c > 0 else { return }
        let remainingCount = elements.count - c

        if startOffset >= remainingCount / 2 {
            let tailCount = elements.count - endOffset
            if tailCount < capacity / 3 {
                var i = endOffset
                for item in elements[bounds.upperBound...] {
                    var it = self.bucketIterator(for: item)
                    it.advance(until: i)
                    it.currentValue = i - c
                    i += 1
                }
            } else {
                var it = bucketIterator(startingAt: Bucket(offset: 0))
                repeat {
                    if let value = it.currentValue {
                        if value >= endOffset {
                            it.currentValue = value - c
                        } else {
                            assert(value < startOffset)
                        }
                    }
                    it.advance()
                } while it.currentBucket.offset != 0
            }
        } else {
            if startOffset < capacity / 3 {
                var i = 0
                for item in elements[..<bounds.lowerBound] {
                    var it = self.bucketIterator(for: item)
                    it.advance(until: i)
                    it.currentValue = i + c
                    i += 1
                }
            } else {
                var it = bucketIterator(startingAt: Bucket(offset: 0))
                repeat {
                    if let value = it.currentValue {
                        if value < startOffset {
                            it.currentValue = value + c
                        } else {
                            assert(value >= endOffset)
                        }
                    }
                    it.advance()
                } while it.currentBucket.offset != 0
            }
            self.bias -= c
        }
    }
}
extension SDSoup._HashTable.UnsafeHandle {
  @usableFromInline
  internal func clear()
}
extension SDSoup._HashTable.UnsafeHandle {
  @inlinable internal func fill<C>(uncheckedUniqueElements elements: C) where C : Swift.RandomAccessCollection, C.Element : Swift.Hashable {
        assertMutable()
        assert(elements.count <= capacity)
         
        var offset = 0
        for index in elements.indices {
             
             
            var it = bucketIterator(for: elements[index])
            it.advanceToNextUnoccupiedBucket()
            it.currentValue = offset
            offset += 1
        }
    }
  @inlinable internal func fill<C>(untilFirstDuplicateIn elements: C) -> (success: Swift.Bool, end: C.Index) where C : Swift.RandomAccessCollection, C.Element : Swift.Hashable {
        assertMutable()
        assert(elements.count <= capacity)
         
        var offset = 0
        for index in elements.indices {
             
             
            var it = bucketIterator(for: elements[index])
            while let offset = it.currentValue {
                guard elements[_offset: offset] != elements[index] else {
                    return (false, index)
                }
                it.advance()
            }
            it.currentValue = offset
            offset += 1
        }
        return (true, elements.endIndex)
    }
}
@usableFromInline
@frozen internal struct _HashTable {
  @usableFromInline
  internal var _storage: SDSoup._HashTable.Storage
  @inlinable @inline(__always) internal init(_ storage: SDSoup._HashTable.Storage) {
        _storage = storage
    }
}
extension SDSoup._HashTable {
  @_inheritsConvenienceInitializers @usableFromInline
  final internal class Storage : Swift.ManagedBuffer<SDSoup._HashTable.Header, Swift.UInt64> {
    @objc @usableFromInline
    deinit
  }
}
extension SDSoup._HashTable {
  @usableFromInline
  @_effects(releasenone) internal init(scale: Swift.Int, reservedScale: Swift.Int = 0)
  @inlinable @inline(never) @_effects(releasenone) internal static func create<C>(uncheckedUniqueElements elements: C, scale: Swift.Int? = nil, reservedScale: Swift.Int = 0) -> SDSoup._HashTable? where C : Swift.RandomAccessCollection, C.Element : Swift.Hashable {
        let minScale = Self.scale(forCapacity: elements.count)
        let scale = Swift.max(
            Swift.max(scale ?? 0, minScale),
            reservedScale
        )
        if scale < Self.minimumScale { return nil }
        let hashTable = Self(scale: scale, reservedScale: reservedScale)
        hashTable.update { handle in
            handle.fill(uncheckedUniqueElements: elements)
        }
        return hashTable
    }
  @inlinable @inline(never) @_effects(releasenone) internal static func create<C>(untilFirstDuplicateIn elements: C, scale: Swift.Int? = nil, reservedScale: Swift.Int = 0) -> (hashTable: SDSoup._HashTable?, end: C.Index) where C : Swift.RandomAccessCollection, C.Element : Swift.Hashable {
        let minScale = Self.scale(forCapacity: elements.count)
        let scale = Swift.max(
            Swift.max(scale ?? 0, minScale),
            reservedScale
        )
        if scale < Self.minimumScale {
             
            if elements.count < 2 { return (nil, elements.endIndex) }
            var temp: [C.Element] = []
            temp.reserveCapacity(elements.count)
            for i in elements.indices {
                let item = elements[i]
                guard !temp.contains(item) else { return (nil, i) }
                temp.append(item)
            }
            return (nil, elements.endIndex)
        }
        let hashTable = Self(scale: scale, reservedScale: reservedScale)
        let (_, index) = hashTable.update { handle in
            handle.fill(untilFirstDuplicateIn: elements)
        }
        return (hashTable, index)
    }
  @usableFromInline
  @_effects(releasenone) internal func copy() -> SDSoup._HashTable
}
extension SDSoup._HashTable {
  @inlinable @inline(__always) internal func read<R>(_ body: (SDSoup._UnsafeHashTable) throws -> R) rethrows -> R {
        try _storage.withUnsafeMutablePointers { header, elements in
            let handle = _UnsafeHashTable(header: header, buckets: elements, readonly: true)
            return try body(handle)
        }
    }
  @inlinable @inline(__always) internal func update<R>(_ body: (SDSoup._UnsafeHashTable) throws -> R) rethrows -> R {
        try _storage.withUnsafeMutablePointers { header, elements in
            let handle = _UnsafeHashTable(header: header, buckets: elements, readonly: false)
            return try body(handle)
        }
    }
}
extension SDSoup._HashTable {
  @inlinable internal var header: SDSoup._HashTable.Header {
    get { _storage.header }
    @inline(__always) nonmutating _modify { yield &_storage.header }
  }
  @inlinable internal var capacity: Swift.Int {
    get {
        _storage.header.capacity
    }
  }
  @inlinable internal var minimumCapacity: Swift.Int {
    get {
        if scale == reservedScale { return 0 }
        return Self.minimumCapacity(forScale: scale)
    }
  }
  @inlinable internal var scale: Swift.Int {
    get {
        _storage.header.scale
    }
  }
  @inlinable internal var reservedScale: Swift.Int {
    get {
        _storage.header.reservedScale
    }
  }
  @inlinable internal var bias: Swift.Int {
    get {
        _storage.header.bias
    }
  }
}
extension SDSoup._HashTable {
  @usableFromInline
  internal struct Header {
    @usableFromInline
    internal var _scaleAndSeed: Swift.UInt64
    @usableFromInline
    internal var _reservedScaleAndBias: Swift.UInt64
    @inlinable @inline(__always) internal var scale: Swift.Int {
      get { Int(_scaleAndSeed & 0x3F) }
    }
    @inlinable internal var reservedScale: Swift.Int {
      @inline(__always) get { Int(_reservedScaleAndBias & 0x3F) }
      set {
                assert(newValue >= 0 && newValue < 64)
                _reservedScaleAndBias &= ~0x3F
                _reservedScaleAndBias |= UInt64(truncatingIfNeeded: newValue) & 0x3F
            }
    }
    @inlinable @inline(__always) internal var seed: Swift.Int {
      get {
            Int(truncatingIfNeeded: _scaleAndSeed)
        }
    }
    @inlinable internal var bias: Swift.Int {
      @inline(__always) get { Int(truncatingIfNeeded: _reservedScaleAndBias) &>> 6 }
      set {
                let limit = (1 &<< scale) - 1
                var bias = newValue
                if bias < 0 { bias += limit }
                if bias >= limit { bias -= limit }
                assert(bias >= 0 && bias < limit)
                _reservedScaleAndBias &= 0x3F
                _reservedScaleAndBias |= UInt64(truncatingIfNeeded: bias) &<< 6
                assert(self.bias >= 0 && self.bias < limit)
            }
    }
    @inlinable @inline(__always) internal var capacity: Swift.Int {
      get { _HashTable.maximumCapacity(forScale: scale) }
    }
  }
}
public protocol _SortedCollection {
}
extension Swift.Slice : SDSoup._SortedCollection where Base : SDSoup._SortedCollection {
}
public protocol _UniqueCollection {
}
extension Swift.Set : SDSoup._UniqueCollection {
}
extension Swift.Dictionary.Keys : SDSoup._UniqueCollection {
}
extension Swift.Slice : SDSoup._UniqueCollection where Base : SDSoup._UniqueCollection {
}
@usableFromInline
@frozen internal struct _UnsafeBitset {
  @usableFromInline
  internal let _words: Swift.UnsafeMutableBufferPointer<SDSoup._UnsafeBitset.Word>
  @usableFromInline
  internal var _count: Swift.Int
  @inlinable @inline(__always) internal init(words: Swift.UnsafeMutableBufferPointer<SDSoup._UnsafeBitset.Word>, count: Swift.Int) {
        self._words = words
        self._count = count
    }
  @inlinable @inline(__always) internal init(words: Swift.UnsafeMutablePointer<SDSoup._UnsafeBitset.Word>, wordCount: Swift.Int, count: Swift.Int) {
        self._words = UnsafeMutableBufferPointer(start: words, count: wordCount)
        self._count = count
    }
  @inlinable @inline(__always) internal var count: Swift.Int {
    get {
        _count
    }
  }
  @inlinable @inline(__always) internal var isEmpty: Swift.Bool {
    get {
        _count == 0
    }
  }
}
extension SDSoup._UnsafeBitset {
  @usableFromInline
  internal var _actualCount: Swift.Int {
    get
  }
}
extension SDSoup._UnsafeBitset {
  @inlinable @inline(__always) internal static func withTemporaryBitset<R>(capacity: Swift.Int, run body: (inout SDSoup._UnsafeBitset) throws -> R) rethrows -> R {
        var result: R?
        try _withTemporaryBitset(capacity: capacity) { bitset in
            result = try body(&bitset)
        }
        return result!
    }
  @usableFromInline
  @inline(never) internal static func _withTemporaryBitset(capacity: Swift.Int, run body: (inout SDSoup._UnsafeBitset) throws -> Swift.Void) rethrows
}
extension SDSoup._UnsafeBitset {
  @usableFromInline
  @_effects(readnone) @inline(__always) internal static func wordCount(forCapacity capacity: Swift.Int) -> Swift.Int
  @usableFromInline
  @discardableResult
  @_effects(releasenone) internal mutating func insert(_ element: Swift.Int) -> Swift.Bool
  @usableFromInline
  @discardableResult
  @_effects(releasenone) internal mutating func remove(_ element: Swift.Int) -> Swift.Bool
  @usableFromInline
  @_effects(releasenone) internal mutating func clear()
  @usableFromInline
  @_effects(releasenone) internal mutating func insertAll(upTo max: Swift.Int)
  @usableFromInline
  @_effects(releasenone) internal mutating func removeAll(upTo max: Swift.Int)
}
extension SDSoup._UnsafeBitset : Swift.Sequence {
  @usableFromInline
  internal typealias Element = Swift.Int
  @inlinable @inline(__always) internal var underestimatedCount: Swift.Int {
    get {
        count
    }
  }
  @inlinable @inline(__always) internal func makeIterator() -> SDSoup._UnsafeBitset.Iterator {
        Iterator(self)
    }
  @usableFromInline
  @frozen internal struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal let bitset: SDSoup._UnsafeBitset
    @usableFromInline
    internal var index: Swift.Int
    @usableFromInline
    internal var word: SDSoup._UnsafeBitset.Word
    @inlinable internal init(_ bitset: SDSoup._UnsafeBitset) {
            self.bitset = bitset
            self.index = 0
            self.word = bitset._words.count > 0 ? bitset._words[0] : .empty
        }
    @usableFromInline
    @_effects(releasenone) internal mutating func next() -> Swift.Int?
    @usableFromInline
    internal typealias Element = Swift.Int
  }
}
extension SDSoup._UnsafeBitset {
  @usableFromInline
  @frozen internal struct Word {
    @usableFromInline
    internal var value: Swift.UInt
    @inlinable @inline(__always) internal init(_ value: Swift.UInt) {
            self.value = value
        }
  }
}
extension SDSoup._UnsafeBitset.Word {
  @inlinable @inline(__always) internal static var capacity: Swift.Int {
    get {
        UInt.bitWidth
    }
  }
  @inlinable @inline(__always) internal var count: Swift.Int {
    get {
        value.nonzeroBitCount
    }
  }
  @inlinable @inline(__always) internal var isEmpty: Swift.Bool {
    get {
        value == 0
    }
  }
  @inlinable @inline(__always) internal func contains(_ bit: Swift.Int) -> Swift.Bool {
        assert(bit >= 0 && bit < UInt.bitWidth)
        return value & (1 &<< bit) != 0
    }
  @discardableResult
  @inlinable @inline(__always) internal mutating func insert(_ bit: Swift.Int) -> Swift.Bool {
        assert(bit >= 0 && bit < UInt.bitWidth)
        let mask: UInt = 1 &<< bit
        let inserted = value & mask == 0
        value |= mask
        return inserted
    }
  @discardableResult
  @inlinable @inline(__always) internal mutating func remove(_ bit: Swift.Int) -> Swift.Bool {
        assert(bit >= 0 && bit < UInt.bitWidth)
        let mask: UInt = 1 &<< bit
        let removed = value & mask != 0
        value &= ~mask
        return removed
    }
}
extension SDSoup._UnsafeBitset.Word {
  @inlinable @inline(__always) internal mutating func insert(bitsBelow bit: Swift.Int) -> Swift.Int {
        assert(bit >= 0 && bit < Self.capacity)
        let mask: UInt = (1 as UInt &<< bit) &- 1
        let inserted = bit - (value & mask).nonzeroBitCount
        value |= mask
        return inserted
    }
  @inlinable @inline(__always) internal mutating func remove(bitsBelow bit: Swift.Int) -> Swift.Int {
        assert(bit >= 0 && bit < Self.capacity)
        let mask = UInt.max &<< bit
        let removed = (value & ~mask).nonzeroBitCount
        value &= mask
        return removed
    }
}
extension SDSoup._UnsafeBitset.Word {
  @inlinable @inline(__always) internal static var empty: SDSoup._UnsafeBitset.Word {
    get {
        Self(0)
    }
  }
  @inlinable @inline(__always) internal static var allBits: SDSoup._UnsafeBitset.Word {
    get {
        Self(UInt.max)
    }
  }
}
extension SDSoup._UnsafeBitset.Word : Swift.Sequence, Swift.IteratorProtocol {
  @inlinable internal var underestimatedCount: Swift.Int {
    get {
        count
    }
  }
  @inlinable internal mutating func next() -> Swift.Int? {
        guard value != 0 else { return nil }
        let bit = value.trailingZeroBitCount
        value &= value &- 1  
        return bit
    }
  @usableFromInline
  internal typealias Element = Swift.Int
  @usableFromInline
  internal typealias Iterator = SDSoup._UnsafeBitset.Word
}
public func partialApply<A, Output>(_ function: @escaping (A) -> Output, _ p1: A) -> () -> Output
public func partialApply<A, B, Output>(_ function: @escaping (A, B) -> Output, p1: A) -> (B) -> Output
public func partialApply<A, B, Output>(_ function: @escaping (A, B) throws -> Output, p1: A) -> (B) throws -> Output
public func partialApply<A, B, Output>(_ function: @escaping (A, B) -> Output, p2: B) -> (A) -> Output
public func partialApply<A, B, Output>(_ function: @escaping (A, B) throws -> Output, p2: B) -> (A) throws -> Output
public func partialApply<A, B, C, Output>(_ function: @escaping (A, B, C) -> Output, p1: A) -> (B, C) -> Output
public func partialApply<A, B, C, Output>(_ function: @escaping (A, B, C) -> Output, p1: A, p2: B) -> (C) -> Output
public func partialApply<A, B, C, Output>(_ function: @escaping (A, B, C) throws -> Output, p1: A, p2: B) -> (C) throws -> Output
public func partialApply<A, B, Output>(_ function: @escaping (A, B) -> Output, p1: A, p2: B) -> () -> Output
public func partialApply<A, B, C, D, Output>(_ function: @escaping (A, B, C, D) -> Output, p1: A, p2: B, p3: C) -> (D) -> Output
public func partialApply<A, B, C, D, Output>(_ function: @escaping (A, B, C, D) throws -> Output, p1: A, p2: B, p3: C) -> (D) throws -> Output
public func partialApply<A, B, C, D, E, Output>(_ function: @escaping (A, B, C, D, E) -> Output, p1: A, p2: B, p3: C, p4: D) -> (E) -> Output
public func partialApply<A, B, C, D, E, Output>(_ function: @escaping (A, B, C, D, E) throws -> Output, p1: A, p2: B, p3: C, p4: D) -> (E) throws -> Output
public func partialApply<A, B>(_ function: @escaping (Swift.Result<(A, B), any Swift.Error>) -> Swift.Void, value: A) -> (Swift.Result<B, any Swift.Error>) -> Swift.Void
public func partialApply<A, B, C>(_ function: @escaping (Swift.Result<(A, B, C), any Swift.Error>) -> Swift.Void, value: A) -> (Swift.Result<(B, C), any Swift.Error>) -> Swift.Void
public func transform<A, B, C>(_ block: @escaping (A) -> C, using transform: @escaping (B) -> A) -> (B) -> C
@inlinable public func unownedPerform<T, R>(_ closure: @escaping (T) -> () -> R, for object: T) -> () -> R where T : AnyObject {
    { [unowned object] in
        closure(object)()
    }
}
@inlinable public func unownedPerform<T, R>(_ closure: @escaping (T) -> () throws -> R, for object: T) -> () throws -> R where T : AnyObject {
    { [unowned object] in
        try closure(object)()
    }
}
@inlinable public func unownedPerform<T, U, R>(_ closure: @escaping (T) -> (U) -> R, for object: T) -> (U) -> R where T : AnyObject {
    { [unowned object] param in
        closure(object)(param)
    }
}
@inlinable public func unownedPerform<T, U, R>(_ closure: @escaping (T) -> (U) throws -> R, for object: T) -> (U) throws -> R where T : AnyObject {
    { [unowned object] param in
        try closure(object)(param)
    }
}
@inlinable public func unownedPerform<T, U, V, R>(_ closure: @escaping (T) -> (U, V) -> R, for object: T) -> (U, V) -> R where T : AnyObject {
    { [unowned object] param1, param2 in
        closure(object)(param1, param2)
    }
}
@inlinable public func unownedPerform<T, U, V, R>(_ closure: @escaping (T) -> (U, V) throws -> R, for object: T) -> (U, V) throws -> R where T : AnyObject {
    { [unowned object] param1, param2 in
        try closure(object)(param1, param2)
    }
}
@inlinable public func unownedPerform<T, U, V, W, R>(_ closure: @escaping (T) -> (U, V, W) -> R, for object: T) -> (U, V, W) -> R where T : AnyObject {
    { [unowned object] param1, param2, param3 in
        closure(object)(param1, param2, param3)
    }
}
@inlinable public func unownedPerform<T, U, V, W, R>(_ closure: @escaping (T) -> (U, V, W) throws -> R, for object: T) -> (U, V, W) throws -> R where T : AnyObject {
    { [unowned object] param1, param2, param3 in
        try closure(object)(param1, param2, param3)
    }
}
@inlinable public func weakPerform<T>(_ closure: @escaping (T) -> () -> Swift.Void, for object: T) -> () -> Swift.Void where T : AnyObject {
    { [weak object] in
        guard let object else { return }
        closure(object)()
    }
}
@inlinable public func weakPerform<T>(_ closure: @escaping (T) -> () throws -> Swift.Void, for object: T) -> () throws -> Swift.Void where T : AnyObject {
    { [weak object] in
        guard let object else { return }
        try closure(object)()
    }
}
@inlinable public func weakPerform<T, U>(_ closure: @escaping (T) -> (U) -> Swift.Void, for object: T) -> (U) -> Swift.Void where T : AnyObject {
    { [weak object] param in
        guard let object else { return }
        closure(object)(param)
    }
}
@inlinable public func weakPerform<T, U>(_ closure: @escaping (T) -> (U) throws -> Swift.Void, for object: T) -> (U) throws -> Swift.Void where T : AnyObject {
    { [weak object] param in
        guard let object else { return }
        try closure(object)(param)
    }
}
@inlinable public func weakPerform<T, U, V>(_ closure: @escaping (T) -> (U, V) -> Swift.Void, for object: T) -> (U, V) -> Swift.Void where T : AnyObject {
    { [weak object] param1, param2 in
        guard let object else { return }
        closure(object)(param1, param2)
    }
}
@inlinable public func weakPerform<T, U, V>(_ closure: @escaping (T) -> (U, V) throws -> Swift.Void, for object: T) -> (U, V) throws -> Swift.Void where T : AnyObject {
    { [weak object] param1, param2 in
        guard let object else { return }
        try closure(object)(param1, param2)
    }
}
@inlinable public func weakPerform<T, U, V, R>(_ closure: @escaping (T) -> (U, V, R) -> Swift.Void, for object: T) -> (U, V, R) -> Swift.Void where T : AnyObject {
    { [weak object] param1, param2, param3 in
        guard let object else { return }
        closure(object)(param1, param2, param3)
    }
}
@inlinable public func weakPerform<T, U, V, R>(_ closure: @escaping (T) -> (U, V, R) throws -> Swift.Void, for object: T) -> (U, V, R) throws -> Swift.Void where T : AnyObject {
    { [weak object] param1, param2, param3 in
        guard let object else { return }
        try closure(object)(param1, param2, param3)
    }
}
@discardableResult
public func with<A>(_ a: A, _ f: (A) throws -> Swift.Void) rethrows -> A
public func with<A>(_ a: inout A, _ f: (A) throws -> Swift.Void) rethrows
extension SDSoup.CompressionMethod : Swift.Equatable {}
extension SDSoup.CompressionMethod : Swift.Hashable {}
extension SDSoup.CompressionMethod : Swift.RawRepresentable {}
extension SDSoup.Archive.ArchiveError : Swift.Equatable {}
extension SDSoup.Archive.ArchiveError : Swift.Hashable {}
extension SDSoup.Archive.AccessMode : Swift.Equatable {}
extension SDSoup.Archive.AccessMode : Swift.Hashable {}
extension SDSoup.Archive.AccessMode : Swift.RawRepresentable {}
extension SDSoup.CompilationBuildType : Swift.Equatable {}
extension SDSoup.CompilationBuildType : Swift.Hashable {}
extension SDSoup.CompilationMode : Swift.Equatable {}
extension SDSoup.CompilationMode : Swift.Hashable {}
extension SDSoup.CompilationMode : Swift.BitwiseCopyable {}
extension SDSoup.Entry.EntryType : Swift.Equatable {}
extension SDSoup.Entry.EntryType : Swift.Hashable {}
extension SDSoup.Entry.EntryType : Swift.RawRepresentable {}
extension SDSoup.ImageFormat : Swift.Equatable {}
extension SDSoup.ImageFormat : Swift.Hashable {}
extension SDSoup._HashTable.UnsafeHandle : Swift.BitwiseCopyable {}
extension SDSoup.PermissionStatus : Swift.Equatable {}
extension SDSoup.PermissionStatus : Swift.Hashable {}
extension SDSoup.PhoneCountryType : Swift.Equatable {}
extension SDSoup.PhoneCountryType : Swift.Hashable {}
extension SDSoup.PhoneCountryType : Swift.RawRepresentable {}
extension SDSoup.GradientToken.Kind : Swift.Hashable {}
extension SDSoup.PlasmaColorScheme : Swift.Equatable {}
extension SDSoup.PlasmaColorScheme : Swift.Hashable {}
extension SDSoup.Plist.Error : Swift.Equatable {}
extension SDSoup.Plist.Error : Swift.Hashable {}
extension SDSoup.Regex.CharacterSet : Swift.Equatable {}
extension SDSoup.Regex.CharacterSet : Swift.Hashable {}
extension SDSoup.Regex.CharacterSet : Swift.RawRepresentable {}
extension SDSoup.StackTraceFilter.Mask : Swift.Hashable {}
extension SDSoup.StackTraceFilter.Mask : Swift.RawRepresentable {}
extension SDSoup.TapticFeedback : Swift.Hashable {}
extension UIKit.UIColor.HexType : Swift.Equatable {}
extension UIKit.UIColor.HexType : Swift.Hashable {}
extension UIKit.UIImage.AverageColorError : Swift.Equatable {}
extension UIKit.UIImage.AverageColorError : Swift.Hashable {}
extension SDSoup._HashTable.Bucket : Swift.Sendable {}
extension SDSoup._HashTable.Bucket : Swift.BitwiseCopyable {}
extension SDSoup._UnsafeBitset : Swift.BitwiseCopyable {}
extension SDSoup._UnsafeBitset.Iterator : Swift.BitwiseCopyable {}
extension SDSoup._UnsafeBitset.Word : Swift.BitwiseCopyable {}
extension SDSoup._UnsafeBitset.Word : Swift.Sendable {}
